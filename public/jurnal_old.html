<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // Înlocuiește cu cheia ta reală
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÎNLOCUIEȘTE AICI !!! (Asigură-te că NU este placeholder-ul!)
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17";
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configurată:", "'" + GEMINI_API_KEY + "'");

     if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") { // Am eliminat verificarea .startsWith()
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini inițializat. Model Feedback Jurnal:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare critică la inițializarea SDK Gemini:", e);
            let alertMessage = "Eroare la inițializarea serviciului AI pentru jurnal. Verificați cheia API Gemini și configurația.";
            if (e.message && e.message.toLowerCase().includes("api key not valid")) {
                alertMessage = "Cheia API Gemini nu este validă sau nu are permisiuni pentru modelul de jurnal. Verificați Google Cloud Console.";
            } else if (e.message && e.message.toLowerCase().includes("quota")) {
                alertMessage = "Limita de utilizare pentru API-ul Gemini a fost atinsă (posibil pentru modelul de jurnal).";
            }
            alert(alertMessage + " Funcționalitatea AI va fi limitată.");
            geminiModelJournalFeedback = null;
        }
    } else  {
        console.warn(`Jurnal Terapeutic: Cheia API Gemini este goală sau lipsește. Funcționalitatea AI va fi dezactivată.`);
        alert("Jurnal Terapeutic: Cheia API Gemini nu este configurată. Funcționalitatea AI pentru jurnal va fi dezactivată.");
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;
    let selectedPrompt = null; 

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
        
        // Global click listener to potentially hide activePromptBox if clicked outside form/prompts (optional UX enhancement)
        // document.addEventListener('click', function(event) {
        //     const formContainer = document.querySelector('.journal-form-container');
        //     const activePromptBox = document.getElementById('activePromptBox');
        //     if (activePromptBox && activePromptBox.style.display === 'block' && formContainer && !formContainer.contains(event.target)) {
        //          // toggleActivePrompt(false); // Comentat pentru a evita închideri nedorite la click pe body
        //     }
        // });
    };

    function toggleActivePrompt(show, promptData = null) {
        const box = document.getElementById('activePromptBox');
        const titleEl = document.getElementById('activePromptTitle');
        const contentEl = document.getElementById('activePromptContent');
        const journalTextarea = document.getElementById("journalContent");

        if (show && promptData) {
            selectedPrompt = promptData;
            titleEl.textContent = `Ghid activ: ${promptData.label}`;
            contentEl.textContent = promptData.text; // Afișează textul ghidului
            box.style.display = 'block';
            if(contentEl) contentEl.scrollTop = 0;
             // Opțional: Curăță textarea dacă se dorește și confirmă utilizatorul
            if (journalTextarea && journalTextarea.value.trim() !== "" && promptData.id !== (selectedPrompt?.previousIdForClearCheck)) {
                if (confirm("Dorești să ștergi conținutul actual al jurnalului pentru a începe cu acest nou ghid?")) {
                   journalTextarea.value = "";
                }
            }
            if(selectedPrompt) selectedPrompt.previousIdForClearCheck = promptData.id;


        } else { // Când se ascunde programatic (ex. după salvare) sau de către utilizator
            selectedPrompt = null; // Asigură-te că se resetează
            box.style.display = 'none';
        }
    }
    
    // Adaugă această funcție globală pentru butonul de închidere al prompt boxului
    window.hideActivePromptManual = function() {
        const box = document.getElementById('activePromptBox');
        box.style.display = 'none';
        // Nu reseta selectedPrompt aici, pentru că utilizatorul poate doar să-l ascundă temporar,
        // dar tot vrea să se considere că acel prompt e "activ" pentru AI.
        // SelectedPrompt se resetează în toggleActivePrompt(false) sau după salvare.
    }


    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [ // Structura ID-urilor e importantă pentru buildAdaptiveAIPrompt
            {
                label: "🌡️ Explorează o emoție",
                id: "explorare_emotie",
                text: "🌡️ *Astăzi simt...*\n" +
                      "Numește emoția dominantă: ________________\n\n" +
                      "🔍 *Unde o simt în corp?*\n" +
                      "Descrie senzațiile (tensiune, greutate, pulsație etc.): ________________\n\n" +
                      "💭 *Ce gânduri vin cu această emoție?*\n" +
                      "Notează gândurile automate, chiar dacă par „exagerate”: ________________\n\n" +
                      "📚 *În ce context a apărut?*\n" +
                      "Ce s-a întâmplat exact? Ce a declanșat-o? ________________\n\n" +
                      "💧 *Ce nevoie ar putea semnala?*\n" +
                      "De ce are nevoie această parte din tine? Ce lipsește? ________________\n\n" +
                      "💌 *Dacă aș avea compasiune pentru mine acum...*\n" +
                      "Ce mi-aș spune? Ce gest aș face pentru mine? ________________\n"
            },
            {
                label: "📝 Analizează o situație",
                id: "analiza_situatie",
                text: "Situația care mă preocupă este: ________________\n\n" +
                      "Ce s-a întâmplat exact? (Fapte): ________________\n" +
                      "Interpretarea mea inițială (Gânduri automate): ________________\n" +
                      "Emoțiile principale: ________________\n" +
                      "O altă perspectivă (Reframing): ________________\n" +
                      "Ce am învățat/pot învăța? (Lecții): ________________\n"
            },
            {
                label: "🗣️ Dialog Voce Critică",
                id: "dialog_voce_critica",
                text: "🗣️ *Vocea mea interioară îmi spune...*\n" +
                      "(\"Ești slab\", \"Nu faci destul\", \"O să fii respins\"...): ________________\n\n" +
                      "😔 *Când aud acest mesaj, mă simt...*\n" +
                      "(emoții și senzații fizice): ________________\n\n" +
                      "🧒 *Această voce seamănă cu...*\n" +
                      "(E o voce veche? un părinte? un profesor? un fost partener?): ________________\n\n" +
                      "🧠 *Ce nevoie neîmplinită e în spatele acestui mesaj?*\n" +
                      "(Poate recunoaștere, protecție, control, apartenență?): ________________\n\n" +
                      "🧘 *Răspunsul meu ca Adult Sănătos ar fi...*\n" +
                      "(\"Apreciez că vrei să mă protejezi, dar acum aleg altceva.\"): ________________\n"
            },
            {
                label: "💖 Recunoștință & Resurse",
                id: "recunostinta_resurse",
                text: "💖 *Astăzi aleg să văd ce e bun...*\n" +
                      "Sunt recunoscător/oare pentru:\n" +
                      "1. ________________\n" +
                      "2. ________________\n" +
                      "3. ________________\n\n" +
                      "🌱 *O resursă interioară pe care mă pot baza astăzi este...*\n" +
                      "(ex: curaj, blândețe, claritate, capacitatea de a simți): ________________\n\n" +
                      "🛁 *Un gest de auto-îngrijire pe care îl pot face azi...*\n" +
                      "(chiar dacă e mic): ________________\n"
            },
            {
                label: "🌀 Ritual Reconstrucție Interioară",
                id: "ritual_reconstructie",
                text: `🧭 MASTER TEMPLATE – Scriere Terapeutică de Integrare și Vindecare\n` +
                      `Denumire: „Ritual de reconstrucție interioară”\n` +
                      `Scop: Eliberare, Clarificare, Conținere, Înțelepciune, Direcție\n\n` +
                      `I. 🔍 INVITAȚIE LA AUTENTICITATE\n` +
                      `„Ce parte din mine cere atenție acum?”\n` +
                      `   * Ce trăiesc cu adevărat, fără filtru, fără poveste cosmetizată?\n` +
                      `   * Ce mi-e rușine să simt sau să recunosc chiar și în scris?\n` +
                      `   * Ce parte din mine se simte exclusă, neauzită, ignorată?\n` +
                      `Răspuns: ________________\n\n` +
                      `II. 🌊 CONTAINERE EMOȚIONALE\n` +
                      `„Ce simte corpul meu? Unde locuiește durerea?”\n` +
                      `   * Unde simt emoția în corp? Cum se manifestă? (Tensiune, înțepături, etc.)\n` +
                      `   * Dacă ar avea o culoare, formă, textură – cum ar arăta?\n` +
                      `   * Pot respira în acea zonă 3 minute, fără să fug?\n` +
                      `Răspuns: ________________\n\n` +
                      `III. 🧠 DECODIFICARE NARATIVĂ\n` +
                      `„Ce poveste îmi spun? Este întreagă?”\n` +
                      `   * Ce narațiune inconștientă guvernează trăirea mea? (ex: „Nu sunt dorit.”)\n` +
                      `   * De unde vine această narațiune? Când am mai trăit ceva similar?\n` +
                      `   * Ce parte din mine (copil rănit, etc.) scrie această poveste?\n` +
                      `Răspuns: ________________\n\n` +
                      `IV. 🧩 INTEGRARE EXPLICATIVĂ\n` +
                      `„Ce înțeleg nou despre mine din această durere?”\n` +
                      `   * Ce nevoi profunde au fost ignorate sau negate?\n` +
                      `   * Ce am protejat, de fapt, prin reacția mea?\n` +
                      `   * Ce emoții contradictorii coexistă în mine și ce spun ele?\n` +
                      `Răspuns: ________________\n\n` +
                      `V. 🪞 COMPASIUNE ȘI BLÂNDEȚE\n` +
                      `„Cum pot fi părinte pentru mine acum?”\n` +
                      `   * Dacă mi-aș ține partea rănită în brațe, ce i-aș spune?\n` +
                      `   * Ce aș vrea să aud din partea unei figuri ideale de susținere?\n` +
                      `   * Pot lăsa iubirea, nu logica, să conducă acest moment?\n` +
                      `Răspuns: ________________\n\n` +
                      `VI. 🔮 RECONFIGURARE IDENTITARĂ\n` +
                      `„Cine sunt eu dincolo de această rană?”\n` +
                      `   * Ce adevăr despre mine rămâne valabil, chiar și în durere?\n` +
                      `   * Cine devin dacă învăț să stau cu mine în acest spațiu?\n` +
                      `   * Dacă aș fi un personaj simbolic acum, cine aș fi?\n` +
                      `Răspuns: ________________\n\n` +
                      `VII. ✍️ ACTUL SACRU DE ALEGERE\n` +
                      `„Ce aleg de azi, pentru mine?”\n` +
                      `   * Ce merită să las să plece?\n` +
                      `   * Ce îmi iau ca învățătură de încredere în viață?\n` +
                      `   * Ce ritual zilnic/mic obicei pot începe pentru a onora această transformare?\n` +
                      `Răspuns: ________________\n\n` +
                      `VIII. (Opțional) 📜 SCRISOARE-RITUAL\n` +
                      `Scrie o scrisoare către... (persoana, partea din tine, situația):\n` + // Clarificare
                      `Răspuns: ________________\n`
            }
        ];
        promptsContainerEl.innerHTML = '';
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "Afișează acest ghid și folosește-l ca referință";
            button.onclick = () => {
                toggleActivePrompt(true, prompt);
                journalTextarea.focus();
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        // ... (Funcția callGeminiAPI rămâne la fel ca în versiunea anterioară pe care ți-am dat-o, cu logarea și gestionarea erorilor)
        if (!modelToUse) return "EROARE: Model AI neinițializat (jurnal).";
        try {
            console.log("Trimitem la Gemini (jurnal, primele 200 caractere):", promptText.substring(0, 200));
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.7, maxOutputTokens: 4000, ...generationConfigOptions } // Max token crescut ușor
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare oprită (Motiv: ${response.candidates[0].finishReason}). Detalii: ${JSON.stringify(response.candidates[0].safetyRatings || 'N/A')}`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Detalii: ${JSON.stringify(response.promptFeedback.blockReasonDetail || response.promptFeedback.safetyRatings || 'N/A')}`;
            }
            console.warn("Răspuns Gemini neașteptat sau gol:", JSON.stringify(response, null, 2));
            return "EROARE Gemini: Răspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            let userFriendlyError = `EROARE Gemini: ${error.message || "Eroare API necunoscută."}`;
            if (error.message && error.message.toLowerCase().includes("api key not valid")) {
                userFriendlyError = "EROARE: Cheia API Gemini nu este validă sau nu are permisiuni. Verificați configurația.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.message.toLowerCase().includes("resource has been exhausted")) ) ){
                userFriendlyError = "EROARE: Limita de utilizare API Gemini a fost depășită. Încercați mai târziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety") || error.message.toLowerCase().includes("blocked due to safety_settings"))){
                 userFriendlyError = "EROARE Gemini: Generarea a fost oprită, posibil din motive de siguranță sau din cauza conținutului. Încercați să reformulați sau verificați setările de siguranță dacă aveți acces."
            } else if (error.status && error.status === 400 && error.message.toLowerCase().includes("model") && error.message.toLowerCase().includes("doesn't support")){
                 userFriendlyError = `EROARE Gemini: Modelul ${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK} ar putea să nu suporte anumite funcționalități sau configurare. Verificați documentația.`;
            }
            return userFriendlyError;
        }
    }
    
    function getSelectedPromptType() {
        // Dacă un ghid a fost selectat (este în `activePromptBox`), folosim ID-ul lui.
        if (selectedPrompt && selectedPrompt.id) {
            return selectedPrompt.id;
        }
        // Ca fallback, dacă utilizatorul a scris liber dar a inclus cumva cuvinte cheie
        // (mai puțin probabil acum, dar bun pentru robustețe/intrări vechi):
        const journalContent = document.getElementById("journalContent")?.value || "";
        return detectPromptUsed(journalContent);
    }

    function detectPromptUsed(content) {
        // ... (Funcția detectPromptUsed rămâne la fel ca în versiunea anterioară)
        if (!content) return "prompt_personalizat";
        content = content.toLowerCase();

        if (content.includes("ce parte din mine cere atenție acum") && content.includes("master template")) return "ritual_reconstructie";
        if (content.includes("vocea mea interioară îmi spune") || content.includes("vocea mea critică îmi spune")) return "dialog_voce_critica";
        if (content.includes("astăzi simt...") && content.includes("numește emoția dominantă:")) return "explorare_emotie";
        if (content.includes("astăzi aleg să văd ce e bun") && content.includes("sunt recunoscător/oare pentru:")) return "recunostinta_resurse";
        if (content.includes("situația care mă preocupă este:")) return "analiza_situatie";
        return "prompt_personalizat";
    }

    function buildAdaptiveAIPrompt(entryTitle, journalText, promptType, guideText = null) {
        // ... (Funcția buildAdaptiveAIPrompt rămâne la fel ca în versiunea anterioară,
        // dar am adăugat parametrul opțional `guideText`)
        let specificInstructions = "";
        let modelFocus = "feedback general și reflecție";

        let basePrompt = `Ești PsihoGPT – un terapeut AI avansat, extrem de empatic, cu o profundă înțelegere a psihologiei umane, antrenat în Terapie Cognitiv-Comportamentală (TCC), Terapia Schemelor, Terapia prin Acceptare și Angajament (ACT), Scrierea Expresivă și principii de mindfulness. Comunică într-un limbaj cald, validant și ușor de înțeles, dar păstrează profunzimea analitică. Folosește formatare Markdown pentru structurare (titluri principale cu \`**Titlu Principal**\`, subtitluri dacă e cazul cu \`### Subtitlu\`, liste cu \`* Element listă\`, text bold cu \`**text bold**\` și italic cu \`*text italic*\` unde e cazul). Evită citatele direct din literatură dacă nu sunt absolut esențiale, concentrează-te pe limbajul tău.

Obiectivul tău este să oferi un feedback personalizat, constructiv și profund pentru următoarea intrare în jurnal. Nu oferi sfaturi medicale sau diagnostice. Concentrează-te pe facilitarea auto-înțelegerii și a creșterii personale. Utilizatorul a avut la dispoziție un ghid vizual (tipul: "${promptType}") pentru a-și structura gândurile, iar textul de mai jos reprezintă răspunsurile sale la acel ghid sau o reflecție liberă inspirată de el.`;
        
        // Instrucțiuni specifice (rămân la fel)
        switch (promptType) {
            case "ritual_reconstructie":
                specificInstructions = `
Utilizatorul a folosit ghidul "Ritual de Reconstrucție Interioară", care are 7 secțiuni principale (I. Invitație la Autenticitate, II. Containere Emoționale, III. Decodificare Narativă, IV. Integrare Explicativă, V. Compasiune și Blândețe, VI. Reconfigurare Identitară, VII. Actul Sacru de Alegere) și poate o secțiune VIII (Scrisoare-Ritual).
Feedback-ul tău AR TREBUI SĂ URMEZE ACEASTĂ STRUCTURĂ. Pentru FIECARE secțiune a ritualului (I-VII și opțional VIII):
1.  **Numește secțiunea clar** (ex: \`**I. Invitație la Autenticitate:**\`).
2.  Pe baza textului utilizatorului (\`Text Complet Jurnal Utilizator\` de mai jos), **extrage și reflectă** ce a scris sau ce pare să fi explorat pentru ACEASTĂ secțiune specifică. Fii concis și la obiect. Dacă utilizatorul nu pare să fi adresat o secțiune, menționează scurt (ex: "Pentru această secțiune, nu par să existe răspunsuri detaliate în textul furnizat.") sau sari peste ea cu eleganță dacă e goală.
3.  **Oferă o scurtă validare empatică** dacă a completat ceva relevant pentru secțiune.
4.  **Pune 1-2 întrebări de aprofundare SPECIFICE** pentru acea secțiune, care să invite la o reflecție mai adâncă asupra celor descoperite acolo *de către utilizator*. Întrebările trebuie să fie direct legate de conținutul reflectat de la punctul 2.
După ce ai parcurs secțiunile individuale, adaugă o secțiune de \`**### Concluzii și Reflecții Finale:**\`
*   **Sinteza Conexiunilor:** Identifică și subliniază pe scurt 1-2 conexiuni sau teme generale care par să lege diferitele răspunsuri ale utilizatorului de-a lungul ritualului.
*   **Încurajare și Pași Următori:** Încurajează procesul de transformare schițat în special în secțiunea VII (Actul Sacru de Alegere) și apreciază vulnerabilitatea. Poți sugera o mică intenție sau un focus pentru zilele următoare, bazat pe întregul ritual.
Fii analitic și profund, dar și uman și susținător. Evită răspunsurile generice; personalizează feedback-ul la maximum pe baza textului furnizat de utilizator.`;
                modelFocus = "analiză structurată a ritualului de reconstrucție, pas cu pas, corelând textul utilizatorului cu fiecare secțiune a ghidului, oferind reflecție și întrebări de aprofundare per secțiune, plus o sinteză finală.";
                break;
            case "dialog_voce_critica":
                specificInstructions = `
Utilizatorul a folosit ghidul "Dialog Voce Critică". Analizează răspunsurile sale și structurează feedback-ul astfel:
1.  **\`**Validare Empatică Inițială:\`** Recunoaște dificultatea și curajul de a confrunta vocea critică.
2.  **\`**Analiza Mesajului Critic:\`** Pe baza răspunsului la "Vocea mea interioară îmi spune...", reflectă mesajul central al vocii critice. Ce temeri sau convingeri de bază par să fie active?
3.  **\`**Impactul Emoțional și Corporal:\`** Cum descrie utilizatorul impactul vocii critice ("Când aud acest mesaj, mă simt...")? Validează aceste trăiri.
4.  **\`**Originea Vocii (dacă e explorată):\`** Dacă utilizatorul a răspuns la "Această voce seamănă cu...", comentează pe scurt această asociere și ce ar putea implica.
5.  **\`**Nevoia Neîmplinită:\`** Ce nevoie neîmplinită a identificat utilizatorul în spatele mesajului critic? Este aceasta o pistă importantă?
6.  **\`**Forța Adultului Sănătos:\`** Cum a formulat utilizatorul răspunsul Adultului Sănătos? Reflectă punctele forte ale acestui răspuns (compasiune, asertivitate, realism etc.).
7.  **\`**### Întrebări de Aprofundare și Direcții:\`** (1-2 întrebări) Ex: "*Ce mic pas ai putea face săptămâna aceasta pentru a întări și mai mult vocea Adultului tău Sănătos în fața criticii interne?*", "*Există vreo situație specifică recentă unde ai putea exersa conștient acest răspuns al Adultului Sănătos?*"
8.  **\`**Notă despre Scheme (opțional, foarte discret):\`** Dacă este foarte evident, poți adăuga: "*Uneori, aceste voci critice pot fi legate de tipare mai vechi de auto-percepție, numite în terapie 'scheme'. Dacă simți că rezonează, ar putea fi o direcție de explorat.*"`;
                modelFocus = "analiză detaliată a dialogului cu vocea critică, evidențiind fiecare componentă a ghidului și oferind piste concrete de reflecție și acțiune pentru cultivarea Adultului Sănătos.";
                break;
            case "explorare_emotie":
                specificInstructions = `
Utilizatorul a folosit ghidul "Explorează o emoție". Feedback-ul tău trebuie să parcurgă pașii ghidului:
1.  **\`**Validarea Emoției Denumite:\`** Recunoaște și validează emoția pe care utilizatorul a identificat-o.
2.  **\`**Conexiunea Corp-Emoție:\`** Cum a descris utilizatorul senzațiile corporale? Ce ne spune asta despre cum trăiește emoția respectivă?
3.  **\`**Relația Gânduri-Emoție:\`** Ce gânduri automate a asociat utilizatorul cu emoția? Cum par acestea să influențeze intensitatea sau calitatea emoției? Există distorsiuni cognitive evidente?
4.  **\`**Contextul și Declanșatorul:\`** Pe baza descrierii contextului, ce pare să fi fost elementul declanșator principal?
5.  **\`**Nevoia Fundamentală Semnalată:\`** Ce nevoie a identificat utilizatorul? Cât de conectată pare această nevoie de emoție și situație? Este o nevoie universală sau una mai specifică?
6.  **\`**Gestul de Auto-Compasiune:\`** Cum a intenționat utilizatorul să-și ofere compasiune? Cât de important și vindecător poate fi acest gest?
7.  **\`**### Reflecții Suplimentare și Întrebări:\`** (1-2 întrebări) Ex: "*Ce ai învățat nou despre această emoție (sau despre tine în raport cu ea) prin acest exercițiu?*", "*Dacă ai putea menține vie intenția de auto-compasiune, ce mică schimbare ar aduce asta în modul cum gestionezi această emoție data viitoare când apare?*"`;
                modelFocus = "analiză pas cu pas a explorării emoției, de la denumire la auto-compasiune, cu accent pe înțelegerea profundă a componentelor și încurajarea integrării.";
                break;
            case "recunostinta_resurse":
                specificInstructions = `
Utilizatorul a folosit ghidul "Recunoștință & Resurse". Structurează feedback-ul astfel:
1.  **\`**Aprecierea Practicii Recunoștinței:\`** Începe prin a valoriza gestul de a se concentra pe recunoștință.
2.  **\`**Observații asupra Elementelor de Recunoștință:\`** Există teme comune în cele trei lucruri pentru care este recunoscător/oare? Ce arată acestea despre ce prețuiește utilizatorul?
3.  **\`**Explorarea Resursei Interioare:\`** Cum poate resursa interioară menționată să fie o ancoră sau un sprijin în viața de zi cu zi, mai ales în provocări? Cum ar putea fi cultivată și mai conștient?
4.  **\`**Impactul Gestului de Auto-Îngrijire:\`** Cât de important este acest gest, fie el și mic, pentru bunăstarea generală? Încurajează regularitatea.
5.  **\`**### Întrebări pentru Consolidare:\`** (1-2 întrebări) Ex: "*Cum te-a făcut să te simți acest exercițiu de conectare cu recunoștința și resursele tale?*", "*Ce ai putea face mâine pentru a te reconecta, chiar și pentru un minut, cu sentimentul de recunoștință sau cu resursa interioară pe care ai identificat-o?*"`;
                modelFocus = "încurajarea și validarea practicii recunoștinței și a conectării la resursele interioare, cu sugestii de integrare și consolidare.";
                break;
            case "analiza_situatie":
                specificInstructions = `
Utilizatorul a folosit ghidul "Analizează o situație". Feedback-ul tău trebuie să reflecte structura ghidului:
1.  **\`**Recunoașterea Efortului Analitic:\`** Validează demersul structurat de a înțelege situația.
2.  **\`**Situația și Faptele:\`** Reflectă pe scurt situația și faptele, așa cum au fost descrise.
3.  **\`**Interpretarea Inițială și Emoțiile:\`** Care au fost gândurile automate și emoțiile principale identificate de utilizator? Există vreo distorsiune evidentă în gândurile automate?
4.  **\`**Puterea Reîncadrării (Reframing):\`** Comentează perspectiva alternativă oferită. Cât de diferită este? Ce noi posibilități sau sentimente deschide această reîncadrare?
5.  **\`**Lecții Învățate:\`** Care sunt învățămintele principale pe care utilizatorul le-a extras sau le poate extrage?
6.  **\`**### Întrebări pentru Acțiune și Integrare:\`** (1-2 întrebări) Ex: "*Ce mică acțiune, inspirată de 'altă perspectivă' sau de 'lecțiile învățate', ai putea întreprinde dacă o situație similară ar apărea din nou?*", "*Cum te-ar ajuta să-ți reamintești de această 'altă perspectivă' în momentele tensionate?*"`;
                modelFocus = "susținerea analizei de situație prin reflectarea pașilor, cu focus pe puterea reîncadrării și pe transpunerea lecțiilor în acțiuni concrete.";
                break;
            default: // prompt_personalizat sau neidentificat
                specificInstructions = `
Utilizatorul a scris o intrare liberă în jurnal. Feedback-ul tău ar trebui să fie empatic și să invite la explorare:
1.  **\`**Validare Empatică Generală:\`** Începe cu o validare caldă pentru ceea ce a fost exprimat. Recunoaște deschiderea și reflectă emoția sau tonul general care reiese din text.
2.  **\`**Identificarea Temelor Centrale (1-2):\`** Cu grijă, identifică 1-2 teme, emoții sau preocupări principale. Poți folosi citate foarte scurte (1-3 cuvinte) pentru a ilustra.
3.  **\`**Reflecție Oglindă:\`** Ce pare să fie cel mai important pentru utilizator în această scriere? Ce anume iese în evidență?
4.  **\`**### Întrebări Deschise și Evocatoare (2-3):\`** Pune întrebări care să stimuleze auto-descoperirea. Exemple: "*Citind despre [temă specifică], ce altceva ai observat despre tine sau despre perspectiva ta?*", "*Dacă această parte din tine care a scris ar putea cere ceva, ce crezi că ar fi?*", "*Ce simți că ai nevoie cel mai mult acum, după ce ai așternut aceste gânduri/emoții pe hârtie (digitală)?*".
5.  **\`**Încurajare Finală:\`** Oferă o scurtă încurajare pentru continuarea procesului de auto-reflecție prin scris.`;
                modelFocus = "reflecție empatică asupra textului liber, identificare teme și facilitarea explorării prin întrebări deschise, fără a fi directiv.";
                break;
        }
        
        const ghidReferintaText = guideText ? `\n\n--- TEXTUL GHIDULUI DE REFERINȚĂ (NU RĂSPUNSURILE UTILIZATORULUI) ---\n\`\`\`\n${guideText}\n\`\`\`\nUtilizatorul a avut acest ghid afișat și a scris răspunsurile în secțiunea "Text Complet Jurnal Utilizator" de mai jos.` : "\n\nUtilizatorul a scris liber sau detaliile specifice ale ghidului nu sunt furnizate aici; concentrează-te pe răspunsurile utilizatorului și tipul de ghid general.";


        const finalPrompt = `${basePrompt}
${ghidReferintaText}

**Focusul specific pentru această intrare de jurnal (bazat pe ghidul "${promptType}") este: ${modelFocus}.**

**Instrucțiuni specifice pentru feedback bazat pe tipul de ghid ("${promptType}"):**
${specificInstructions}
---
**INFORMAȚII DESPRE INTRAREA UTILIZATORULUI:**
Titlu Jurnal: ${entryTitle || "Fără titlu"}
Tipul de Ghid Utilizat (selectat de utilizator / detectat): ${promptType}

**TEXT COMPLET JURNAL UTILIZATOR (RĂSPUNSURILE SALE):**
\`\`\`
${journalText}
\`\`\`
---
Te rog să generezi un feedback AI detaliat, empatic și structurat conform instrucțiunilor de mai sus, personalizat pe baza textului furnizat de utilizator. Asigură-te că respecți formatarea Markdown cerută pentru lizibilitate. Mulțumesc!`;

        return finalPrompt;
    }


    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: Funcționalitatea AI pentru jurnal nu este disponibilă.";
        
        const promptType = entryData.promptTypeUtilizat || detectPromptUsed(entryData.continut);
        // Preluăm textul ghidului original, dacă e posibil și selectedPrompt corespunde (mai ales la generarea inițială)
        let textGhidOriginal = null;
        if (selectedPrompt && selectedPrompt.id === promptType) {
            textGhidOriginal = selectedPrompt.text;
        } else { // Fallback pentru regenerare dacă selectedPrompt nu mai e setat corect
            const promptsList = (typeof initializeReflectionPrompts.prompts !== 'undefined') ? initializeReflectionPrompts.prompts : []; // Asumând că stocăm undeva lista de prompts
            const ghidGasit = promptsList.find(p => p.id === promptType);
            if (ghidGasit) textGhidOriginal = ghidGasit.text;
        }

        const promptJurnalAdaptiv = buildAdaptiveAIPrompt(entryData.titlu, entryData.continut, promptType, textGhidOriginal);

        console.log(`Jurnal - Regenerare/Generare Feedback pentru tipul: ${promptType}. Se trimite și textul ghidului original dacă este disponibil.`);
        const feedbackText = await callGeminiAPI(promptJurnalAdaptiv, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId, promptType);
    }
    
    // Stocăm referința la lista de prompt-uri într-un loc accesibil pentru funcția de mai sus.
    // O modalitate e să o atașăm funcției `initializeReflectionPrompts` după ce e definită.
    // Sau o definim global în script, dar asta poate fi mai puțin curat.
    // Alegem varianta mai simplă pentru contextul dat:
    (function() {
      const promptsInternal = [
            { id: "explorare_emotie", text: "..." }, // prescurtat; copiază textul complet de la initializeReflectionPrompts
            { id: "analiza_situatie", text: "..." },
            { id: "dialog_voce_critica", text: "..." },
            { id: "recunostinta_resurse", text: "..." },
            { id: "ritual_reconstructie", text: "..." }
      ];
       // Trebuie completate textele aici ca în `initializeReflectionPrompts`
       promptsInternal[0].text = `🌡️ *Astăzi simt...*\nNumește emoția dominantă: ________________\n\n🔍 *Unde o simt în corp?*\nDescrie senzațiile (tensiune, greutate, pulsație etc.): ________________\n\n💭 *Ce gânduri vin cu această emoție?*\nNotează gândurile automate, chiar dacă par „exagerate”: ________________\n\n📚 *În ce context a apărut?*\nCe s-a întâmplat exact? Ce a declanșat-o? ________________\n\n💧 *Ce nevoie ar putea semnala?*\nDe ce are nevoie această parte din tine? Ce lipsește? ________________\n\n💌 *Dacă aș avea compasiune pentru mine acum...*\nCe mi-aș spune? Ce gest aș face pentru mine? ________________\n`;
       promptsInternal[1].text = `Situația care mă preocupă este: ________________\n\nCe s-a întâmplat exact? (Fapte): ________________\nInterpretarea mea inițială (Gânduri automate): ________________\nEmoțiile principale: ________________\nO altă perspectivă (Reframing): ________________\nCe am învățat/pot învăța? (Lecții): ________________\n`;
       promptsInternal[2].text = `🗣️ *Vocea mea interioară îmi spune...*\n(\"Ești slab\", \"Nu faci destul\", \"O să fii respins\"...): ________________\n\n😔 *Când aud acest mesaj, mă simt...*\n(emoții și senzații fizice): ________________\n\n🧒 *Această voce seamănă cu...*\n(E o voce veche? un părinte? un profesor? un fost partener?): ________________\n\n🧠 *Ce nevoie neîmplinită e în spatele acestui mesaj?*\n(Poate recunoaștere, protecție, control, apartenență?): ________________\n\n🧘 *Răspunsul meu ca Adult Sănătos ar fi...*\n(\"Apreciez că vrei să mă protejezi, dar acum aleg altceva.\"): ________________\n`;
       promptsInternal[3].text = `💖 *Astăzi aleg să văd ce e bun...*\nSunt recunoscător/oare pentru:\n1. ________________\n2. ________________\n3. ________________\n\n🌱 *O resursă interioară pe care mă pot baza astăzi este...*\n(ex: curaj, blândețe, claritate, capacitatea de a simți): ________________\n\n🛁 *Un gest de auto-îngrijire pe care îl pot face azi...*\n(chiar dacă e mic): ________________\n`;
       promptsInternal[4].text = `🧭 MASTER TEMPLATE – Scriere Terapeutică de Integrare și Vindecare\nDenumire: „Ritual de reconstrucție interioară”\nScop: Eliberare, Clarificare, Conținere, Înțelepciune, Direcție\n\nI. 🔍 INVITAȚIE LA AUTENTICITATE\n„Ce parte din mine cere atenție acum?”\n   * Ce trăiesc cu adevărat, fără filtru, fără poveste cosmetizată?\n   * Ce mi-e rușine să simt sau să recunosc chiar și în scris?\n   * Ce parte din mine se simte exclusă, neauzită, ignorată?\nRăspuns: ________________\n\nII. 🌊 CONTAINERE EMOȚIONALE\n„Ce simte corpul meu? Unde locuiește durerea?”\n   * Unde simt emoția în corp? Cum se manifestă? (Tensiune, înțepături, etc.)\n   * Dacă ar avea o culoare, formă, textură – cum ar arăta?\n   * Pot respira în acea zonă 3 minute, fără să fug?\nRăspuns: ________________\n\nIII. 🧠 DECODIFICARE NARATIVĂ\n„Ce poveste îmi spun? Este întreagă?”\n   * Ce narațiune inconștientă guvernează trăirea mea? (ex: „Nu sunt dorit.”)\n   * De unde vine această narațiune? Când am mai trăit ceva similar?\n   * Ce parte din mine (copil rănit, etc.) scrie această poveste?\nRăspuns: ________________\n\nIV. 🧩 INTEGRARE EXPLICATIVĂ\n„Ce înțeleg nou despre mine din această durere?”\n   * Ce nevoi profunde au fost ignorate sau negate?\n   * Ce am protejat, de fapt, prin reacția mea?\n   * Ce emoții contradictorii coexistă în mine și ce spun ele?\nRăspuns: ________________\n\nV. 🪞 COMPASIUNE ȘI BLÂNDEȚE\n„Cum pot fi părinte pentru mine acum?”\n   * Dacă mi-aș ține partea rănită în brațe, ce i-aș spune?\n   * Ce aș vrea să aud din partea unei figuri ideale de susținere?\n   * Pot lăsa iubirea, nu logica, să conducă acest moment?\nRăspuns: ________________\n\nVI. 🔮 RECONFIGURARE IDENTITARĂ\n„Cine sunt eu dincolo de această rană?”\n   * Ce adevăr despre mine rămâne valabil, chiar și în durere?\n   * Cine devin dacă învăț să stau cu mine în acest spațiu?\n   * Dacă aș fi un personaj simbolic acum, cine aș fi?\nRăspuns: ________________\n\nVII. ✍️ ACTUL SACRU DE ALEGERE\n„Ce aleg de azi, pentru mine?”\n   * Ce merită să las să plece?\n   * Ce îmi iau ca învățătură de încredere în viață?\n   * Ce ritual zilnic/mic obicei pot începe pentru a onora această transformare?\nRăspuns: ________________\n\nVIII. (Opțional) 📜 SCRISOARE-RITUAL\nScrie o scrisoare către... (persoana, partea din tine, situația):\nRăspuns: ________________\n`;

      // Expunem lista global prin atașare la o funcție (hacky, dar funcțional în context limitat)
      // O soluție mai bună ar fi un mic modul de management al prompturilor dacă proiectul crește.
      initializeReflectionPrompts.prompts = promptsInternal;
    })();


    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId, promptType = "necunoscut") {
        // ... (Funcția proceseazaSiStructureazaFeedbackJurnal rămâne la fel)
         const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            promptTypeAtGeneration: promptType, 
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        // ... (Funcția salveazaIntrareJurnalSiGenereazaFeedback rămâne aproape la fel,
        // dar se asigură că `toggleActivePrompt(false)` și `selectedPrompt = null` se apelează la final)
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva în jurnal."); return; }

        const tipPromptFolosit = getSelectedPromptType(); // Determină tipul ghidului activ

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid,
            promptTypeUtilizat: tipPromptFolosit 
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salvează..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');
        confirmationMsg.style.display = 'none'; // Ascunde mesajul anterior

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se generează AI...";
            
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id);
            
            const docSnapshot = await getDoc(docRef); 
            if (docSnapshot.exists()) {
                 afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            } else { 
                 console.warn("Documentul nu a fost găsit imediat după adăugare/update. Afișare cu date parțiale.");
                 entryData.id = docRef.id; 
                 entryData.feedbackAI_latest = parsedFeedback;
                 entryData.feedbackAI_history = [parsedFeedback];
                 afiseazaCardJurnal(entryData);
            }
            
            journalTextarea.value = ""; 
            if (journalTitleInput) journalTitleInput.value = "";
            toggleActivePrompt(false); // Ascunde ghidul activ
            // selectedPrompt se resetează în interiorul toggleActivePrompt(false)
            if(selectedPrompt) selectedPrompt.previousIdForClearCheck = null; // Reset pentru verificarea de curățare

            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvată. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvată și feedback AI generat! Îl poți vedea în cardul nou creat.';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau la generarea feedback-ului AI. Verifică consola pentru detalii.';
            confirmationMsg.className = 'confirmation-message error';
        } finally {
            confirmationMsg.style.display = 'block';
            setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 9000);
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        // ... (Funcția regenereazaFeedbackJurnal rămâne la fel)
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se generează..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');
        if(confirmationMsg) confirmationMsg.style.display = 'none';


        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { 
                const msg = "Eroare: Intrarea nu a fost găsită pentru regenerare.";
                if(confirmationMsg) { confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; } 
                else { alert(msg); }
                return; 
            }
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId); 
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); 
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) {
                    afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
                }
            }
            const message = parsedFeedback.error ? `Feedback AI: ${parsedFeedback.rawText}` : "Feedback AI regenerat și adăugat la istoric!";
            if(confirmationMsg) {
                confirmationMsg.textContent = message;
                confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
                confirmationMsg.style.display = 'block';
                setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                alert(message);
            }

        } catch (e) { 
            console.error("Eroare regenerare:", e); 
            const msg = "Eroare la regenerarea feedback-ului AI. Verificați consola.";
            if(confirmationMsg) {
                confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block';
                setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                 alert(msg);
            }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        // ... (Funcția stergeUltimulFeedbackJurnal rămâne la fel)
        if (!confirm("Ștergi ultimul feedback AI pentru această intrare? Această acțiune nu poate fi anulată.")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se șterge..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');
        if(confirmationMsg) confirmationMsg.style.display = 'none';

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                const msg = "Nu există feedback de șters pentru această intrare.";
                if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message warning'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);}
                else { alert(msg); }
                return;
            }
            const history = entrySnap.data().feedbackAI_history;
            history.pop(); 

            await updateDoc(entryDocRef, {
                feedbackAI_history: history,
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            
            const msg = "Ultimul feedback AI a fost șters cu succes.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message success'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }

        } catch (e) { 
            console.error("Eroare ștergere ultim feedback:", e); 
            const msg = "Eroare la ștergerea feedback-ului. Verificați consola.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, feedbackHistory) {
        // ... (Funcția afiseazaIstoricFeedbackJurnal rămâne la fel, cu parsarea Markdown îmbunătățită)
        containerEl.innerHTML = ''; 

        if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
            const noHistoryMsg = document.createElement("p");
            noHistoryMsg.textContent = "Niciun feedback AI generat pentru această intrare.";
            noHistoryMsg.className = "no-feedback-message";
            containerEl.appendChild(noHistoryMsg);
            return;
        }

        feedbackHistory.slice().reverse().forEach((entry, index) => {
            const itemContainer = document.createElement("div");
            itemContainer.className = "feedback-entry-card"; 

            const timestampAndModel = document.createElement("p");
            timestampAndModel.className = "feedback-timestamp";
            const modelInfo = entry.model || 'N/A';
            const promptTypeInfo = entry.promptTypeAtGeneration ? ` (Ghid folosit la generare: ${entry.promptTypeAtGeneration.replace(/_/g, ' ')})` : '';
            timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - ${modelInfo}${promptTypeInfo})`;
            itemContainer.appendChild(timestampAndModel);

            const contentWrapper = document.createElement("div"); 
            contentWrapper.className = "content-ai"; 

            if (entry.error) {
                const errorP = document.createElement("p");
                errorP.className = "ai-text-error";
                errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>'); // Simplu afișare eroare
                contentWrapper.appendChild(errorP);
            } else {
                let textToProcess = entry.rawText || 'Conținut indisponibil.';
                let finalHtmlElements = []; 
                const lines = textToProcess.split('\n');
                let currentParagraphContent = [];
                let inList = false;
                let currentListElement = null; // va fi UL sau OL

                for (const line of lines) {
                    // 1. Verifică Titlurile Principale (ex: **Titlu**, ### Titlu)
                    const matchTitle = line.match(/^\s*(?:(\*\*|###|\##|\#)\s*([^#*]+)\s*(?:\1)?\s*)$/);

                    if (matchTitle && matchTitle[2] && matchTitle[2].trim().length > 0) {
                        if (currentParagraphContent.length > 0) { // Adaugă paragraful anterior
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>'); // Use <br> for newlines within a paragraph
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                         if (inList && currentListElement) { // Termină lista anterioară
                            finalHtmlElements.push(currentListElement);
                            inList = false; currentListElement = null;
                        }

                        const titleMarker = matchTitle[1]; // **, ###, ##, #
                        let titleLevel = 2; // Default H2 pentru **
                        if (titleMarker.startsWith('#')) {
                            titleLevel = titleMarker.length;
                            if (titleLevel > 4) titleLevel = 4; // Max H4 pentru consistență vizuală
                        }
                        const titleEl = document.createElement(`h${titleLevel}`);
                        titleEl.className = 'ai-main-section-title';
                        // Pentru **Titlu**, matchTitle[2] conține 'Titlu'. Pentru # Titlu, matchTitle[2] conține 'Titlu'.
                        let titleText = matchTitle[2].trim();
                        titleText = titleText.replace(/\*\*(.*?)\*\*/g, '$1').replace(/__(.*?)__/g, '$1'); // Curăță bold din titluri dacă AI-ul le dublează
                        titleEl.textContent = titleText;
                        finalHtmlElements.push(titleEl);
                        continue; 
                    }

                    // 2. Verifică Elementele de Listă (ex: * Item, - Item, + Item, 1. Item)
                    const matchListItem = line.match(/^\s*([\*\-\+]|\d+\.)\s+(.*)/);
                    if (matchListItem) {
                        if (currentParagraphContent.length > 0) { // Adaugă paragraful anterior
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        if (!inList) { // Începe o listă nouă
                            inList = true;
                            currentListElement = document.createElement(matchListItem[1].match(/\d+\./) ? 'ol' : 'ul');
                            currentListElement.className = 'ai-list';
                        } else { // Verifică dacă tipul de listă s-a schimbat (ex: de la * la 1.)
                             const newListTypeIsOrdered = !!matchListItem[1].match(/\d+\./);
                             const currentListIsOrdered = currentListElement.tagName === 'OL';
                             if (newListTypeIsOrdered !== currentListIsOrdered) {
                                 // Tipul listei s-a schimbat, încheie lista veche, începe una nouă
                                 finalHtmlElements.push(currentListElement);
                                 currentListElement = document.createElement(newListTypeIsOrdered ? 'ol' : 'ul');
                                 currentListElement.className = 'ai-list';
                             }
                        }
                        const listItem = document.createElement('li');
                        listItem.className = 'ai-list-item';
                        let itemHtml = matchListItem[2]; // Conținutul itemului de listă
                        itemHtml = itemHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                        itemHtml = itemHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                        listItem.innerHTML = itemHtml;
                        currentListElement.appendChild(listItem);
                        continue; 
                    }
                    
                    // Dacă nu e titlu sau listă, și eram într-o listă, terminăm lista.
                    if (inList && currentListElement) {
                        finalHtmlElements.push(currentListElement);
                        inList = false; currentListElement = null;
                    }

                    // 3. Text normal sau linie goală
                    if (line.trim() === "") {
                        if (currentParagraphContent.length > 0) { // Adaugă paragraful adunat
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        // Pentru linii goale, adăugăm un <br> dacă urmează conținut, pentru spațiere
                        const nextNonEmptyLineIndex = lines.findIndex((l, i) => i > lines.indexOf(line) && l.trim() !== "");
                        if (nextNonEmptyLineIndex !== -1) {
                           // Nu adăugăm <br> explicit, paragrafele vor crea spațiu
                        }
                    } else { // Linie de text normal, adaug-o la paragraful curent
                        currentParagraphContent.push(line);
                    }
                }

                // Adaugă ultimul paragraf adunat, dacă există
                if (currentParagraphContent.length > 0) {
                    const p = document.createElement('p');
                    p.className = 'ai-text-paragraph';
                    let paragraphHtml = currentParagraphContent.join('<br>');
                    paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                    paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                    p.innerHTML = paragraphHtml;
                    finalHtmlElements.push(p);
                }
                // Adaugă ultima listă, dacă eram într-una
                 if (inList && currentListElement) {
                    finalHtmlElements.push(currentListElement);
                }

                finalHtmlElements.forEach(el => contentWrapper.appendChild(el));
            }
            itemContainer.appendChild(contentWrapper);
            containerEl.appendChild(itemContainer);
        });
    }

    function afiseazaCardJurnal(entryData) {
        // ... (Funcția afiseazaCardJurnal rămâne la fel ca în versiunea anterioară, cu detaliile jurnalului în <details>)
        const container = document.getElementById("journalEntriesContainer");
        let card = container.querySelector(`.journal-card[data-id="${entryData.id}"]`);
        
        const entryDate = entryData.dataIntrare || (entryData.timestampCreare?.toDate ? new Date(entryData.timestampCreare.toDate()).toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }) : 'Dată necunoscută');
        const entryTitle = entryData.titlu || `Intrare din ${entryDate}`;
        // Formatăm tipul de prompt pentru afișare
        let promptTypeDisplay = "";
        if (entryData.promptTypeUtilizat && entryData.promptTypeUtilizat !== "prompt_personalizat") {
            promptTypeDisplay = entryData.promptTypeUtilizat.replace(/_/g, ' ');
            promptTypeDisplay = promptTypeDisplay.charAt(0).toUpperCase() + promptTypeDisplay.slice(1); // Capitalize
            promptTypeDisplay = ` (Ghid: ${promptTypeDisplay})`;
        } else if (entryData.promptTypeUtilizat === "prompt_personalizat"){
            promptTypeDisplay = " (Scriere liberă)";
        }


        if (!card) { 
            card = document.createElement("div");
            card.className = "response-card journal-card"; 
            card.setAttribute("data-id", entryData.id);
            card.innerHTML = `
                <div class="card-header">
                    <span>${entryTitle}${promptTypeDisplay}</span>
                    <span class="card-date">${entryDate}</span>
                </div>
                <div class="card-content">
                    <details class="journal-entry-details">
                        <summary>Vezi/Ascunde textul intrării de jurnal</summary>
                        <p class="journal-entry-content-text">${entryData.continut.replace(/\n/g, '<br>')}</p>
                    </details>
                    <h4>Feedback AI <span style="font-weight:300; font-style:italic; font-size:0.85em;">(PsihoGPT)</span></h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                         <button class="regenerate-feedback-button" title="Regenerează Feedback AI pentru această intrare">Regenerează</button>
                         <button class="delete-last-feedback-button" title="Șterge Ultimul Feedback AI generat">Șterge Ultimul</button>
                         <button class="delete-journal-entry-button" title="Șterge Această Intrare din Jurnal și Tot Feedback-ul">Șterge Intrarea</button>
                    </div>
                </div>`;
            
            const header = card.querySelector('.card-header');
            header.addEventListener('click', (e) => {
                 if (!e.target.closest('button') && !e.target.closest('details')) { // Nu deschide/închide dacă se apasă pe butoane sau pe zona <details>
                    card.classList.toggle('open');
                 }
            });
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); regenereazaFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); stergeUltimulFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeIntrareJurnal(entryData.id, card); });
            
            const noEntriesMsg = container.querySelector('.no-entries-message');
            if (noEntriesMsg) noEntriesMsg.remove();

            if (container.firstChild && container.firstChild.nodeName !== 'P') { // Adaugă înaintea primului card, dacă există și nu e mesajul "nici o intrare"
                container.insertBefore(card, container.firstChild);
            } else { // Altfel, dacă e gol sau are un mesaj placeholder, curăță și adaugă
                if (container.firstChild && container.firstChild.nodeName === 'P') container.innerHTML = '';
                container.appendChild(card);
            }
        } else { 
             card.querySelector('.card-header span:first-child').textContent = `${entryTitle}${promptTypeDisplay}`;
             card.querySelector('.journal-entry-content-text').innerHTML = entryData.continut.replace(/\n/g, '<br>');
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, entryData.feedbackAI_history || (entryData.feedbackAI_latest ? [entryData.feedbackAI_latest] : []));
    }

    async function stergeIntrareJurnal(id, cardElement) {
        // ... (Funcția stergeIntrareJurnal rămâne la fel)
        if (!confirm("Ștergi această intrare din jurnal și tot feedback-ul asociat? Acțiunea este ireversibilă.")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card') && !container.querySelector('.no-entries-message')) { // Verifică dacă mai sunt carduri
                const noEntriesMsg = document.createElement("p");
                noEntriesMsg.className = "no-entries-message"; // Folosește clasa consistentă
                noEntriesMsg.textContent = "Nicio intrare în jurnal. Începe prin a scrie una!";
                container.appendChild(noEntriesMsg);
            }
        } catch (error) { console.error("Eroare ștergere intrare:", error); alert("Eroare la ștergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        // ... (Funcția incarcaIntrariJurnal rămâne la fel)
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        
        let loadingMsg = container.querySelector(".loading-message");
        if (!container.querySelector('.journal-card') && !container.querySelector('.no-entries-message') && !loadingMsg) {
            loadingMsg = document.createElement("p");
            loadingMsg.className = "loading-message"; // Folosește clasa consistentă
            loadingMsg.textContent = "Se încarcă intrările din jurnal...";
            container.appendChild(loadingMsg);
        }

        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            if (loadingMsg) loadingMsg.remove(); 

            // Optimizare: Înlătură doar cardurile care nu mai există
            const currentCardsMap = new Map();
            container.querySelectorAll('.journal-card').forEach(card => currentCardsMap.set(card.dataset.id, card));

            const newDocsData = [];
            querySnapshot.forEach((docSnap) => {
                newDocsData.push({ id: docSnap.id, ...docSnap.data() });
                if (currentCardsMap.has(docSnap.id)) {
                    currentCardsMap.delete(docSnap.id); // Acest card este încă valid, nu-l șterge
                }
            });

            // Șterge cardurile rămase în map (cele care nu mai sunt în Firestore)
            currentCardsMap.forEach(oldCard => oldCard.remove());
            
            if (newDocsData.length === 0 && !container.querySelector('.journal-card')) {
                if (!container.querySelector('.no-entries-message')) { // Adaugă mesajul doar dacă e gol
                    const noEntriesMsg = document.createElement("p");
                    noEntriesMsg.className = "no-entries-message";
                    noEntriesMsg.textContent = "Nicio intrare în jurnal. Începe prin a scrie una!";
                    container.appendChild(noEntriesMsg);
                }
            } else {
                 const noEntriesMessageIfAny = container.querySelector('.no-entries-message');
                 if (noEntriesMessageIfAny) noEntriesMessageIfAny.remove();
                 
                 // Adaugă sau actualizează cardurile
                 newDocsData.forEach(docData => afiseazaCardJurnal(docData));
            }

        } catch (error) {
            console.error("Eroare încărcare jurnal:", error);
             if (loadingMsg) loadingMsg.remove();
            if(!container.querySelector('.journal-card') && !container.querySelector('.error-loading-message')) { // Verifică să nu fie deja un mesaj de eroare
                const errorMsgElement = document.createElement("p");
                errorMsgElement.className = "error-loading-message"; // Folosește clasa consistentă
                errorMsgElement.textContent = "Eroare la încărcarea jurnalului. Vă rugăm reîncărcați pagina sau verificați consola.";
                // Șterge orice mesaj de "nicio intrare" înainte de a adăuga eroarea
                const noEntriesMsg = container.querySelector('.no-entries-message');
                if(noEntriesMsg) noEntriesMsg.remove();
                container.appendChild(errorMsgElement);
            }
        }
    }

    </script>
    <style>
    /* Stilurile rămân identice cu cele din răspunsul anterior, sunt deja adaptate */
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f0f2f5; 
        color: #333a40; line-height: 1.6; font-size: 16px;
    }
    .journal-form-container {
        max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
        box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.7em; margin-bottom: 10px; }
    h3 { font-size: 1.4em; margin-top: 35px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
        transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
    }
    textarea#journalContent { min-height: 250px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;
    }
    
    .prompt-box {
        background: #f8f9fc;
        border: 1px solid #e6eaf0;
        border-left: 4px solid #5c85d6;
        padding: 12px 15px;
        margin-bottom: 15px;
        font-size: 0.9em;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }
    .prompt-box strong { color: #2c3e50; display: block; margin-bottom: 8px; }
    .prompt-content-display {
        white-space: pre-wrap; 
        max-height: 180px; 
        overflow-y: auto;
        background-color: #ffffff;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #e9edf2;
        font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
        font-size:0.95em;
        line-height: 1.55;
        color: #333;
    }
    .prompt-content-display::-webkit-scrollbar { width: 5px; }
    .prompt-content-display::-webkit-scrollbar-thumb { background: #cbd2d9; border-radius:3px; }

    .hide-prompt-button { 
        background: none; border: none; color: #88929e;
        font-size: 1.6em; font-weight: bold; cursor: pointer;
        padding: 0 5px; line-height: 0.8; 
        /* float:right; // Eliminat float pentru o mai bună aliniere cu flex pe containerul părintelui */
    }
    .hide-prompt-button:hover { color: #333; }

    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 15px; background-color: #f8f9fc; border-radius: 8px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 12px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    button.prompt-button {
        background-color: #e9f0ff; color: #4a69bd; border: 1px solid #d1dfff;
        padding: 7px 14px; font-size: 0.85em; font-weight: 500; border-radius: 18px;
        cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button.prompt-button:hover { background-color: #d8e4ff; color: #3a539b; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.07); }

    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 20px; padding: 13px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 3px 7px rgba(92, 133, 214, 0.22);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1.5px); box-shadow: 0 4px 9px rgba(92, 133, 214, 0.28); }
    button#saveJournalEntryButton:disabled { background: #b0c4de !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    .confirmation-message { display: none; text-align: center; padding: 13px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdecea; color: #b32d21; border-color: #f8c6c1; }
    .confirmation-message.warning { background-color: #fff8e1; color: #795508; border-color: #ffecb3; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
    .response-card .card-header {
        font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
        padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
    .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap; font-weight: 400;}

    .response-card .card-header::after {content: '▼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
    .response-card.open .card-content { max-height: 7000px; padding: 20px 20px; }
    
    .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
    .journal-entry-details summary { 
        cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
        background-color: #f8f9fa; border-radius: 6px 6px 0 0; 
        list-style-position: inside; 
    }
    .journal-entry-details summary:hover { background-color: #f1f3f6; }
    .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
    .journal-entry-content-text { 
        padding: 12px; font-size: 1em; line-height: 1.7; color: #3e4c59; white-space: pre-wrap; 
        max-height: 400px; overflow-y: auto;
    }
    .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
    .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }

    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 15px; font-size: 1.05em;
        border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
    }
    .response-card h4:first-of-type { margin-top: 0; } 

    .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }
    .no-entries-message, .loading-message, .error-loading-message { text-align: center; margin-top:25px; font-style: italic; color: #556575; font-size: 1.05em; padding:15px;}
    .error-loading-message { color: #c0392b; font-weight: 500;}

    .ai-feedback-history-container { margin-top: 10px; }
    .feedback-entry-card { 
        background:#fdfdff; padding: 15px; 
        border: 1px solid #e7ecf2;
        border-left: 4px solid #5c85d6; 
        border-radius:8px; margin-bottom:15px; 
        font-size:0.95em; line-height:1.6;
        box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    }
    .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
    
    .card-actions { 
        text-align: right; margin-top: 20px; padding-top: 15px; 
        border-top: 1px solid #eef2f7; 
        display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
    }
    .card-actions button {
        padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
        transition: all 0.2s; border: 1px solid transparent; cursor: pointer;
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
    button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
    button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
    button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
    button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
    
    /* Stiluri specifice pentru conținutul AI din feedback-entry-card .content-ai */
    .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
    .content-ai .ai-main-section-title, 
    .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 { /* Am adăugat și h1-h4 pentru flexibilitatea AI */
        font-weight: 600; color: #3b74d7; /* Un albastru puțin mai vibrant */
        margin-top: 1.2em; margin-bottom: 0.6em; font-size: 1.05em; /* Un pic mai mic decât H4 general al cardului */
        padding-bottom: 4px;
        /* border-bottom: 1px dotted #d1d9e2; */ /* Sublinierea poate aglomera uneori */
    }
    .content-ai .ai-main-section-title:first-child, /* Reduce spațiul pentru primul titlu */
    .content-ai h1:first-child, .content-ai h2:first-child, 
    .content-ai h3:first-child, .content-ai h4:first-child {
        margin-top: 0.3em;
    }
    .content-ai p.ai-text-paragraph { margin-bottom: 0.9em; }
    .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; } /* Mai închis pt contrast */
    .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; } /* Un gri mediu pentru italic */
    
    .content-ai ul.ai-list, .content-ai ol.ai-list {
        margin-left: 5px; padding-left: 22px; margin-bottom: 0.9em; list-style-position: outside;
    }
    .content-ai .ai-list-item { margin-bottom: 0.5em; }
    .content-ai .ai-list-item::marker { color: #4a69bd; font-weight: bold; } /* Marcatori mai vizibili */

    .content-ai .ai-text-error {
        color: #c0392b; font-weight: 500; background-color: #fff5f5; 
        padding: 10px 12px; border-radius: 4px; border: 1px solid #fecaca; border-left: 4px solid #ef4444;
        white-space: pre-wrap; font-size: 0.9em;
    }
    
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto; max-width: 100%;}
        h2 {font-size: 1.5em;} h3 {font-size: 1.25em;}
        textarea#journalContent {min-height: 200px;}
        .card-actions {justify-content: space-around;} /* Distribuie mai bine pe mobil */
        .card-actions button { flex-basis: auto; padding: 7px 12px;} /* Butoanele să-și ia lățimea necesară */
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.3em;} h3 {font-size: 1.15em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 8px;}
        button.prompt-button {padding: 6px 12px; font-size: 0.8em;}
        button#saveJournalEntryButton {padding: 11px 18px; font-size: 1em;}
        .response-card .card-header {font-size: 1em; padding: 12px 15px; flex-direction: column; align-items: flex-start; gap: 5px;}
        .response-card .card-header::after { align-self: flex-end; margin-top: -1.5em; }
        .card-actions button { flex-basis: calc(50% - 5px); } /* Două pe rând */
    }
    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -12px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            Spațiul tău dedicat pentru reflecție ghidată, auto-descoperire și integrare emoțională.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (Opțional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: Reflecții despre ziua de azi, Explorarea anxietății...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflecție (alege un ghid pentru a-l afișa ca referință):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <div id="activePromptBox" class="prompt-box" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <strong id="activePromptTitle">Ghid activ:</strong>
                    <!-- Butonul de închidere va apela o funcție globală -->
                    <button type="button" onclick="window.hideActivePromptManual()" class="hide-prompt-button" title="Ascunde ghidul">×</button>
                </div>
                <div id="activePromptContent" class="prompt-content-display"></div>
                <p style="font-size:0.85em; text-align:right; margin-top:8px; color: #64748B;"><em>Acest ghid este pentru inspirație. Scrie reflecțiile tale în câmpul de jurnal de mai jos.</em></p>
            </div>

            <label for="journalContent" style="margin-top: 15px;">Intrarea ta în jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="15" placeholder="Scrie liber aici sau completează răspunzând la întrebările din ghidul afișat mai sus."></textarea>
            
            <button type="button" id="saveJournalEntryButton">Salvează și Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul Intrărilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Cardurile cu intrări vor fi încărcate aici -->
        <!-- Mesajele de "loading", "no entries", "error" vor fi adăugate de JS -->
    </div>
    
</body>
</html>