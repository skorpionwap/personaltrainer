<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migrare Chat Firestore</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #log { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: scroll; margin-top: 10px; white-space: pre-wrap; }
        .error { color: red; }
        .success { color: green; }
        .info { color: blue; }
    </style>
</head>
<body>
    <h1>Migrare Istoric Chat Firestore (Client-Side)</h1>
    <p><strong>Atenție:</strong> Acest script este pentru migrarea datelor din client. Este recomandat să folosiți Firebase Admin SDK pentru migrări complexe. Asigurați-vă că aveți un backup al datelor!</p>

    <div>
        <label for="chatId">Chat Document ID (ex: chatHistory_xxxx):</label>
        <input type="text" id="chatIdInput" value="chatHistory_U75LwhsnQ4U2XGOLsIX22NNla292" size="50">
    </div>
    <br>
    <button id="startMigrationButton">Pornește Migrarea pentru ID-ul Specificat</button>
    <button id="migrateAllButton" title="Nu este implementat robust pentru client-side bulk" disabled>Migrează Toate (PRUDENȚĂ MAXIMĂ - neimplementat robust)</button>

    <h3>Log Migrare:</h3>
    <div id="log">Așteptare acțiune...<br></div>

    <!-- Firebase SDK -->
    <script type="module">
        // --- IMPORTURI ȘI CONFIGURARE FIREBASE ---
        // Adaugă aici configurația Firebase și inițializarea aplicației
        // similar cu ce ai în psihoterapie.js sau personalizedMaterials.js

        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import {
            getFirestore,
            doc,
            getDoc,
            updateDoc,
            collection,
            addDoc,
            writeBatch,
            Timestamp,
            FieldValue, // Necesar pentru serverTimestamp și delete
            query,
            orderBy,
            limit,
            getDocs
        } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";


        // --- CONFIGURARE FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // CHEIA TA API WEB
            authDomain: "personaltrainer-74ea4.firebaseapp.com",
            projectId: "personaltrainer-74ea4",
            storageBucket: "personaltrainer-74ea4.appspot.com",
            messagingSenderId: "591778567441",
            appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
             measurementId: "G-WLWNGNDK5V" 
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app); // Necesar dacă ai reguli de securitate

        const logDiv = document.getElementById('log');
        const chatIdInput = document.getElementById('chatIdInput');
        const startMigrationButton = document.getElementById('startMigrationButton');
        const migrateAllButton = document.getElementById('migrateAllButton'); // Rămâne dezactivat

        function logMessage(message, type = 'info') {
            const p = document.createElement('p');
            p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            p.className = type;
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[MigrateHTML - ${type.toUpperCase()}] ${message}`);
        }

        // Autentificare anonimă simplă pentru testare (dacă regulile permit useri autentificați)
        // ÎNTR-UN SCENARIU REAL, VEI FI DEJA AUTENTIFICAT CA ADMIN/UTILIZATOR CU DREPTURI
        let currentUser = null;
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                logMessage(`Autentificat ca: ${user.uid} (poate fi anonim)`, 'info');
                startMigrationButton.disabled = false;
            } else {
                currentUser = null;
                logMessage('Utilizator neautentificat. Se încearcă autentificare anonimă...', 'info');
                startMigrationButton.disabled = true;
                signInAnonymously(auth).catch(error => {
                    logMessage(`Eroare autentificare anonimă: ${error.message}`, 'error');
                });
            }
        });


        async function migrateSingleChatClientSide(chatId) {
            if (!currentUser) {
                logMessage("Eroare: Utilizatorul nu este autentificat. Migrarea nu poate începe.", "error");
                return;
            }
            if (!chatId || chatId.trim() === "") {
                logMessage("Eroare: ID-ul documentului de chat este necesar.", "error");
                return;
            }

            logMessage(`--- Începe migrarea (client-side) pentru Chat ID: ${chatId} ---`, 'info');
            startMigrationButton.disabled = true;

            const chatDocRef = doc(db, 'chatHistories', chatId);
            const messagesSubcollectionRef = collection(chatDocRef, 'messages');

            try {
                logMessage(`Preluare document ${chatId}...`, 'info');
                const chatDocSnap = await getDoc(chatDocRef);

                if (!chatDocSnap.exists()) {
                    logMessage(`Documentul ${chatId} nu există. Se omite.`, 'error');
                    startMigrationButton.disabled = false;
                    return;
                }

                const chatData = chatDocSnap.data();
                logMessage(`Document ${chatId} găsit. Se verifică array-ul 'messages'.`, 'info');

                if (chatData.migratedToSubcollection === true && !confirm("Acest chat pare deja migrat. Forțezi re-migrarea (poate duce la duplicate)?")) {
                    logMessage(`Migrarea pentru ${chatId} a fost anulată de utilizator (deja migrat).`, 'info');
                    startMigrationButton.disabled = false;
                    return;
                }


                if (!chatData.messages || !Array.isArray(chatData.messages)) {
                    logMessage(`Documentul ${chatId} nu are un array 'messages' valid.`, 'info');
                    if (chatData.hasOwnProperty('messages')) {
                        logMessage(`Se încearcă ștergerea câmpului 'messages' (gol/invalid) din ${chatId}...`, 'info');
                        await updateDoc(chatDocRef, {
                            messages: FieldValue.delete(), // Folosește FieldValue.delete() importat
                            migrationStatusClient: 'messages_array_deleted_no_migration',
                            migratedClientAt: Timestamp.now()
                        });
                        logMessage(`Câmpul 'messages' (gol/invalid) șters din ${chatId}.`, 'success');
                    }
                    startMigrationButton.disabled = false;
                    return;
                }

                if (chatData.messages.length === 0) {
                    logMessage(`Documentul ${chatId} are un array 'messages' gol. Se șterge array-ul.`, 'info');
                     await updateDoc(chatDocRef, {
                        messages: FieldValue.delete(),
                        migrationStatusClient: 'messages_array_deleted_empty_array',
                        migratedClientAt: Timestamp.now()
                    });
                    logMessage(`Array-ul 'messages' (gol) șters din ${chatId}.`, 'success');
                    startMigrationButton.disabled = false;
                    return;
                }

                const existingMessages = chatData.messages;
                const totalMessagesToMigrate = existingMessages.length;
                logMessage(`Se vor migra ${totalMessagesToMigrate} mesaje pentru ${chatId}.`, 'info');

                // Verificare simplă dacă subcolecția are deja mesaje (mai puțin robustă decât cu Admin SDK)
                const existingSubQuery = query(messagesSubcollectionRef, limit(1));
                const existingSubSnap = await getDocs(existingSubQuery);
                if (!existingSubSnap.empty) {
                    if (!confirm(`Subcolecția 'messages' pentru ${chatId} PARE să conțină deja date. Continuarea poate duce la duplicate. Ești sigur că vrei să continui?`)) {
                        logMessage(`Migrarea pentru ${chatId} a fost anulată de utilizator (subcolecție existentă).`, 'info');
                        startMigrationButton.disabled = false;
                        return;
                    }
                    logMessage("Utilizatorul a ales să continue migrarea chiar dacă subcolecția pare să aibă date.", "warning");
                }


                const batchSize = 100; // Mai mic pentru client-side pentru a reduce riscul de timeout / probleme
                let messagesMigratedCount = 0;

                for (let i = 0; i < totalMessagesToMigrate; i += batchSize) {
                    const batch = writeBatch(db);
                    const chunk = existingMessages.slice(i, i + batchSize);

                    logMessage(`Procesare batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(totalMessagesToMigrate / batchSize)} (mesaje ${i + 1} - ${Math.min(i + batchSize, totalMessagesToMigrate)})`, 'info');

                    for (const message of chunk) {
                        if (!message || typeof message.role !== 'string' || typeof message.content !== 'string') {
                            logMessage(`Mesaj invalid sau incomplet în array. Se omite: ${JSON.stringify(message)}`, 'warning');
                            continue;
                        }

                        let firestoreTimestamp;
                        if (message.timestamp && message.timestamp.toDate) { // Deja Firestore Timestamp (mai puțin probabil în datele vechi)
                            firestoreTimestamp = message.timestamp;
                        } else if (message.timestamp) {
                            try {
                                firestoreTimestamp = Timestamp.fromDate(new Date(message.timestamp));
                            } catch (e) {
                                logMessage(`Timestamp invalid: '${message.timestamp}'. Se folosește ora curentă.`, 'warning');
                                firestoreTimestamp = Timestamp.now();
                            }
                        } else {
                            firestoreTimestamp = Timestamp.now();
                        }

                        const newMessageData = {
                            role: message.role,
                            content: message.content,
                            thoughts: (message.thoughts && typeof message.thoughts === 'string' && message.thoughts.trim() !== "") ? message.thoughts.trim() : null,
                            error: typeof message.error === 'boolean' ? message.error : false,
                            timestamp: firestoreTimestamp,
                            migratedFromOldArrayClient: true
                        };
                        const newMessageRef = doc(messagesSubcollectionRef); // ID auto-generat
                        batch.set(newMessageRef, newMessageData);
                        messagesMigratedCount++;
                    }

                    if (messagesMigratedCount > (i / batchSize) * batchSize) { // Doar dacă s-au adăugat mesaje în batch
                        await batch.commit();
                        logMessage(`Batch ${Math.floor(i / batchSize) + 1} commitat. ${messagesMigratedCount} mesaje migrate până acum.`, 'info');
                    } else {
                        logMessage(`Batch ${Math.floor(i / batchSize) + 1} gol, sărit.`, 'info');
                    }
                     // O mică pauză pentru a nu stresa browser-ul/rețeaua prea tare
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Actualizare document părinte
                const lastMigratedMessage = existingMessages[totalMessagesToMigrate - 1];
                 let lastMsgTsParent;
                 if (lastMigratedMessage.timestamp && lastMigratedMessage.timestamp.toDate) {
                    lastMsgTsParent = lastMigratedMessage.timestamp;
                 } else {
                    try {
                        lastMsgTsParent = Timestamp.fromDate(new Date(lastMigratedMessage.timestamp));
                    } catch { lastMsgTsParent = Timestamp.now(); }
                 }


                logMessage("Se actualizează documentul părinte și se șterge array-ul vechi...", 'info');
                await updateDoc(chatDocRef, {
                    messages: FieldValue.delete(),
                    lastMessageText: String(lastMigratedMessage?.content || "").substring(0, 200),
                    lastMessageTimestamp: lastMsgTsParent,
                    lastMessageRole: String(lastMigratedMessage?.role || ""),
                    migratedToSubcollection: true, // Marchează ca migrat
                    migratedClientAt: Timestamp.now(),
                    migrationStatusClient: 'success'
                });

                logMessage(`Migrarea (client-side) pentru ${chatId} finalizată. ${messagesMigratedCount} mesaje mutate. Array 'messages' șters.`, 'success');

            } catch (error) {
                logMessage(`Eroare majoră la migrarea (client-side) pentru ${chatId}: ${error.message} \nStack: ${error.stack}`, 'error');
                console.error(error);
                // Încearcă să salvezi un status de eroare
                try {
                    await updateDoc(doc(db, 'chatHistories', chatId), {
                        migrationStatusClient: 'failed',
                        migrationErrorClient: error.message.substring(0, 500) // Limitează lungimea erorii
                    });
                } catch (statusError) {
                    logMessage(`Nu s-a putut actualiza statusul de eroare: ${statusError.message}`, 'error');
                }
            } finally {
                startMigrationButton.disabled = false;
            }
        }

        startMigrationButton.addEventListener('click', () => {
            const chatIdToMigrate = chatIdInput.value;
            if (confirm(`Sigur dorești să pornești migrarea pentru ID-ul: ${chatIdToMigrate}? Verifică ID-ul și fă un backup!`)) {
                migrateSingleChatClientSide(chatIdToMigrate);
            }
        });

        migrateAllButton.addEventListener('click', () => {
            logMessage("Migrarea tuturor chat-urilor din client-side este o operațiune riscantă și nu este implementată robust aici. Folosește Admin SDK.", "error");
            // Dacă ai implementa asta, ar trebui să faci getDocs pe 'chatHistories', să iterezi
            // și să gestionezi rate limits, erori etc., ceea ce e foarte complex în client.
        });

        // Initializează starea butonului pe baza autentificării
        if (auth.currentUser) {
            startMigrationButton.disabled = false;
        } else {
            startMigrationButton.disabled = true; // Așteaptă onAuthStateChanged
        }

    </script>
</body>
</html>