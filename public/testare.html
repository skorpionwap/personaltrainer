<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // ÃŽnlocuieÈ™te cu cheia ta realÄƒ
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÃŽNLOCUIEÈ˜TE AICI !!!
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17"; // Sau modelul tÄƒu preferat
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configuratÄƒ:", "'" + GEMINI_API_KEY + "'");

     if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") { // Am eliminat verificarea .startsWith()
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini iniÈ›ializat. Model Feedback Jurnal:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare criticÄƒ la iniÈ›ializarea SDK Gemini:", e);
            let alertMessage = "Eroare la iniÈ›ializarea serviciului AI pentru jurnal. VerificaÈ›i cheia API Gemini È™i configuraÈ›ia.";
            if (e.message && e.message.toLowerCase().includes("api key not valid")) {
                alertMessage = "Cheia API Gemini nu este validÄƒ sau nu are permisiuni pentru modelul de jurnal. VerificaÈ›i Google Cloud Console.";
            } else if (e.message && e.message.toLowerCase().includes("quota")) {
                alertMessage = "Limita de utilizare pentru API-ul Gemini a fost atinsÄƒ (posibil pentru modelul de jurnal).";
            }
            alert(alertMessage + " FuncÈ›ionalitatea AI va fi limitatÄƒ.");
            geminiModelJournalFeedback = null;
        }
    } else  {
        console.warn(`Jurnal Terapeutic: Cheia API Gemini este goalÄƒ sau lipseÈ™te. FuncÈ›ionalitatea AI va fi dezactivatÄƒ.`);
        alert("Jurnal Terapeutic: Cheia API Gemini nu este configuratÄƒ. FuncÈ›ionalitatea AI pentru jurnal va fi dezactivatÄƒ.");
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;
    let selectedPrompt = null; // StocheazÄƒ obiectul promptului selectat

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
    };

    function toggleActivePrompt(show, promptData = null) {
        const box = document.getElementById('activePromptBox');
        const titleEl = document.getElementById('activePromptTitle');
        const contentEl = document.getElementById('activePromptContent');

        if (show && promptData) {
            selectedPrompt = promptData;
            titleEl.textContent = `Ghid activ: ${promptData.label}`;
            contentEl.textContent = promptData.text;
            box.style.display = 'block';
            // Scroll to the top of the prompt box content if it's long
            if(contentEl) contentEl.scrollTop = 0;
        } else {
            selectedPrompt = null;
            box.style.display = 'none';
        }
    }

    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [
            {
                label: "ðŸŒ¡ï¸ ExploreazÄƒ o emoÈ›ie",
                id: "explorare_emotie",
                text: "ðŸŒ¡ï¸ *AstÄƒzi simt...*\n" +
                      "NumeÈ™te emoÈ›ia dominantÄƒ: ________________\n\n" +
                      "ðŸ” *Unde o simt Ã®n corp?*\n" +
                      "Descrie senzaÈ›iile (tensiune, greutate, pulsaÈ›ie etc.): ________________\n\n" +
                      "ðŸ’­ *Ce gÃ¢nduri vin cu aceastÄƒ emoÈ›ie?*\n" +
                      "NoteazÄƒ gÃ¢ndurile automate, chiar dacÄƒ par â€žexagerateâ€: ________________\n\n" +
                      "ðŸ“š *ÃŽn ce context a apÄƒrut?*\n" +
                      "Ce s-a Ã®ntÃ¢mplat exact? Ce a declanÈ™at-o? ________________\n\n" +
                      "ðŸ’§ *Ce nevoie ar putea semnala?*\n" +
                      "De ce are nevoie aceastÄƒ parte din tine? Ce lipseÈ™te? ________________\n\n" +
                      "ðŸ’Œ *DacÄƒ aÈ™ avea compasiune pentru mine acum...*\n" +
                      "Ce mi-aÈ™ spune? Ce gest aÈ™ face pentru mine? ________________\n"
            },
            {
                label: "ðŸ“ AnalizeazÄƒ o situaÈ›ie", // PÄƒstrÄƒm acest prompt clasic, poate fi util
                id: "analiza_situatie",
                text: "SituaÈ›ia care mÄƒ preocupÄƒ este: ________________\n\n" +
                      "Ce s-a Ã®ntÃ¢mplat exact? (Fapte): ________________\n" +
                      "Interpretarea mea iniÈ›ialÄƒ (GÃ¢nduri automate): ________________\n" +
                      "EmoÈ›iile principale: ________________\n" +
                      "O altÄƒ perspectivÄƒ (Reframing): ________________\n" +
                      "Ce am Ã®nvÄƒÈ›at/pot Ã®nvÄƒÈ›a? (LecÈ›ii): ________________\n"
            },
            {
                label: "ðŸ—£ï¸ Dialog Voce CriticÄƒ",
                id: "dialog_voce_critica",
                text: "ðŸ—£ï¸ *Vocea mea interioarÄƒ Ã®mi spune...*\n" +
                      "(\"EÈ™ti slab\", \"Nu faci destul\", \"O sÄƒ fii respins\"...): ________________\n\n" +
                      "ðŸ˜” *CÃ¢nd aud acest mesaj, mÄƒ simt...*\n" +
                      "(emoÈ›ii È™i senzaÈ›ii fizice): ________________\n\n" +
                      "ðŸ§’ *AceastÄƒ voce seamÄƒnÄƒ cu...*\n" +
                      "(E o voce veche? un pÄƒrinte? un profesor? un fost partener?): ________________\n\n" +
                      "ðŸ§  *Ce nevoie neÃ®mplinitÄƒ e Ã®n spatele acestui mesaj?*\n" +
                      "(Poate recunoaÈ™tere, protecÈ›ie, control, apartenenÈ›Äƒ?): ________________\n\n" +
                      "ðŸ§˜ *RÄƒspunsul meu ca Adult SÄƒnÄƒtos ar fi...*\n" +
                      "(\"Apreciez cÄƒ vrei sÄƒ mÄƒ protejezi, dar acum aleg altceva.\"): ________________\n"
            },
            {
                label: "ðŸ’– RecunoÈ™tinÈ›Äƒ & Resurse",
                id: "recunostinta_resurse",
                text: "ðŸ’– *AstÄƒzi aleg sÄƒ vÄƒd ce e bun...*\n" +
                      "Sunt recunoscÄƒtor/oare pentru:\n" +
                      "1. ________________\n" +
                      "2. ________________\n" +
                      "3. ________________\n\n" +
                      "ðŸŒ± *O resursÄƒ interioarÄƒ pe care mÄƒ pot baza astÄƒzi este...*\n" +
                      "(ex: curaj, blÃ¢ndeÈ›e, claritate, capacitatea de a simÈ›i): ________________\n\n" +
                      "ðŸ› *Un gest de auto-Ã®ngrijire pe care Ã®l pot face azi...*\n" +
                      "(chiar dacÄƒ e mic): ________________\n"
            },
            {
                label: "ðŸŒ€ Ritual ReconstrucÈ›ie InterioarÄƒ",
                id: "ritual_reconstructie",
                text: `ðŸ§­ MASTER TEMPLATE â€“ Scriere TerapeuticÄƒ de Integrare È™i Vindecare\n` +
                      `Denumire: â€žRitual de reconstrucÈ›ie interioarÄƒâ€\n` +
                      `Scop: Eliberare, Clarificare, ConÈ›inere, ÃŽnÈ›elepciune, DirecÈ›ie\n\n` +
                      `I. ðŸ” INVITAÈšIE LA AUTENTICITATE\n` +
                      `â€žCe parte din mine cere atenÈ›ie acum?â€\n\n` +
                      `   * Ce trÄƒiesc cu adevÄƒrat, fÄƒrÄƒ filtru, fÄƒrÄƒ poveste cosmetizatÄƒ?\n` +
                      `   * Ce mi-e ruÈ™ine sÄƒ simt sau sÄƒ recunosc chiar È™i Ã®n scris?\n` +
                      `   * Ce parte din mine se simte exclusÄƒ, neauzitÄƒ, ignoratÄƒ?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `II. ðŸŒŠ CONTAINERE EMOÈšIONALE\n` +
                      `â€žCe simte corpul meu? Unde locuieÈ™te durerea?â€\n\n` +
                      `   * Unde simt emoÈ›ia Ã®n corp? Cum se manifestÄƒ? (Tensiune, Ã®nÈ›epÄƒturi, etc.)\n` +
                      `   * DacÄƒ ar avea o culoare, formÄƒ, texturÄƒ â€“ cum ar arÄƒta?\n` +
                      `   * Pot respira Ã®n acea zonÄƒ 3 minute, fÄƒrÄƒ sÄƒ fug?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `III. ðŸ§  DECODIFICARE NARATIVÄ‚\n` +
                      `â€žCe poveste Ã®mi spun? Este Ã®ntreagÄƒ?â€\n\n` +
                      `   * Ce naraÈ›iune inconÈ™tientÄƒ guverneazÄƒ trÄƒirea mea? (ex: â€žNu sunt dorit.â€)\n` +
                      `   * De unde vine aceastÄƒ naraÈ›iune? CÃ¢nd am mai trÄƒit ceva similar?\n` +
                      `   * Ce parte din mine (copil rÄƒnit, etc.) scrie aceastÄƒ poveste?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `IV. ðŸ§© INTEGRARE EXPLICATIVÄ‚\n` +
                      `â€žCe Ã®nÈ›eleg nou despre mine din aceastÄƒ durere?â€\n\n` +
                      `   * Ce nevoi profunde au fost ignorate sau negate?\n` +
                      `   * Ce am protejat, de fapt, prin reacÈ›ia mea?\n` +
                      `   * Ce emoÈ›ii contradictorii coexistÄƒ Ã®n mine È™i ce spun ele?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `V. ðŸªž COMPASIUNE È˜I BLÃ‚NDEÈšE\n` +
                      `â€žCum pot fi pÄƒrinte pentru mine acum?â€\n\n` +
                      `   * DacÄƒ mi-aÈ™ È›ine partea rÄƒnitÄƒ Ã®n braÈ›e, ce i-aÈ™ spune?\n` +
                      `   * Ce aÈ™ vrea sÄƒ aud din partea unei figuri ideale de susÈ›inere?\n` +
                      `   * Pot lÄƒsa iubirea, nu logica, sÄƒ conducÄƒ acest moment?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `VI. ðŸ”® RECONFIGURARE IDENTITARÄ‚\n` +
                      `â€žCine sunt eu dincolo de aceastÄƒ ranÄƒ?â€\n\n` +
                      `   * Ce adevÄƒr despre mine rÄƒmÃ¢ne valabil, chiar È™i Ã®n durere?\n` +
                      `   * Cine devin dacÄƒ Ã®nvÄƒÈ› sÄƒ stau cu mine Ã®n acest spaÈ›iu?\n` +
                      `   * DacÄƒ aÈ™ fi un personaj simbolic acum, cine aÈ™ fi?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `VII. âœï¸ ACTUL SACRU DE ALEGERE\n` +
                      `â€žCe aleg de azi, pentru mine?â€\n\n` +
                      `   * Ce meritÄƒ sÄƒ las sÄƒ plece?\n` +
                      `   * Ce Ã®mi iau ca Ã®nvÄƒÈ›ÄƒturÄƒ de Ã®ncredere Ã®n viaÈ›Äƒ?\n` +
                      `   * Ce ritual zilnic/mic obicei pot Ã®ncepe pentru a onora aceastÄƒ transformare?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `VIII. (OpÈ›ional) ðŸ“œ SCRISOARE-RITUAL\n` +
                      `Scrie o scrisoare cÄƒtre...\n` +
                      `RÄƒspuns: ________________\n`
            }
        ];
        promptsContainerEl.innerHTML = '';
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "InsereazÄƒ acest ghid Ã®n jurnal È™i afiÈ™eazÄƒ-l";
            button.onclick = () => {
                const insertText = prompt.text;
                if (journalTextarea.value.trim() !== "" && !confirm("Vrei sÄƒ Ã®nlocuieÈ™ti textul curent cu acest ghid? OK pentru a Ã®nlocui, Anulare pentru a adÄƒuga la sfÃ¢rÈ™it.")) {
                    journalTextarea.value += "\n\n---\n" + insertText;
                } else {
                    journalTextarea.value = insertText;
                }
                toggleActivePrompt(true, prompt);
                journalTextarea.focus();
                // Scroll to the top of the textarea to see the newly inserted prompt
                journalTextarea.scrollTop = 0;
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) return "EROARE: Model AI neiniÈ›ializat (jurnal).";
        try {
            console.log("Trimitem la Gemini (jurnal, primele 200 caractere):", promptText.substring(0, 200));
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.7, maxOutputTokens: 3500, ...generationConfigOptions } // Temp. 0.7, max token ajustat
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare opritÄƒ (Motiv: ${response.candidates[0].finishReason}). Detalii: ${JSON.stringify(response.candidates[0].safetyRatings)}`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Detalii: ${JSON.stringify(response.promptFeedback.blockReasonDetail || response.promptFeedback.safetyRatings)}`;
            }
            console.warn("RÄƒspuns Gemini neaÈ™teptat sau gol:", JSON.stringify(response, null, 2));
            return "EROARE Gemini: RÄƒspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            let userFriendlyError = `EROARE Gemini: ${error.message || "Eroare API necunoscutÄƒ."}`;
            if (error.message && error.message.toLowerCase().includes("api key not valid")) {
                userFriendlyError = "EROARE: Cheia API Gemini nu este validÄƒ sau nu are permisiuni. VerificaÈ›i configuraÈ›ia.";
            } else if (error.message && error.message.toLowerCase().includes("quota has been exceeded")) {
                userFriendlyError = "EROARE: Limita de utilizare API Gemini a fost depÄƒÈ™itÄƒ. ÃŽncercaÈ›i mai tÃ¢rziu.";
            } else if (error.message && error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety")){
                 userFriendlyError = "EROARE Gemini: Generarea a fost opritÄƒ, posibil din motive de siguranÈ›Äƒ sau din cauza conÈ›inutului. ÃŽncercaÈ›i sÄƒ reformulaÈ›i."
            }
            return userFriendlyError;
        }
    }
    
    function getSelectedPromptType() {
        if (selectedPrompt && selectedPrompt.id) {
            return selectedPrompt.id;
        }
        const journalContent = document.getElementById("journalContent")?.value || "";
        return detectPromptUsed(journalContent);
    }

    function detectPromptUsed(content) {
        if (!content) return "prompt_personalizat";
        content = content.toLowerCase();

        if (content.includes("ce parte din mine cere atenÈ›ie acum") && content.includes("master template")) return "ritual_reconstructie";
        if (content.includes("vocea mea interioarÄƒ Ã®mi spune") || content.includes("vocea mea criticÄƒ Ã®mi spune")) return "dialog_voce_critica";
        if (content.includes("astÄƒzi simt...") && content.includes("numeÈ™te emoÈ›ia dominantÄƒ:")) return "explorare_emotie";
        if (content.includes("astÄƒzi aleg sÄƒ vÄƒd ce e bun") && content.includes("sunt recunoscÄƒtor/oare pentru:")) return "recunostinta_resurse";
        if (content.includes("situaÈ›ia care mÄƒ preocupÄƒ este:")) return "analiza_situatie";
        return "prompt_personalizat";
    }

    function buildAdaptiveAIPrompt(entryTitle, journalText, promptType) {
        let specificInstructions = "";
        let modelFocus = "feedback general È™i reflecÈ›ie";

        let basePrompt = `EÈ™ti PsihoGPT â€“ un terapeut AI avansat, extrem de empatic, cu o profundÄƒ Ã®nÈ›elegere a psihologiei umane, antrenat Ã®n Terapie Cognitiv-ComportamentalÄƒ (TCC), Terapia Schemelor, Terapia prin Acceptare È™i Angajament (ACT), Scrierea ExpresivÄƒ È™i principii de mindfulness. ComunicÄƒ Ã®ntr-un limbaj cald, validant È™i uÈ™or de Ã®nÈ›eles, dar pÄƒstreazÄƒ profunzimea analiticÄƒ. FoloseÈ™te formatare Markdown pentru structurare (titluri cu \`**Titlu**\`, liste cu \`* Element listÄƒ\`, text bold cu \`**text bold**\` È™i italic cu \`*text italic*\` unde e cazul). EvitÄƒ citatele direct din literaturÄƒ dacÄƒ nu sunt absolut esenÈ›iale, concentreazÄƒ-te pe limbajul tÄƒu.

Obiectivul tÄƒu este sÄƒ oferi un feedback personalizat, constructiv È™i profund pentru urmÄƒtoarea intrare Ã®n jurnal. Nu oferi sfaturi medicale sau diagnostice. ConcentreazÄƒ-te pe facilitarea auto-Ã®nÈ›elegerii È™i a creÈ™terii personale.`;

        switch (promptType) {
            case "ritual_reconstructie":
                specificInstructions = `
Utilizatorul a completat un exerciÈ›iu profund numit "Ritual de ReconstrucÈ›ie InterioarÄƒ", care are 7 secÈ›iuni principale (I. InvitaÈ›ie la Autenticitate, II. Containere EmoÈ›ionale, III. Decodificare NarativÄƒ, IV. Integrare ExplicativÄƒ, V. Compasiune È™i BlÃ¢ndeÈ›e, VI. Reconfigurare IdentitarÄƒ, VII. Actul Sacru de Alegere) È™i poate include o secÈ›iune VIII (Scrisoare-Ritual).
Feedback-ul tÄƒu AR TREBUI SÄ‚ URMEZE ACEASTÄ‚ STRUCTURÄ‚. Pentru FIECARE secÈ›iune relevantÄƒ (unde utilizatorul a scris ceva semnificativ):
1.  **NumeÈ™te secÈ›iunea** (ex: "**I. InvitaÈ›ie la Autenticitate:**").
2.  **RecunoaÈ™te È™i ValideazÄƒ** efortul specific pentru acea secÈ›iune È™i oferÄƒ o scurtÄƒ validare empaticÄƒ a conÈ›inutului.
3.  **ReflectÄƒ principalele teme È™i insight-uri** care reies din rÄƒspunsurile utilizatorului la acea secÈ›iune. Fii specific È™i poÈ›i cita scurt (1-5 cuvinte) din textul utilizatorului pentru ancorare.
4.  **Pune o Ã®ntrebare de aprofundare specificÄƒ** (sau 2 maxim, doar dacÄƒ este pertinent) pentru acea secÈ›iune, care sÄƒ invite la o reflecÈ›ie È™i mai adÃ¢ncÄƒ asupra celor descoperite acolo.
DupÄƒ ce ai parcurs secÈ›iunile, adaugÄƒ o secÈ›iune de **Concluzii È™i ÃŽncurajare:**
*   **IdentificÄƒ Conexiuni Generale:** EvidenÈ›iazÄƒ pe scurt legÄƒturi sau tipare observate Ã®ntre diferitele secÈ›iuni (ex: cum autenticitatea din I se leagÄƒ de nevoile din IV sau de alegerile din VII).
*   **ÃŽncurajeazÄƒ** procesul de transformare schiÈ›at Ã®n secÈ›iunea VII (Actul Sacru de Alegere) È™i apreciazÄƒ vulnerabilitatea.
EvitÄƒ generalitÄƒÈ›ile. Fii È›intit pe conÈ›inutul specific fiecÄƒrei secÈ›iuni a ritualului. RÄƒspunsul total trebuie sÄƒ fie detaliat, dar structurat È™i uÈ™or de parcurs.`;
                modelFocus = "analizÄƒ structuratÄƒ a ritualului de reconstrucÈ›ie, pas cu pas, cu focus pe integrare, reflecÈ›ie aprofundatÄƒ per secÈ›iune È™i transformare";
                break;
            case "dialog_voce_critica":
                specificInstructions = `
Utilizatorul a explorat un dialog cu "Vocea CriticÄƒ". Feedback-ul tÄƒu ar trebui sÄƒ fie structurat astfel:
1.  **Validare EmpaticÄƒ:** RecunoaÈ™te dificultatea È™i durerea asociate cu auzirea mesajelor critice.
2.  **Analiza Mesajului Critic:** IdentificÄƒ mesajul critic principal. Ce temÄƒ sau fricÄƒ de bazÄƒ pare sÄƒ exprime? (Ex: frica de eÈ™ec, de respingere, de a nu fi suficient de bun).
3.  **Rolul Protector (DisfuncÈ›ional):** ExploreazÄƒ posibilul rol protector al vocii critice. Ce nevoie fundamentalÄƒ (ex: siguranÈ›Äƒ, apartenenÈ›Äƒ, control) ar putea Ã®ncerca aceastÄƒ voce sÄƒ satisfacÄƒ Ã®ntr-un mod neÃ®ndemÃ¢natic?
4.  **Perspectiva Adultului SÄƒnÄƒtos:** ReflecteazÄƒ asupra rÄƒspunsului Adultului SÄƒnÄƒtos. Este compasional? Asertiv? Cum Ã®ntÄƒreÈ™te o perspectivÄƒ mai echilibratÄƒ È™i auto-susÈ›inÄƒtoare?
5.  **ÃŽntrebÄƒri de Aprofundare (1-2):** Acestea ar putea viza originile vocii critice (ex: "AceastÄƒ voce pare sÄƒ ecouze pe cineva din trecutul tÄƒu, sau este un mesaj pe care l-ai internalizat de-a lungul timpului?") sau strategii de a cultiva mai mult vocea Adultului SÄƒnÄƒtos (ex: "Ce mic gest de blÃ¢ndeÈ›e sau acÈ›iune aliniatÄƒ cu Adultul SÄƒnÄƒtos ai putea practica mÃ¢ine, chiar È™i pentru cÃ¢teva minute?").
6.  **NotÄƒ despre Scheme (discret):** DacÄƒ mesajul critic este foarte puternic È™i pare legat de o schemÄƒ (ex: "Nu eÈ™ti bun de nimic" -> Defectivitate), poÈ›i menÈ›iona la final, cu delicateÈ›e: "*Uneori, astfel de voci critice pot fi ecouri ale unor tipare de gÃ¢ndire È™i simÈ›ire mai vechi, pe care Ã®n terapie le numim 'scheme'. Explorarea lor poate aduce È™i mai multÄƒ claritate.*" Nu insista, nu diagnostica.`;
                modelFocus = "analizÄƒ aprofundatÄƒ a dinamicii vocii critice versus Adultul SÄƒnÄƒtos, identificarea nevoilor subiacente È™i oferirea de piste pentru reflecÈ›ie ulterioarÄƒ";
                break;
            case "explorare_emotie":
                specificInstructions = `
Utilizatorul a explorat o emoÈ›ie specificÄƒ. Feedback-ul tÄƒu ar trebui sÄƒ aibÄƒ urmÄƒtoarea structurÄƒ:
1.  **Validarea EmoÈ›iei:** ÃŽncepe prin a valida emoÈ›ia numitÄƒ È™i intensitatea ei. RecunoaÈ™te curajul de a o explora.
2.  **Conexiunea Corp-EmoÈ›ie:** ComenteazÄƒ descrierea senzaÈ›iilor corporale. Cum ajutÄƒ aceastÄƒ conÈ™tientizare la Ã®nÈ›elegerea mai profundÄƒ È™i la "simÈ›irea" emoÈ›iei, nu doar la "gÃ¢ndirea" ei?
3.  **RelaÈ›ia GÃ¢nduri-EmoÈ›ie:** AnalizeazÄƒ cum gÃ¢ndurile automate menÈ›ionate par sÄƒ influenÈ›eze (sÄƒ genereze, intensifice sau menÈ›inÄƒ) emoÈ›ia. ExistÄƒ tipare de gÃ¢ndire evidente?
4.  **Context È™i DeclanÈ™ator:** ReflecteazÄƒ asupra contextului È™i a declanÈ™atorului. Ce anume din situaÈ›ia descrisÄƒ pare sÄƒ fi activat aceastÄƒ emoÈ›ie?
5.  **Nevoia FundamentalÄƒ:** AnalizeazÄƒ nevoia semnalatÄƒ. CÃ¢t de pertinentÄƒ pare? Cum se leagÄƒ aceasta de emoÈ›ie È™i de situaÈ›ie? Este o nevoie recurentÄƒ?
6.  **Auto-Compasiune È™i AcÈ›iune:** ApreciazÄƒ gestul de auto-compasiune descris. Cum ar putea fi acesta un pas concret spre reglare emoÈ›ionalÄƒ sau spre Ã®mplinirea nevoii identificate?
7.  **ÃŽntrebÄƒri de ReflecÈ›ie FinalÄƒ (1-2):** Pune Ã®ntrebÄƒri deschise, orientate spre viitor sau spre o Ã®nÈ›elegere mai profundÄƒ. Ex: "*Ce ai Ã®nvÄƒÈ›at despre tine sau despre aceastÄƒ emoÈ›ie prin acest exerciÈ›iu?*", "*Ce mic pas ai putea face Ã®n urmÄƒtoarele zile pentru a onora nevoia pe care ai identificat-o, atunci cÃ¢nd simÈ›i din nou aceastÄƒ emoÈ›ie?*"`;
                modelFocus = "Ã®nÈ›elegerea detaliatÄƒ a emoÈ›iei Ã®n context (corp, gÃ¢nduri, trigger, nevoie) È™i promovarea auto-compasiunii È™i a acÈ›iunilor conÈ™tiente";
                break;
            case "recunostinta_resurse":
                specificInstructions = `
Utilizatorul a completat un exerciÈ›iu de recunoÈ™tinÈ›Äƒ È™i identificare a resurselor interioare. Feedback-ul tÄƒu ar trebui sÄƒ:
1.  **Aprecierea Practicii:** ÃŽncepe prin a aprecia efortul de a se conecta cu recunoÈ™tinÈ›a È™i resursele interioare.
2.  **Analiza RecunoÈ™tinÈ›ei:** ObservÄƒ temele recurente Ã®n motivele de recunoÈ™tinÈ›Äƒ, dacÄƒ existÄƒ. Ce spun acestea despre valorile, prioritÄƒÈ›ile sau domeniile de viaÈ›Äƒ importante pentru utilizator?
3.  **Explorarea Resursei Interioare:** ReflecteazÄƒ asupra resursei interioare menÈ›ionate. Cum poate fi aceasta o ancorÄƒ Ã®n momente dificile? Cum poate fi cultivatÄƒ È™i mai mult Ã®n viaÈ›a de zi cu zi? PoÈ›i oferi o micro-sugestie practicÄƒ (ex: o vizualizare scurtÄƒ, o afirmaÈ›ie).
4.  **Impactul Auto-ÃŽngrijirii:** ComenteazÄƒ gestul de auto-Ã®ngrijire. CÃ¢t de important este acest act, chiar È™i mic, Ã®n contextul general al stÄƒrii de bine È™i al echilibrului emoÈ›ional?
5.  **ÃŽncurajarea ContinuitÄƒÈ›ii:** ÃŽncurajeazÄƒ integrarea acestor practici (recunoÈ™tinÈ›Äƒ, conectare la resurse, auto-Ã®ngrijire) Ã®n rutina zilnicÄƒ, subliniind beneficiile pe termen lung.
6.  **ÃŽntrebÄƒri de Final (1-2):** Pune Ã®ntrebÄƒri care sÄƒ ancoreze experienÈ›a. Ex: "*Cum te-a fÄƒcut sÄƒ te simÈ›i acest exerciÈ›iu? Ce micÄƒ schimbare de perspectivÄƒ (dacÄƒ existÄƒ) Ã®È›i aduce?*", "*Cum ai putea sÄƒ Ã®È›i reaminteÈ™ti de aceastÄƒ resursÄƒ interioarÄƒ atunci cÃ¢nd te confrunÈ›i cu o provocare?*"`;
                modelFocus = "consolidarea practicii recunoÈ™tinÈ›ei, ancorarea Ã®n resurse interioare È™i auto-Ã®ngrijire, È™i Ã®ncurajarea integrÄƒrii lor Ã®n viaÈ›a cotidianÄƒ";
                break;
            case "analiza_situatie":
                specificInstructions = `
Utilizatorul a analizat o situaÈ›ie specificÄƒ folosind un ghid structurat. Feedback-ul tÄƒu ar trebui sÄƒ:
1.  **RecunoaÈ™terea Efortului:** ValideazÄƒ efortul de structurare È™i analizÄƒ a situaÈ›iei.
2.  **Sumarizarea Elementelor Cheie:** ReflectÄƒ pe scurt elementele principale identificate de utilizator: situaÈ›ia, faptele, interpretarea iniÈ›ialÄƒ (gÃ¢ndurile automate) È™i emoÈ›iile.
3.  **Analiza Perspectivei Alternative (Reframing):** ComenteazÄƒ perspectiva alternativÄƒ. CÃ¢t de diferitÄƒ este aceasta de interpretarea iniÈ›ialÄƒ? Ce impact ar putea avea adoptarea conÈ™tientÄƒ a acestei noi perspective asupra emoÈ›iilor È™i comportamentelor viitoare?
4.  **EvidenÈ›ierea ÃŽnvÄƒÈ›Äƒmintelor (LecÈ›iilor):** SubliniazÄƒ lecÈ›iile Ã®nvÄƒÈ›ate sau cele potenÈ›iale identificate. Ce se poate extrage constructiv È™i valoros din aceastÄƒ situaÈ›ie, chiar dacÄƒ a fost dificilÄƒ?
5.  **ÃŽntrebÄƒri de Aprofundare È™i AcÈ›iune (1-2):** Pune Ã®ntrebÄƒri care sÄƒ stimuleze integrarea. Ex: "*Ce te-ar ajuta sÄƒ accesezi mai uÈ™or aceastÄƒ 'altÄƒ perspectivÄƒ' Ã®n situaÈ›ii similare viitoare?*", "*Ce mic pas concret, bazat pe lecÈ›ia Ã®nvÄƒÈ›atÄƒ, ai putea face Ã®n urmÄƒtoarea sÄƒptÄƒmÃ¢nÄƒ dacÄƒ o situaÈ›ie similarÄƒ ar apÄƒrea?*"`;
                modelFocus = "analiza constructivÄƒ a situaÈ›iei, cu accent pe reframing, identificarea lecÈ›iilor È™i transpunerea lor Ã®n paÈ™i acÈ›ionabili";
                break;
            default: // prompt_personalizat sau neidentificat
                specificInstructions = `
Utilizatorul a scris o intrare liberÄƒ Ã®n jurnal, fÄƒrÄƒ un ghid specific. Feedback-ul tÄƒu ar trebui sÄƒ fie empatic, reflexiv È™i sÄƒ deschidÄƒ noi perspective:
1.  **Validare GeneralÄƒ È™i Empatie:** ÃŽncepe cu o validare caldÄƒ pentru ceea ce a fost exprimat. RecunoaÈ™te deschiderea È™i reflectÄƒ emoÈ›ia sau tonul general care reiese din text.
2.  **Identificarea Temelor Centrale (1-2):** IdentificÄƒ cu grijÄƒ 1-2 teme, emoÈ›ii sau preocupÄƒri principale care par sÄƒ iasÄƒ Ã®n evidenÈ›Äƒ din textul utilizatorului. PoÈ›i folosi citate foarte scurte (1-3 cuvinte) pentru a ilustra, dar nu excesiv.
3.  **ÃŽntrebÄƒri Deschise È™i Evocatoare (2-3):** Pune 2-3 Ã®ntrebÄƒri deschise, care sÄƒ invite utilizatorul la o explorare mai adÃ¢ncÄƒ a aspectelor menÈ›ionate, fÄƒrÄƒ a fi intruziv. ÃŽntrebÄƒrile ar trebui sÄƒ stimuleze auto-descoperirea. Exemple: "*Citind despre [temÄƒ specificÄƒ], mÄƒ Ã®ntrebam ce altceva ai observat despre tine Ã®n acea experienÈ›Äƒ?*", "*DacÄƒ ai putea da un mesaj pÄƒrÈ›ii din tine care a trÄƒit [emoÈ›ie/situaÈ›ie], care ar fi acela È™i de ce crezi cÄƒ ar avea nevoie sÄƒ-l audÄƒ?*", "*Ce nevoie mai profundÄƒ crezi cÄƒ Ã®ncearcÄƒ sÄƒ se facÄƒ auzitÄƒ prin aceste rÃ¢nduri/sentimente?*".
4.  **Oglindire È™i ReflecÈ›ie (nu interpretare):** ReflectÄƒ Ã®napoi ceea ce ai "auzit" Ã®n text, fÄƒrÄƒ a adÄƒuga interpretÄƒri personale sau a presupune prea mult. FoloseÈ™te formulÄƒri de genul "Pare cÄƒ...", "Am observat cÄƒ menÈ›ionezi...", "SunÄƒ ca È™i cum...".
5.  **ÃŽncurajare FinalÄƒ:** OferÄƒ o scurtÄƒ Ã®ncurajare pentru continuarea procesului valoros de scriere È™i auto-reflecÈ›ie.`;
                modelFocus = "reflecÈ›ie empaticÄƒ asupra textului liber, identificarea temelor centrale È™i facilitarea explorÄƒrii prin Ã®ntrebÄƒri deschise È™i susÈ›inÄƒtoare";
                break;
        }

        const finalPrompt = `${basePrompt}

**Focusul specific pentru aceastÄƒ intrare de jurnal (bazat pe ghidul "${promptType}") este: ${modelFocus}.**

**InstrucÈ›iuni specifice pentru feedback bazat pe tipul de ghid ("${promptType}"):**
${specificInstructions}
---
**ConÈ›inutul Jurnalului Utilizatorului este:**
Titlu: ${entryTitle || "FÄƒrÄƒ titlu"}
Ghid utilizat (detectat/selectat): ${promptType}

Text Complet:
\`\`\`
${journalText}
\`\`\`
---
Te rog sÄƒ generezi un feedback AI care sÄƒ respecte toate aceste cerinÈ›e. Fii cÃ¢t mai specific È™i personalizat pe textul oferit. MulÈ›umesc!`;

        return finalPrompt;
    }

    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: FuncÈ›ionalitatea AI pentru jurnal nu este disponibilÄƒ.";
        
        const promptType = entryData.promptTypeUtilizat || detectPromptUsed(entryData.continut);
        const promptJurnalAdaptiv = buildAdaptiveAIPrompt(entryData.titlu, entryData.continut, promptType);

        console.log(`Jurnal - Regenerare/Generare Feedback pentru tipul: ${promptType}.`);
        const feedbackText = await callGeminiAPI(promptJurnalAdaptiv, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId, promptType);
    }
    
    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId, promptType = "necunoscut") { // Am adaugat promptType
        const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            promptTypeAtGeneration: promptType, // Salvam si tipul de prompt folosit la generare
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva Ã®n jurnal."); return; }

        const tipPromptFolosit = getSelectedPromptType();

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid,
            promptTypeUtilizat: tipPromptFolosit // SALVEAZÄ‚ TIPUL PROMPTULUI
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salveazÄƒ..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se genereazÄƒ AI...";
            // entryData.id = docRef.id; // AdaugÄƒ ID-ul pentru consistenÈ›Äƒ dacÄƒ genereaza... are nevoie de el direct
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id); // Trimite entryData complet
            
            const docSnapshot = await getDoc(docRef); // Re-fetch pentru a avea È™i feedback-ul AI
            if (docSnapshot.exists()) {
                 afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            } else { // Fallback dacÄƒ docSnapshot nu e gata imediat, puÈ›in probabil dar defensiv
                 console.warn("Documentul nu a fost gÄƒsit imediat dupÄƒ adÄƒugare/update. AfiÈ™are cu date parÈ›iale.");
                 entryData.id = docRef.id; // AsigurÄƒ-te cÄƒ ID-ul e setat
                 entryData.feedbackAI_latest = parsedFeedback;
                 entryData.feedbackAI_history = [parsedFeedback];
                 afiseazaCardJurnal(entryData);
            }
            
            journalTextarea.value = ""; 
            if (journalTitleInput) journalTitleInput.value = "";
            toggleActivePrompt(false); // Ascunde ghidul activ
            selectedPrompt = null; // ReseteazÄƒ promptul selectat

            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvatÄƒ. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvatÄƒ È™i feedback AI generat!';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau generare feedback.';
            confirmationMsg.className = 'confirmation-message error';
        } finally {
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 9000);
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se genereazÄƒ..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');


        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { 
                alert("Intrarea nu existÄƒ."); 
                if(confirmationMsg) {
                    confirmationMsg.textContent = 'Eroare: Intrarea nu a fost gÄƒsitÄƒ.';
                    confirmationMsg.className = 'confirmation-message error';
                    confirmationMsg.style.display = 'block';
                }
                return; 
            }
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId); // trimite entryDoc.data() care are promptTypeUtilizat
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); 
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                // ActualizeazÄƒ Ã®ntregul card pentru a reflecta noul feedback, similar cu cum e fÄƒcut Ã®n salveaza...
                // Cel mai simplu e sÄƒ re-afiÈ™Äƒm cardul. Dar asta poate Ã®nchide cardul dacÄƒ era deschis.
                // O soluÈ›ie mai bunÄƒ e sÄƒ actualizÄƒm doar containerul de feedback.
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) {
                    afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
                }
            }
            const message = parsedFeedback.error ? `Feedback AI: ${parsedFeedback.rawText}` : "Feedback AI regenerat È™i adÄƒugat la istoric!";
            if(confirmationMsg) {
                confirmationMsg.textContent = message;
                confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
                confirmationMsg.style.display = 'block';
                setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                alert(message);
            }

        } catch (e) { 
            console.error("Eroare regenerare:", e); 
            if(confirmationMsg) {
                confirmationMsg.textContent = 'Eroare la regenerare feedback.';
                confirmationMsg.className = 'confirmation-message error';
                confirmationMsg.style.display = 'block';
                setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                 alert("Eroare la regenerare feedback.");
            }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        if (!confirm("È˜tergi ultimul feedback AI pentru aceastÄƒ intrare? AceastÄƒ acÈ›iune nu poate fi anulatÄƒ.")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se È™terge..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                const msg = "Nu existÄƒ feedback de È™ters.";
                if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message warning'; confirmationMsg.style.display = 'block'; setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);}
                else { alert(msg); }
                return;
            }
            const history = entrySnap.data().feedbackAI_history;
            history.pop(); // Scoate ultimul

            await updateDoc(entryDocRef, {
                feedbackAI_history: history,
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            
            const msg = "Ultimul feedback AI È™ters.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message success'; confirmationMsg.style.display = 'block'; setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }

        } catch (e) { 
            console.error("Eroare È™tergere ultim feedback:", e); 
             const msg = "Eroare la È™tergere feedback.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, feedbackHistory) {
        containerEl.innerHTML = ''; 

        if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
            const noHistoryMsg = document.createElement("p");
            noHistoryMsg.textContent = "Niciun feedback AI generat pentru aceastÄƒ intrare.";
            noHistoryMsg.className = "no-feedback-message";
            containerEl.appendChild(noHistoryMsg);
            return;
        }

        feedbackHistory.slice().reverse().forEach((entry, index) => {
            const itemContainer = document.createElement("div");
            itemContainer.className = "feedback-entry-card"; 

            const timestampAndModel = document.createElement("p");
            timestampAndModel.className = "feedback-timestamp";
            const modelInfo = entry.model || 'N/A';
            const promptTypeInfo = entry.promptTypeAtGeneration ? ` (Ghid: ${entry.promptTypeAtGeneration.replace(/_/g, ' ')})` : '';
            timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - ${modelInfo}${promptTypeInfo})`;
            itemContainer.appendChild(timestampAndModel);

            const contentWrapper = document.createElement("div"); 
            contentWrapper.className = "content-ai"; 

            if (entry.error) {
                const errorP = document.createElement("p");
                errorP.className = "ai-text-error";
                errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
                contentWrapper.appendChild(errorP);
            } else {
                let textToProcess = entry.rawText || 'ConÈ›inut indisponibil.';
                let finalHtmlElements = []; 
                const lines = textToProcess.split('\n');
                let currentParagraphContent = [];
                let inList = false; // Track if we are inside a list
                let currentListElement = null;


                for (const line of lines) {
                    // 1. VerificÄƒ Titlurile Principale (ex: **Titlu**)
                    // AsigurÄƒ-te cÄƒ nu e parte dintr-un text bold Ã®n interiorul unei linii.
                    const matchTitle = line.match(/^\s*(\*\*|###\s*|\#\#\s*|\#\s*)([^*#]+)\1?\s*$/);


                    if (matchTitle && matchTitle[2].trim().length > 0) {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                         if (inList && currentListElement) {
                            finalHtmlElements.push(currentListElement);
                            inList = false; currentListElement = null;
                        }
                        const titleDiv = document.createElement(matchTitle[1].startsWith('#') ? `h${matchTitle[1].length}` : 'div'); // H_ sau DIV
                        titleDiv.className = 'ai-main-section-title';
                        // Scoat boldul din titlu dacÄƒ e cu ** È™i pÄƒstreazÄƒ-l dacÄƒ e din #
                        titleDiv.textContent = matchTitle[2].trim();
                        finalHtmlElements.push(titleDiv);
                        continue; 
                    }

                    // 2. VerificÄƒ Elementele de ListÄƒ (ex: * Item, - Item, 1. Item)
                    const matchListItem = line.match(/^\s*([\*\-\+]|\d+\.)\s+(.*)/);
                    if (matchListItem) {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                             let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        if (!inList) {
                            inList = true;
                            currentListElement = document.createElement(matchListItem[1].match(/\d+\./) ? 'ol' : 'ul');
                            currentListElement.className = 'ai-list';
                        }
                        const listItem = document.createElement('li');
                        listItem.className = 'ai-list-item';
                        // ParseazÄƒ markdown simplu Ã®n interiorul itemului de listÄƒ
                        let itemHtml = matchListItem[2];
                        itemHtml = itemHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                        itemHtml = itemHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                        listItem.innerHTML = itemHtml;
                        currentListElement.appendChild(listItem);
                        continue; 
                    }
                    
                    // DacÄƒ nu e titlu sau listÄƒ, È™i eram Ã®ntr-o listÄƒ, terminÄƒm lista.
                    if (inList && currentListElement) {
                        finalHtmlElements.push(currentListElement);
                        inList = false; currentListElement = null;
                    }

                    // 3. Text normal sau linie goalÄƒ
                    if (line.trim() === "") {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                             let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        // AdaugÄƒ un <br> doar dacÄƒ nu e ultimul element sau dacÄƒ nu e urmat de alt conÈ›inut
                        if (lines.indexOf(line) < lines.length -1 && lines[lines.indexOf(line)+1].trim() !== "") {
                           finalHtmlElements.push(document.createElement('br'));
                        }
                    } else {
                        currentParagraphContent.push(line);
                    }
                }

                if (currentParagraphContent.length > 0) {
                    const p = document.createElement('p');
                    p.className = 'ai-text-paragraph';
                    let paragraphHtml = currentParagraphContent.join('<br>');
                    paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                    paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                    p.innerHTML = paragraphHtml;
                    finalHtmlElements.push(p);
                }
                 if (inList && currentListElement) { // AdaugÄƒ lista dacÄƒ era ultima
                    finalHtmlElements.push(currentListElement);
                }

                finalHtmlElements.forEach(el => contentWrapper.appendChild(el));
            }
            itemContainer.appendChild(contentWrapper);
            containerEl.appendChild(itemContainer);
        });
    }

    function afiseazaCardJurnal(entryData) {
        const container = document.getElementById("journalEntriesContainer");
        let card = container.querySelector(`.journal-card[data-id="${entryData.id}"]`);
        
        const entryDate = entryData.dataIntrare || (entryData.timestampCreare?.toDate ? new Date(entryData.timestampCreare.toDate()).toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }) : 'DatÄƒ necunoscutÄƒ');
        const entryTitle = entryData.titlu || `Intrare din ${entryDate}`;
        const promptTypeUsedDisplay = entryData.promptTypeUtilizat ? ` (Ghid: ${entryData.promptTypeUtilizat.replace(/_/g, ' ')})` : '';

        if (!card) { // Creare card nou
            card = document.createElement("div");
            card.className = "response-card journal-card"; 
            card.setAttribute("data-id", entryData.id);
            // Nota: Am simplificat card-content iniÈ›ial; detaliile jurnalului sunt Ã®ntr-un <details>
            card.innerHTML = `
                <div class="card-header">
                    <span>${entryTitle}${promptTypeUsedDisplay}</span>
                    <span class="card-date">${entryDate}</span>
                </div>
                <div class="card-content">
                    <details class="journal-entry-details">
                        <summary>Vezi/Ascunde textul jurnalului</summary>
                        <p class="journal-entry-content-text">${entryData.continut.replace(/\n/g, '<br>')}</p>
                    </details>
                    <h4>Feedback AI PsihoGPT</h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                         <button class="regenerate-feedback-button" title="RegenereazÄƒ Feedback AI">RegenereazÄƒ</button>
                         <button class="delete-last-feedback-button" title="È˜terge Ultimul Feedback AI">È˜terge Ultimul</button>
                         <button class="delete-journal-entry-button" title="È˜terge Intrarea È™i Tot Feedback-ul">È˜terge Intrarea</button>
                    </div>
                </div>`;
            
            const header = card.querySelector('.card-header');
            header.addEventListener('click', (e) => {
                 // Toggle 'open' class only if the click is not on the date span or other specific elements
                 if (!e.target.classList.contains('card-date')) {
                    card.classList.toggle('open');
                 }
            });
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); regenereazaFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); stergeUltimulFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeIntrareJurnal(entryData.id, card); });
            
            const noEntriesMsg = container.querySelector('.no-entries-message');
            if (noEntriesMsg) noEntriesMsg.remove();

            if (container.firstChild) { 
                container.insertBefore(card, container.firstChild);
            } else { 
                container.appendChild(card);
            }
        } else { // Update card existent (ex: dupÄƒ regenerare, dacÄƒ am alege sÄƒ actualizÄƒm tot cardul)
             card.querySelector('.card-header span:first-child').textContent = `${entryTitle}${promptTypeUsedDisplay}`;
             card.querySelector('.journal-entry-content-text').innerHTML = entryData.continut.replace(/\n/g, '<br>');
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, entryData.feedbackAI_history || entryData.feedbackAI_latest ? (entryData.feedbackAI_history || [entryData.feedbackAI_latest].filter(Boolean)) : []);
    }

    async function stergeIntrareJurnal(id, cardElement) {
        if (!confirm("È˜tergi aceastÄƒ intrare din jurnal È™i tot feedback-ul asociat? AcÈ›iunea este ireversibilÄƒ.")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card')) {
                const noEntriesMsg = document.createElement("p");
                noEntriesMsg.className = "no-entries-message";
                noEntriesMsg.textContent = "Nicio intrare Ã®n jurnal. ÃŽncepe prin a scrie una!";
                container.appendChild(noEntriesMsg);
            }
        } catch (error) { console.error("Eroare È™tergere intrare:", error); alert("Eroare la È™tergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        
        let loadingMsg = container.querySelector(".loading-message");
        if (!container.querySelector('.journal-card') && !loadingMsg) {
            loadingMsg = document.createElement("p");
            loadingMsg.className = "loading-message";
            loadingMsg.textContent = "Se Ã®ncarcÄƒ intrÄƒrile...";
            container.appendChild(loadingMsg);
        }

        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            if (loadingMsg) loadingMsg.remove(); // ÃŽnlÄƒturÄƒ "Se Ã®ncarcÄƒ..."

            const currentCardIds = new Set();
            container.querySelectorAll('.journal-card').forEach(card => currentCardIds.add(card.dataset.id));
            
            const docsData = [];
            querySnapshot.forEach((docSnap) => {
                docsData.push({ id: docSnap.id, ...docSnap.data() });
            });

            // È˜terge cardurile care nu mai sunt Ã®n Firestore (dacÄƒ existÄƒ o astfel de logicÄƒ de È™tergere externÄƒ)
            container.querySelectorAll('.journal-card').forEach(card => {
                if (!docsData.find(d => d.id === card.dataset.id)) {
                    card.remove();
                }
            });

            if (docsData.length === 0) {
                if(!container.querySelector('.journal-card') && !container.querySelector('.no-entries-message')) { // AdaugÄƒ mesajul doar dacÄƒ nu existÄƒ deja carduri
                    const noEntriesMsg = document.createElement("p");
                    noEntriesMsg.className = "no-entries-message";
                    noEntriesMsg.textContent = "Nicio intrare. ÃŽncepe prin a scrie una!";
                    container.appendChild(noEntriesMsg);
                }
            } else {
                 const noEntriesMessage = container.querySelector('.no-entries-message');
                 if (noEntriesMessage) noEntriesMessage.remove();
                 docsData.forEach(docData => afiseazaCardJurnal(docData));
            }

        } catch (error) {
            console.error("Eroare Ã®ncÄƒrcare jurnal:", error);
             if (loadingMsg) loadingMsg.remove();
            if(!container.querySelector('.journal-card') && !container.querySelector('.error-loading-message')) {
                const errorMsg = document.createElement("p");
                errorMsg.className = "error-loading-message";
                errorMsg.textContent = "Eroare la Ã®ncÄƒrcarea jurnalului. VÄƒ rugÄƒm reÃ®ncÄƒrcaÈ›i pagina.";
                container.appendChild(errorMsg);
            }
        }
    }
    </script>
    <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f0f2f5; 
        color: #333a40; line-height: 1.6; font-size: 16px;
    }
    .journal-form-container {
        max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
        box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.7em; margin-bottom: 10px; }
    h3 { font-size: 1.4em; margin-top: 35px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
        transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
    }
    textarea#journalContent { min-height: 250px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;
    }
    
    /* Prompturi de ReflecÈ›ie Activi */
    .prompt-box {
        background: #f8f9fc;
        border: 1px solid #e6eaf0;
        border-left: 4px solid #5c85d6;
        padding: 12px 15px;
        margin-bottom: 15px;
        font-size: 0.9em;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }
    .prompt-box strong { color: #2c3e50; display: block; margin-bottom: 8px; }
    .prompt-content-display {
        white-space: pre-wrap; 
        max-height: 180px; 
        overflow-y: auto;
        background-color: #ffffff;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #e9edf2;
        font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
        font-size:0.95em;
        line-height: 1.55;
        color: #333;
    }
    .prompt-content-display::-webkit-scrollbar { width: 5px; }
    .prompt-content-display::-webkit-scrollbar-thumb { background: #cbd2d9; border-radius:3px; }

    .hide-prompt-button { 
        background: none; border: none; color: #88929e;
        font-size: 1.6em; font-weight: bold; cursor: pointer;
        padding: 0 5px; line-height: 0.8; float:right;
    }
    .hide-prompt-button:hover { color: #333; }

    /* Butoane Prompt ReflecÈ›ie - listÄƒ */
    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 15px; background-color: #f8f9fc; border-radius: 8px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 12px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    button.prompt-button {
        background-color: #e9f0ff; color: #4a69bd; border: 1px solid #d1dfff;
        padding: 7px 14px; font-size: 0.85em; font-weight: 500; border-radius: 18px;
        cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button.prompt-button:hover { background-color: #d8e4ff; color: #3a539b; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.07); }

    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 20px; padding: 13px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 3px 7px rgba(92, 133, 214, 0.22);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1.5px); box-shadow: 0 4px 9px rgba(92, 133, 214, 0.28); }
    button#saveJournalEntryButton:disabled { background: #b0c4de !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    .confirmation-message { display: none; text-align: center; padding: 13px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdecea; color: #b32d21; border-color: #f8c6c1; }
    .confirmation-message.warning { background-color: #fff8e1; color: #795508; border-color: #ffecb3; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    /* Carduri Istoric Jurnal */
    .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
    .response-card .card-header {
        font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
        padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
    .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap;}

    .response-card .card-header::after {content: 'â–¼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; /* Allow auto for scroll if needed, but pre-wrap on text content handles overflow better */ transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
    .response-card.open .card-content { max-height: 7000px; /* generous max height */ padding: 20px 20px; }
    
    .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
    .journal-entry-details summary { 
        cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
        background-color: #f8f9fa; border-radius: 6px 6px 0 0; 
        list-style-position: inside; /* For better alignment of the triangle */
    }
    .journal-entry-details summary:hover { background-color: #f1f3f6; }
    .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
    .journal-entry-content-text { 
        padding: 12px; font-size: 1em; line-height: 1.7; color: #3e4c59; white-space: pre-wrap; 
        max-height: 400px; overflow-y: auto;
    }
    .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
    .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }


    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 15px; font-size: 1.05em;
        border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
    }
    .response-card h4:first-of-type { margin-top: 0; } /* Feedback AI title might be first */

    .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }
    .no-entries-message, .loading-message, .error-loading-message { text-align: center; margin-top:25px; font-style: italic; color: #556575; font-size: 1.05em; padding:15px;}
    .error-loading-message { color: #c0392b; font-weight: 500;}


    .ai-feedback-history-container { margin-top: 10px; }
    .feedback-entry-card { 
        background:#fdfdff; padding: 15px; 
        border: 1px solid #e7ecf2;
        border-left: 4px solid #5c85d6; 
        border-radius:8px; margin-bottom:15px; 
        font-size:0.95em; line-height:1.6;
        box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    }
    .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
    
    .card-actions { 
        text-align: right; margin-top: 20px; padding-top: 15px; 
        border-top: 1px solid #eef2f7; 
        display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
    }
    .card-actions button {
        padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
        transition: all 0.2s; border: 1px solid transparent;
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
    button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
    button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
    button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
    button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
    
    /* Stiluri specifice pentru conÈ›inutul AI din feedback-entry-card .content-ai */
    .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
    .content-ai .ai-main-section-title, 
    .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 {
        font-weight: 600; color: #5c85d6; /* Culoarea accent */
        margin-top: 1.2em; margin-bottom: 0.6em; font-size: 1.1em;
        padding-bottom: 4px;
        /* border-bottom: 1px dotted #d1d9e2; */
    }
    .content-ai .ai-main-section-title:first-child,
    .content-ai h1:first-child, .content-ai h2:first-child, .content-ai h3:first-child, .content-ai h4:first-child {
        margin-top: 0.2em;
    }
    .content-ai p.ai-text-paragraph { margin-bottom: 0.8em; }
    .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; }
    .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; }
    
    .content-ai ul.ai-list, .content-ai ol.ai-list {
        margin-left: 5px; padding-left: 22px; margin-bottom: 0.8em;
    }
    .content-ai .ai-list-item { margin-bottom: 0.4em; }
    .content-ai .ai-list-item::marker { color: #5c85d6; }

    .content-ai .ai-text-error {
        color: #c0392b; font-weight: 500; background-color: #fff5f5; 
        padding: 8px; border-radius: 4px; border-left: 3px solid #c0392b;
        white-space: pre-wrap;
    }
    
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto; max-width: 100%;}
        h2 {font-size: 1.5em;} h3 {font-size: 1.25em;}
        textarea#journalContent {min-height: 200px;}
        .card-actions {justify-content: center;}
        .card-actions button { flex-basis: calc(33.33% - 7px); }
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.3em;} h3 {font-size: 1.15em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 8px;}
        button.prompt-button {padding: 6px 12px; font-size: 0.8em;}
        button#saveJournalEntryButton {padding: 11px 18px; font-size: 1em;}
        .card-header {font-size: 1em; padding: 12px 15px;}
        .card-actions button { flex-basis: 100%; }
    }
    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -12px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            SpaÈ›iul tÄƒu dedicat pentru reflecÈ›ie ghidatÄƒ, auto-descoperire È™i integrare emoÈ›ionalÄƒ.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (OpÈ›ional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: ReflecÈ›ii despre ziua de azi, Explorarea anxietÄƒÈ›ii...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflecÈ›ie (alege un ghid pentru a-l insera È™i afiÈ™a):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <div id="activePromptBox" class="prompt-box" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <strong id="activePromptTitle">Ghid activ:</strong>
                    <button type="button" onclick="document.getElementById('activePromptBox').style.display='none'; selectedPrompt = null;" class="hide-prompt-button" title="Ascunde ghidul">Ã—</button>
                </div>
                <div id="activePromptContent" class="prompt-content-display"></div>
                <p style="font-size:0.85em; text-align:right; margin-top:8px; color: #64748B;"><em>Acest ghid este pentru inspiraÈ›ie. CompleteazÄƒ Ã®n jurnalul de mai jos.</em></p>
            </div>

            <label for="journalContent" style="margin-top: 15px;">Intrarea ta Ã®n jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="15" placeholder="Scrie liber aici... sau alege un ghid de mai sus È™i completeazÄƒ-l."></textarea>
            
            <button type="button" id="saveJournalEntryButton">SalveazÄƒ È™i Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul IntrÄƒrilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Cardurile cu intrÄƒri vor fi Ã®ncÄƒrcate aici -->
    </div>
    
</body>
</html>