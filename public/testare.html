<!DOCTYPE html>
<html>
<head>
    <title>Fișă Monitorizare - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, deleteField, doc, getDoc, updateDoc, arrayUnion, query, where, setDoc, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", 
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- CHEIA TA API GEMINI AICI (SA NU FIE PLACEHOLDER!)
    const GEMINI_MODEL_NAME_FEEDBACK = "gemini-2.5-flash-preview-04-17"; 
    const GEMINI_MODEL_NAME_CHAT = "gemini-2.5-flash-preview-04-17";
    let genAI, geminiModelFeedback, geminiModelChat;

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_FEEDBACK });
            geminiModelChat = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_CHAT });
            console.log("SDK Gemini inițializat. Model Feedback:", GEMINI_MODEL_NAME_FEEDBACK, "Model Chat:", GEMINI_MODEL_NAME_CHAT);
        } catch (e) {
            console.error("Eroare critică la inițializarea SDK Gemini:", e);
            alert("Eroare la inițializarea serviciului AI. Verificați cheia API Gemini și configurația din Google Cloud. Funcționalitatea AI va fi limitată.");
            geminiModelFeedback = null; geminiModelChat = null;
        }
    } else  {
        console.warn(`Cheia API Gemini pare a fi un placeholder ('${GEMINI_API_KEY}'). Te rog înlocuiește-o cu cheia ta API validă pentru a activa funcționalitatea AI.`);
        // alert("Funcționalitatea AI este dezactivată. Te rog configurează o cheie API Gemini validă în codul sursă (variabila GEMINI_API_KEY).");
        geminiModelFeedback = null; geminiModelChat = null;
        // Cheie goală sau doar spații
        console.warn("Cheia API Gemini nu este configurată. Funcționalitatea AI va fi dezactivată.");
        // alert("Cheia API Gemini nu este configurată. Funcționalitatea AI va fi dezactivată.");
        geminiModelFeedback = null; geminiModelChat = null;
    }

    let currentStep = 1;
    let totalSteps = 0;
    let dataAlreadyLoaded = false;
    let chatSession = null;
    const CHAT_HISTORY_DOC_ID_PREFIX = "chatHistory_";
    let isChatInitialized = false;

    window.onload = function () {
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

function initializeFormFunctionality() {
    // Selectorul este acum corect dacă fiecare .question-card este un .form-step
    const formSteps = document.querySelectorAll('form#exercitiuForm div.question-card.form-step'); 
    
    console.log("Elemente .question-card.form-step găsite:", formSteps.length, formSteps);

    if (formSteps.length > 0) {
        totalSteps = formSteps.length; // Acum ar trebui să fie în jur de 28

        // Asigură-te că doar primul este activ
        formSteps.forEach((step, index) => {
            if (index === 0) {
                step.classList.add('form-step-active');
                console.log("Psiho Fișă (testare.html): Primul pas (question-card) activat:", step.id);
            } else {
                step.classList.remove('form-step-active');
            }
        });
        
        currentStep = 1; 
        updateProgressBar(); 
    } else {
        totalSteps = 0;
        console.warn("Psiho Fișă (testare.html): Niciun .question-card.form-step găsit sub formular.");
    }

    // Restul funcției rămâne la fel (atașarea event listener-ilor)
    document.getElementById("nextButton")?.addEventListener("click", nextStep);
    document.getElementById("prevButton")?.addEventListener("click", previousStep);
    document.getElementById("addButton")?.addEventListener("click", salveazaRaspunsSiGenereazaFeedback);
    document.getElementById("generateLinkButton")?.addEventListener("click", generateCollaborationLink);
    console.log("Psiho Fișă (testare.html): Funcționalitatea formularului inițializată. Total pași (întrebări individuale):", totalSteps);
}


        if (!collabId) {
            onAuthStateChanged(auth, async (user) => {
                const toggleChatBtn = document.getElementById("toggleChatButton");
                const chatContainer = document.getElementById("chatContainer");
                const formContainer = document.querySelector('.form-container');
                const cardViewTitle = document.getElementById('cardViewTitle');


                if (user) {
                    if(formContainer) formContainer.style.display = ''; // Asigură vizibilitate
                    if(cardViewTitle) cardViewTitle.style.display = '';

                    console.log("Utilizator autentificat (fișă):", user.uid);
                    initializeFormFunctionality(); 
                    if (!dataAlreadyLoaded) {
                        loadTableData(user.uid);
                        dataAlreadyLoaded = true;
                    }
                    if(toggleChatBtn) toggleChatBtn.style.display = 'flex';
                } else {
                    console.log("Utilizator neautentificat, redirecționare... (fișă)");
                    if(formContainer) formContainer.style.display = 'none'; 
                    if(cardViewTitle) cardViewTitle.style.display = 'none';
                    if(toggleChatBtn) toggleChatBtn.style.display = 'none';
                    if(chatContainer) chatContainer.style.display = 'none';
                    isChatInitialized = false;
                    chatSession = null;
                    window.location.href = "login.html";
                }
            });
        } else { 
            console.log("Psiho Fișă: Mod colaborare detectat. Funcționalitatea formularului NU va fi inițializată complet în onload.");
            // logica de ascundere a formularului etc. este deja în DOMContentLoaded.
            const toggleChatBtn = document.getElementById("toggleChatButton");
            if(toggleChatBtn) toggleChatBtn.style.display = 'none';
            const chatContainer = document.getElementById("chatContainer");
            if(chatContainer) chatContainer.style.display = 'none';
        }
        
        document.getElementById("toggleChatButton")?.addEventListener("click", handleToggleChat);
        document.getElementById("sendChatMessageButton")?.addEventListener("click", handleSendChatMessage);
        document.getElementById("chatInput")?.addEventListener("keypress", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); 
                handleSendChatMessage();
            }
        });
    };

    function nextStep() {
        // ... (codul funcției nextStep - rămâne la fel)
        if (currentStep < totalSteps) {
            const currentStepEl = document.getElementById(`step-${currentStep}`);
            if(currentStepEl) currentStepEl.classList.remove('form-step-active');
            currentStep++;
            const nextStepEl = document.getElementById(`step-${currentStep}`);
            if(nextStepEl) nextStepEl.classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function previousStep() {
        // ... (codul funcției previousStep - rămâne la fel)
         if (currentStep > 1) {
            const currentStepEl = document.getElementById(`step-${currentStep}`);
            if(currentStepEl) currentStepEl.classList.remove('form-step-active');
            currentStep--;
            const prevStepEl = document.getElementById(`step-${currentStep}`);
            if(prevStepEl) prevStepEl.classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function updateProgressBar() {
        // ... (codul funcției updateProgressBar - rămâne la fel)
         const progress = document.getElementById('progress');
        if(progress && totalSteps > 0) {
            const progressPercentage = (currentStep / totalSteps) * 100;
            progress.style.width = progressPercentage + '%';
        }
    }
    
    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        // ... (codul funcției callGeminiAPI - rămâne la fel)
        if (!modelToUse) {
            console.error("Modelul Gemini specificat este invalid sau neinițializat.", modelToUse === geminiModelChat ? "(Model Chat)" : "(Model Feedback Fișă)");
            return "EROARE: Model AI neinițializat. Verifică cheia API.";
        }
        try {
            console.log("Trimitem la Gemini (fișă, primele 200 caractere):", promptText.substring(0, 200));
            const requestPayload = {
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.55, maxOutputTokens: 4000, ...generationConfigOptions } 
            };
            const result = await modelToUse.generateContent(requestPayload); 
            const response = result.response;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Gemini a oprit generarea prematur (fișă):", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    return `EROARE Gemini: Generare oprită (Motiv: ${response.candidates[0].finishReason}). Detalii: ${JSON.stringify(response.candidates[0].safetyRatings || 'N/A')}`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                console.error("Prompt blocat de Gemini (fișă):", response.promptFeedback.blockReasonDetail || response.promptFeedback.blockReason);
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Detalii: ${JSON.stringify(response.promptFeedback.blockReasonDetail || response.promptFeedback.safetyRatings || 'N/A')}`;
            } else {
                console.error("Răspuns Gemini neașteptat sau gol (fișă):", JSON.stringify(response, null, 2));
                return "EROARE Gemini: Răspuns invalid sau gol de la API.";
            }
        } catch (error) {
            console.error("Eroare detaliată la callGeminiAPI (fișă):", error, error.stack);
            let errorMessage = `EROARE Gemini: ${error.message || "Eroare API necunoscută"}`;
             if (error.toString().toLowerCase().includes("api key not valid") || 
                (error.message && error.message.toLowerCase().includes("permission denied")) ||
                (error.message && error.message.toLowerCase().includes("api_key_invalid")) ||
                (error.status && error.status === 403)) {
                 errorMessage = "EROARE: Cheia API Gemini nu este validă sau nu are permisiuni. Verifică restricțiile din Google Cloud Console și cheia din cod. Asigură-te că domeniul " + (typeof window !== 'undefined' ? window.location.hostname : '') + " este permis.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429) || (error.toString().toLowerCase().includes("resource has been exhausted")) )) {
                errorMessage = "EROARE: Limita de utilizare (posibil gratuită) a API-ului Gemini a fost depășită. Încearcă mai târziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety") || error.message.toLowerCase().includes("blocked due to safety_settings"))) {
                errorMessage = "EROARE Gemini: Generarea a fost oprită (posibil din motive de siguranță, conținut inadecvat, sau alte restricții ale modelului). Încearcă un prompt diferit sau ajustează setările de siguranță dacă ai acces.";
            }  else if (error.toString().toLowerCase().includes("404") && error.toString().toLowerCase().includes("model not found")) {
                 errorMessage = `EROARE Gemini: Modelul specificat (${modelToUse === geminiModelFeedback ? GEMINI_MODEL_NAME_FEEDBACK : GEMINI_MODEL_NAME_CHAT}) nu a fost găsit sau nu este suportat. Verifică numele modelului.`;
            }
            return errorMessage;
         }
    }

    async function genereazaSiProceseazaFeedbackAI(rowData, docId) {
        // ... (codul funcției genereazaSiProceseazaFeedbackAI - rămâne la fel)
          const prompt = `
Analizează în profunzime această fișă completă de auto-reflecție. Utilizatorul a parcurs un exercițiu detaliat pentru a-și înțelege o situație specifică. Oferă feedback psihologic structurat, empatic și acționabil. Respectă cu strictețe formatul și ordinea secțiunilor de mai jos, folosind exact prefixele indicate (ex: \`EmpatieInițială:\`, \`PuncteForteObservate:\`). Folosește Markdown pentru formatarea textului în interiorul fiecărei secțiuni (ex: \`**Text bold**\`, \`*Text italic*\`, liste cu \`* Element\`).

**Datele Complete din Fișa de Reflecție a Utilizatorului:**

**Secțiunea 1: Explorarea Situației și a Nevoilor**
*   Care este situația?: ${rowData.situatie || 'N/A'}
*   Ce îmi trece prin minte (gânduri automate)?: ${rowData.ganduri || 'N/A'}
*   Cum mă face acel gând să mă simt (emoții)?: ${rowData.emotii || 'N/A'}
*   Ce mod este activ?: ${rowData.mod_activ || 'N/A'}
*   Ce comportament simți că adopți?: ${rowData.comportament || 'N/A'}
*   Care sunt nevoile tale mai profunde?: ${rowData.nevoi_profunde || 'N/A'}
*   Mă ajută comportamentul meu să îndeplinesc aceste nevoi?: ${rowData.ajutor_comportament || 'N/A'}
*   Cum ar gândi și cum s-ar comporta Adultul Sănătos (perspectiva utilizatorului)?: ${rowData.adult_sanatos || 'N/A'}

**Secțiunea 2: Analiza Gândurilor și a Percepțiilor**
*   Ce mă face să cred că gândul automat este adevărat?: ${rowData.dovezi_adevar || 'N/A'}
*   Ce mă face să cred că nu este adevărat?: ${rowData.dovezi_fals || 'N/A'}
*   Există o explicație alternativă?: ${rowData.explicatie_alternativa || 'N/A'}
*   Care este cel mai rău lucru care s-ar putea întâmpla?: ${rowData.scenariu_negativ || 'N/A'}
*   Care este cel mai bun lucru care s-ar putea întâmpla?: ${rowData.scenariu_optimist || 'N/A'}
*   Care este cel mai realist rezultat?: ${rowData.rezultat_realist || 'N/A'}
*   Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?: ${rowData.schimbare_gandire || 'N/A'}
*   Ce i-aș spune unui prieten dacă ar fi în aceeași situație?: ${rowData.sfat_prieten || 'N/A'}

**Secțiunea 3: Întrebări pentru Claritate și Reflecție Suplimentară**
*   Văd doar partea rea a lucrurilor?: ${rowData.partea_rea || 'N/A'}
*   Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?: ${rowData.responsabilitate || 'N/A'}
*   Mă condamn în baza unui singur eveniment?: ${rowData.condamnare || 'N/A'}
*   Privesc situația în termeni extremi (alb/negru)?: ${rowData.termeni_extremi || 'N/A'}
*   Exagerez situația?: ${rowData.exagerare || 'N/A'}
*   Există și alți factori responsabili?: ${rowData.factori_responsabili || 'N/A'}
*   Am sărit direct la concluzii?: ${rowData.concluzii || 'N/A'}
*   Îmi pun întrebări fără răspuns?: ${rowData.intrebari_fara_raspuns || 'N/A'}
*   Mă concentrez doar asupra slăbiciunilor mele?: ${rowData.slabiciuni || 'N/A'}
*   Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?: ${rowData.cum_ar_trebui || 'N/A'}
*   Mă aștept să fiu perfect?: ${rowData.perfectiune || 'N/A'}

**CERINȚE PENTRU FEEDBACK-UL AI (folosește prefixele EXACT așa cum sunt scrise și formatarea Markdown în interiorul răspunsurilor):**

EmpatieInițială: (1-2 propoziții empatice scurte, recunoscând efortul utilizatorului.)

PuncteForteObservate: (Identifică 1-2 aspecte pozitive sau de auto-conștientizare observate în răspunsurile utilizatorului.)

TiparePrincipale: (Descrie succint 1-3 tipare de gândire/emoționale/comportamentale centrale care reies din fișă.)

ConexiuniCheie: (Sintetizează legătura S-G-E-C-N (Situație-Gând-Emoție-Comportament-Nevoie) specifică acestei fișe, bazându-te pe răspunsurile la '${rowData.ganduri}', '${rowData.emotii}', '${rowData.comportament}', '${rowData.nevoi_profunde}'.)

DistorsiuniIdentificate: (Identifică 2-3 distorsiuni cognitive principale din răspunsuri. Pentru fiecare:
*   Numele Distorsiunii (ex: \`**Catastrofizare**\`)
*   O scurtă explicație a distorsiunii (1 propoziție).
*   Un exemplu specific din răspunsurile utilizatorului care ilustrează distorsiunea.
*   O întrebare de contestare sau reflecție pentru acea distorsiune (ex: "*Cum ar arăta o perspectivă mai echilibrată asupra X?*").
Listează fiecare distorsiune ca un sub-punct separat.)

SchemeActivate: (Sugerează 1-2 scheme cognitive maladaptative timpurii care par a fi activate de situația descrisă (ex: Defectivitate/Rușine, Abandon, Deprivare Emoțională etc.). Pentru fiecare:
*   Numele Schemei (ex: \`**Schema de Eșec**\`)
*   O scurtă descriere a cum se manifestă în general acea schemă (1-2 propoziții).
*   Cum ar putea răspunsurile utilizatorului din această fișă (gânduri, emoții, comportamente) să reflecte activarea acestei scheme?
Fii speculativ și empatic, nu conclusiv. Prezintă ca sub-puncte.)

ModuriImplicate: (Sugerează pe scurt ce moduri din Terapia Schemelor ar putea fi active sau implicate, pe lângă cel menționat de utilizator, dacă este cazul. Ex: Copil Vulnerabil, Părinte Punitiv, Protector Detașat. Fii concis.)

PerspectivaAdultSănătos: (Comentează răspunsul utilizatorului despre cum ar acționa Adultul Sănătos ('${rowData.adult_sanatos}'). Este realist? Compasional? Oferă sugestii pentru a întări și mai mult această perspectivă, incluzând:
    *   Cum ar putea Adultul Sănătos să interpreteze situația diferit?
    *   Ce gânduri alternative ar putea cultiva?
    *   Cum ar gestiona emoțiile într-un mod adaptativ?
    *   Ce comportamente constructive ar adopta pentru a-și împlini nevoile?
    *   Cum ar putea contracara activ schemele sau modurile disfuncționale?)

ÎntrebareFinalăReflecție: (O întrebare generală, puternică și deschisă, care să încurajeze utilizatorul să integreze învățămintele din această fișă în viața sa de zi cu zi sau să reflecteze la un aspect mai larg.)

SugestieMicPas: (O sugestie concretă, mică și realizabilă, pentru un pas pe care utilizatorul l-ar putea face în următoarele zile pentru a exersa o abilitate nouă, a contesta un gând, sau a acționa din perspectiva Adultului Sănătos, bazat pe analiza fișei.)

ÎncurajareFinală: (1-2 propoziții de încurajare, validare și speranță.)

Răspunde doar cu textul cerut conform structurii, fără introduceri ("Iată feedback-ul...") sau concluzii suplimentare ("Sper că acest feedback..."), în afara celor specificate. Asigură-te că fiecare secțiune începe exact cu prefixul dat (ex: \`EmpatieInițială:\`).`;

      let feedbackRawText = null; 
      let modelFolosit = "N/A";

      if (geminiModelFeedback) {
        console.log("Psiho Fișă: Solicitare feedback de la Gemini...");
        modelFolosit = `Gemini (${GEMINI_MODEL_NAME_FEEDBACK})`;
        feedbackRawText = await callGeminiAPI(prompt, geminiModelFeedback); 
      } else {
        console.warn("Psiho Fișă: Gemini (geminiModelFeedback) nu este configurat. Nu se poate genera feedback AI.");
        return { 
            rawText: "EROARE: Serviciul de feedback AI (Gemini) nu este configurat corect pentru fișe. Verifică cheia API.",
            model: "Configurare Eronată", 
            timestamp: new Date().toISOString(), 
            error: true 
        };
      }

      const parsedFeedback = { 
        rawText: feedbackRawText, 
        model: modelFolosit, 
        timestamp: new Date().toISOString(), 
        error: false, 
        error_parsing: false 
      };

      if (!feedbackRawText || (typeof feedbackRawText === 'string' && feedbackRawText.toUpperCase().startsWith("EROARE:"))) {
        console.warn(`Psiho Fișă: Eroare de la ${modelFolosit} la generarea feedback-ului:`, feedbackRawText);
        parsedFeedback.error = true; 
      } else {
          console.log("Psiho Fișă: Răspuns brut de la Gemini (feedback):\n---\n" + feedbackRawText + "\n---");
          const feedbackStructure = {
                empatie_initiala: /^EmpatieInițială:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                puncte_forte: /^PuncteForteObservate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                tipare_principale: /^TiparePrincipale:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                conexiuni_cheie: /^ConexiuniCheie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                distorsiuni_identificate: /^DistorsiuniIdentificate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                scheme_activate: /^SchemeActivate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                moduri_implicate: /^ModuriImplicate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                perspectiva_adult_sanatos: /^PerspectivaAdultSănătos:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                intrebare_finala_reflectie: /^ÎntrebareFinalăReflecție:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                sugestie_mic_pas: /^SugestieMicPas:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                incurajare_finala: /^ÎncurajareFinală:\s*([\s\S]*?$)/im,
            };
            
            let allParsingOk = true;
            for (const key in feedbackStructure) {
                const match = feedbackRawText.match(feedbackStructure[key]);
                if (match && match[1] && match[1].trim() !== "") {
                     parsedFeedback[key] = match[1].trim();
                } else {
                    console.warn(`Psiho Fișă: Nu s-a putut extrage sau este gol conținutul pentru: '${key}'`);
                    parsedFeedback[key] = `(Secțiune neextrasă sau goală: ${key})`; 
                    allParsingOk = false;
                }
            }
            if (!allParsingOk) {
                console.warn("Psiho Fișă: Cel puțin o secțiune nu a putut fi parsată corect.");
                parsedFeedback.error_parsing = true;
            }
      }

        if (docId) {
            const docRef = doc(db, "raspunsuri", docId);
            try {
                const updatePayload = { feedback_history: arrayUnion(parsedFeedback) };
                 Object.keys(parsedFeedback).forEach(key => {
                     if (key !== 'rawText') { 
                        updatePayload[`feedback_${key}`] = parsedFeedback[key];
                     }
                 });
                await updateDoc(docRef, updatePayload);
                console.log(`Psiho Fișă: Feedback AI (model: ${modelFolosit}) salvat/actualizat pentru fișa ${docId}`);
            } catch (updateError) {
                console.error(`Psiho Fișă: Eroare update Firestore feedback pentru fișa ${docId}:`, updateError);
            }
        }
        return parsedFeedback;
    }

    // --- CHAT FUNCTIONALITY ---
    // ... (Rămâne la fel)
    function displayChatMessage(message, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) return; 
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");
        
        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        messageClass.split(' ').forEach(cls => messageElement.classList.add(cls));

        messageElement.style.whiteSpace = "pre-wrap"; 
        if (role === "AI" && message) {
            let htmlContent = message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                                   .replace(/__(.*?)__/g, '<strong>$1</strong>')
                                   .replace(/\*(.*?)\*/g, '<em>$1</em>')
                                   .replace(/_(.*?)_/g, '<em>$1</em>')
                                   .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre style="background:#eef; padding:5px; border-radius:4px; white-space:pre-wrap; word-break:break-all;">${p1.trim()}</pre>`)
                                   .replace(/`([^`]+)`/g, '<code style="background:#eef; padding:1px 3px; border-radius:3px;">$1</code>');
            
            htmlContent = htmlContent.split('\n').map(line => { // Basic list handling
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ') || trimmedLine.startsWith('+ ')) {
                    return `<li>${trimmedLine.substring(2)}</li>`;
                }
                // Basic numbered list
                if (trimmedLine.match(/^\d+\.\s+/)) {
                     return `<li>${trimmedLine.replace(/^\d+\.\s+/, '')}</li>`;
                }
                return line;
            }).join('\n');
            // Wrap li elements in ul/ol - simplistic approach
            if (htmlContent.includes("<li>")) {
                 const containsOrderedItems = /<li>[^<]*\d+\.\s*/.test(htmlContent); // Very basic check
                 const listTag = containsOrderedItems ? 'ol' : 'ul';
                 // This regex needs to be careful not to break nested structures if AI uses them (unlikely for simple lists)
                 htmlContent = htmlContent.replace(/^(<li>[\s\S]*?<\/li>)$/gm, `<${listTag}>$1</${listTag}>`); // Wrap single line lists
                 htmlContent = htmlContent.replace(/(<li>[\s\S]*?<\/li>\s*)+/gm, (match) => `<${listTag}>${match}</${listTag}>`); // Wrap multi-line lists
            }


            messageElement.innerHTML = htmlContent.replace(/\n/g, '<br>');

        } else {
            messageElement.textContent = message; 
        }

        messagesDiv.appendChild(messageElement);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    async function loadChatHistory(userId) {
        if (!userId) return [];
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists() && docSnap.data().messages && Array.isArray(docSnap.data().messages)) {
                const messages = docSnap.data().messages;
                messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                return messages;
            }
            return []; 
        } catch (error) {
            console.error("Eroare la încărcarea istoricului de chat din Firestore:", error);
            return [];
        }
    }
    
    async function saveChatMessage(userId, messageObject) {
        if (!userId || !messageObject || typeof messageObject.content !== 'string' || messageObject.content.trim() === "") return;
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            await updateDoc(historyDocRef, { messages: arrayUnion(messageObject) }, { merge: true });
        } catch (error) { 
            if (error.code === 'not-found' || error.message.includes("No document to update")) {
                 await setDoc(historyDocRef, { messages: [messageObject] });
            } else {
                console.error("Eroare la salvarea mesajului de chat în Firestore:", error);
            }
        }
    }
    
    async function initializeAndStartChatSession(userId) {
        const chatStatus = document.getElementById("chatStatus");
        const sendButton = document.getElementById("sendChatMessageButton");
        const messagesDiv = document.getElementById("chatMessages");

        if (sendButton) sendButton.disabled = true;
        if (chatStatus) chatStatus.textContent = "Inițializare chat AI...";
        if (messagesDiv) messagesDiv.innerHTML = ''; 

        if (!geminiModelChat) {
            if (chatStatus) chatStatus.textContent = "EROARE: Modelul AI Chat nu este disponibil.";
            displayChatMessage("Serviciul de chat AI nu este disponibil momentan. Verifică cheia API Gemini sau contactează administratorul.", "AI-error");
            return null; 
        }
        
        isChatInitialized = false; 
        let initialContextSummary = "REZUMAT DIN FIȘELE ANTERIOARE (ULTIMELE 3 COMPLETATE DE UTILIZATOR):\n";
        try {
            if (userId) {
                // Modificăm orderby să fie pe timestamp dacă există, altfel pe data de string (mai puțin fiabil)
                const q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId), orderBy("timestamp", "desc"), limit(3)); 
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    querySnapshot.forEach(docSnap => {
                        const data = docSnap.data();
                        const entryDate = data.date || (data.timestamp ? new Date(data.timestamp.toDate()).toLocaleDateString("ro-RO") : 'N/A');
                        initialContextSummary += ` - Fișă (${entryDate}): Situatia - ${(data.situatie || "").substring(0, 60)}...; Ganduri - ${(data.ganduri || "").substring(0, 60)}...; Emotii - ${data.emotii || 'N/A'}.\n`;
                    });
                } else { initialContextSummary += "Nicio fișă de monitorizare recentă găsită.\n"; }
            }
        } catch(e) { 
            console.error("Eroare la încărcarea contextului din fișe pentru chat:", e); 
            initialContextSummary += "Eroare la încărcarea contextului din fișe.\n";
        }

        const systemInstructionText = `# ROL PRINCIPAL ȘI PERSONA:\nTu ești PsihoGPT (alias Dr. Elena/Daniel – alege o identitate caldă și profesională). Ești un asistent AI avansat pentru auto-reflecție și explorare psihologică ghidată, specializat în Terapie Cognitiv-Comportamentală (TCC), Terapia Schemelor, Terapia prin Acceptare și Angajament (ACT), și principii ale Terapiei Dialectic-Comportamentale (DBT). Te adresezi utilizatorului cu "tu", într-un mod respectuos și empatic.\n\n# MISIUNE ȘI ABORDARE TERAPEUTICĂ:\nMisiunea ta este să ajuți utilizatorul să exploreze gânduri, emoții, comportamente și nevoi profunde, să identifice tipare și să dezvolte strategii de coping sănătoase. Vei ghida utilizatorul să:\n1.  Identifice și să înțeleagă **Schemele Maladaptative Timpurii** (explică pe scurt conceptul la nevoie, și dacă pare relevant din contextul discuției sau fișelor).\n2.  Analizeze **Distorsiunile Cognitive** și să le reformuleze.\n3.  Dezvolte abilități de **Reglare Emoțională** și **Toleranță la Disconfort**.\n4.  Clarifice **Valori Personale** și să stabilească **Obiective SMART** aliniate cu acestea.\n5.  Îmbunătățească **Stima de Sine** și **Auto-Compasiunea** (inspiră-te din Kristin Neff, Brené Brown).\n6.  Exploreze **Relația cu Sine și cu Ceilalți**, inclusiv dinamici de atașament și limite sănătoase.\n\n# PRINCIPII DE INTERACȚIUNE ȘI COMUNICARE:\n1.  **Empatie, Căldură și Non-Judecată:** Prioritatea ta absolută. Creează un spațiu sigur și validant.\n2.  **Ascultare Activă și Întrebări Deschise:** Formulează întrebări care stimulează reflecția profundă (ex: "Ce anume te face să simți/crezi asta?", "Cum se manifestă asta în corpul tău?", "Există și o altă perspectivă posibilă?", "Ce nevoie crezi că încearcă să îți comunice această emoție/situație?").\n3.  **Validare Emoțională:** Validează trăirile utilizatorului înainte de a explora sau a oferi perspective (ex: "Înțeleg că te simți copleșit/trist/furios. E firesc să simți așa în această situație.").\n4.  **Psihoeducație Dozată și Relevantă:** Dacă introduci un concept (schemă, distorsiune), explică-l concis și verifică dacă rezonează cu utilizatorul. Folosește metafore simple dacă e cazul. Evită jargonul excesiv.\n5.  **Focus pe Resurse și Puncte Forte:** Ajută utilizatorul să identifice și să mobilizeze resursele interioare și punctele forte.\n6.  **Colaborare și Ritm Adaptat:** Adaptează-te la ritmul utilizatorului. Verifică periodic înțelegerea și utilitatea discuției ("Cum ți se pare ce am discutat până acum?", "Este acest exercițiu util pentru tine?").\n7.  **Non-Directivitate Responsabilă:** NU oferi diagnostice medicale sau psihologice. NU oferi sfaturi directe care înlocuiesc terapia umană. Scopul tău este auto-reflecția ghidată.\n8.  **Utilizarea Contextului (Discret):** Folosește REZUMATUL FIȘELOR ANTERIOARE și istoricul discuției curente pentru a înțelege mai bine. Referă-te la ele cu tact ("Am observat că în una din fișele tale ai menționat X. Simți că există o legătură cu ce explorăm acum?").\n9.  **Concizie și Claritate:** Răspunsuri concise (2-5 propoziții ideal), cu paragrafe scurte. Un singur "punct" terapeutic per mesaj; așteaptă replica. Folosește Markdown pentru formatare (bold, italic, liste scurte).\n10. **Confidențialitate și Siguranță:** Reamintește discret, dacă e nevoie, că ești un AI și discuțiile nu înlocuiesc sfatul unui profesionist uman, și că datele sunt tratate conform politicilor de confidențialitate (fără a intra în detalii tehnice). Dacă utilizatorul exprimă gânduri de auto-vătămare sau vătămare a altora, ghidează-l ferm și empatic către resurse de ajutor specializat (ex: numere de urgență, linii de suport). ACEASTA ESTE O PRIORITATE.\n\n# STRUCTURĂ SUPEVIZATĂ A "ȘEDINȚEI" DE CHAT (Flexibilă):\n*   **Etapa 1 (Conectare Inițială, ~1-5 replici):** Salut, check-in emoțional general, stabilirea intenției/temei discuției.\n*   **Etapa 2 (Explorare și Lucru Central, ~5-20 replici):** Aprofundarea temei, aplicarea de tehnici (ex: restructurare cognitivă, exerciții de imagerie scurte textuale, explorarea valorilor), generare de insight-uri.\n*   **Etapa 3 (Integrare și Încheiere, ~2-5 replici):** Sumarizarea ideilor cheie, identificarea unui mic pas practic pentru săptămâna următoare, validare finală, încurajare.\n\nContext din ultimele fișe completate de utilizator (folosește-l cu discreție și inteligență):\n${initialContextSummary}---\nAcum, începe conversația cu un salut cald și o întrebare de deschidere.`;
        const aiGreeting = "Salut! Sunt PsihoGPT, asistentul tău AI pentru reflecție și explorare interioară. Cum te simți astăzi și despre ce ți-ar plăcea să discutăm sau să reflectăm împreună?";
        let historyForGeminiInitialization = [];
        
        let loadedHistoryFromDB = await loadChatHistory(userId);
        loadedHistoryFromDB.forEach(msg => {
            historyForGeminiInitialization.push({
                role: msg.role === "AI" || msg.role === "model" ? "model" : "user",
                parts: [{ text: msg.content || "" }]
            });
        });
        
        try {
            const chatConfig = {
                //  Instrucțiunea de sistem este trimisă ca prim mesaj "user" pentru compatibilitate largă.
                //  API-urile mai noi Gemini pot accepta systemInstruction separat.
                history: [{ role: "user", parts: [{ text: systemInstructionText }] }, ...historyForGeminiInitialization],
                generationConfig: { 
                    temperature: 0.75, 
                }
            };

            chatSession = geminiModelChat.startChat(chatConfig);
            console.log("Psiho Fișă: Sesiune chat Gemini inițializată. Istoric trimis:", chatConfig.history.length);
            if (chatStatus) chatStatus.textContent = "Chat pregătit.";
            
            if (messagesDiv) messagesDiv.innerHTML = ''; 
            loadedHistoryFromDB.forEach(msg => {
                 displayChatMessage(msg.content, msg.role === "model" ? "AI" : "user");
            });
            
            if (loadedHistoryFromDB.length === 0) { // Dacă nu e istoric, AI-ul salută (deja instruit în system prompt)
                 const firstAiResponse = await chatSession.sendMessage("Salut!"); // Trimitem un "trigger" pentru AI să înceapă
                 const firstAiText = firstAiResponse.response?.candidates?.[0]?.content?.parts?.[0]?.text || aiGreeting;
                 displayChatMessage(firstAiText, "AI");
                 await saveChatMessage(userId, {role: "model", content: firstAiText, timestamp: new Date().toISOString() });
            }

            isChatInitialized = true;
            if (sendButton) sendButton.disabled = false;

        } catch(initError) {
            console.error("Psiho Fișă: Eroare la inițializarea sesiunii de chat Gemini:", initError, initError.stack);
            if (chatStatus) chatStatus.textContent = "Eroare AI Chat. Reîncercați.";
            displayChatMessage("A apărut o problemă tehnică la pornirea chat-ului. Vă rugăm să închideți și redeschideți fereastra de chat sau să încercați mai târziu.", "AI-error");
            isChatInitialized = false; chatSession = null;
            if (sendButton) sendButton.disabled = true;
            return null;
        }
        return chatSession;
    }

    async function handleSendChatMessage() {
        // ... (codul funcției handleSendChatMessage - rămâne la fel)
        const chatInput = document.getElementById("chatInput");
        const sendButton = document.getElementById("sendChatMessageButton");
        const chatStatus = document.getElementById("chatStatus");

        if (!chatInput || !sendButton || !chatStatus) return;

        const messageText = chatInput.value.trim();
        if (messageText === "") return;

        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesară pentru a folosi chat-ul.");
            window.location.href = "login.html"; return;
        }

        displayChatMessage(messageText, "user");
        const userMessageForDB = { role: "user", content: messageText, timestamp: new Date().toISOString() };
        await saveChatMessage(user.uid, userMessageForDB);
        
        chatInput.value = ""; 
        sendButton.disabled = true;
        chatStatus.textContent = "PsihoGPT analizează...";

        if (!chatSession || !isChatInitialized) {
            console.log("Psiho Fișă: Sesiunea de chat nu este (re)inițializată, se încearcă acum...");
            chatSession = await initializeAndStartChatSession(user.uid); 
            if(!chatSession) { 
                chatStatus.textContent = "Eroare chat. Reîncărcați.";
                sendButton.disabled = true; 
                return; 
            }
        }
        
        try {
            const result = await chatSession.sendMessage(messageText); 
            const response = result.response;
            let aiResponseText = "Nu am putut genera un răspuns momentan. Încercați din nou.";
            let isBlockedBySafety = false;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                aiResponseText = response.candidates[0].content.parts[0].text;
                 if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Psiho Fișă: Răspuns Gemini (chat) oprit prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    aiResponseText = `AI-ul a oprit generarea (Motiv: ${response.candidates[0].finishReason}). Este posibil să fie din cauza filtrelor de siguranță. Încercați să reformulați.`;
                    isBlockedBySafety = true; 
                }
            } else if (response?.promptFeedback?.blockReason) {
                 console.warn("Psiho Fișă: Prompt blocat (chat):", response.promptFeedback.blockReason, response.promptFeedback.safetyRatings);
                 aiResponseText = `Mesajul tău sau răspunsul AI a fost blocat (Motiv: ${response.promptFeedback.blockReason}). Revizuiește conținutul sau încearcă o altă formulare.`;
                 isBlockedBySafety = true;
            }
            
            displayChatMessage(aiResponseText, isBlockedBySafety ? "AI-error" : "AI");

            const aiMessageForDB = { role: "model", content: aiResponseText, timestamp: new Date().toISOString() };
            await saveChatMessage(user.uid, aiMessageForDB);
            chatStatus.textContent = "Chat pregătit.";

        } catch (error) {
            console.error("Psiho Fișă: Eroare la trimiterea/procesarea mesajului Gemini (chat):", error, error.stack);
            chatStatus.textContent = "Eroare în comunicarea cu AI.";
            let displayError = "Ne pare rău, a apărut o eroare de comunicare cu asistentul AI. Vă rugăm încercați din nou.";
             if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429))) {
                 displayError = "Limita de utilizare a serviciului AI a fost atinsă. Vă rugăm încercați mai târziu.";
            } else if (error.message && (error.message.toLowerCase().includes("safety") || (error.message.toLowerCase().includes("blocked")) )) {
                 displayError = "Mesajul sau răspunsul AI a fost blocat, posibil din motive de siguranță. Încercați să reformulați.";
            } else if (error.message && error.message.toLowerCase().includes("api key not valid")){
                displayError = "Cheia API pentru serviciul AI nu este validă. Contactați administratorul."
            }
            displayChatMessage(displayError, "AI-error");
            isChatInitialized = false; 
            chatSession = null;
        } finally {
            if(geminiModelChat && isChatInitialized) { 
                 sendButton.disabled = false;
            } else {
                 sendButton.disabled = true; 
                 chatStatus.textContent = "Chat AI indisponibil.";
            }
            chatInput.focus();
        }
    }

    async function handleToggleChat() {
        // ... (codul funcției handleToggleChat - rămâne la fel)
        const user = auth.currentUser;
        if (!user) { alert("Autentificarea este necesară pentru chat."); window.location.href = "login.html"; return; }

        const chatContainer = document.getElementById("chatContainer");
        const toggleButton = document.getElementById("toggleChatButton");
        const sendButton = document.getElementById("sendChatMessageButton");
        if (!chatContainer || !toggleButton) return;

        if (chatContainer.style.display === "none" || chatContainer.style.display === "") {
            chatContainer.style.display = "flex"; 
            toggleButton.innerHTML = "➖"; 
            if (!isChatInitialized || !chatSession) { 
                const sessionOK = await initializeAndStartChatSession(user.uid);
                if (sendButton) sendButton.disabled = !sessionOK;
            } else if (sendButton) {
                 sendButton.disabled = !geminiModelChat;
            }
            document.getElementById("chatInput")?.focus();
        } else {
            chatContainer.style.display = "none";
            toggleButton.innerHTML = "💬"; 
        }
    }
    // --- END CHAT FUNCTIONALITY ---

    async function salveazaRaspunsSiGenereazaFeedback() {
        // ... (codul funcției salveazaRaspunsSiGenereazaFeedback - cu corecția pentru validare și timestamp)
        const form = document.getElementById("exercitiuForm");
        if (form && !form.checkValidity()) {
            form.reportValidity();
            const currentStepElement = document.querySelector('.form-step-active');
            const firstInvalidField = currentStepElement?.querySelector(':invalid:not(fieldset)');
            if (firstInvalidField) {
                firstInvalidField.focus();
                alert("Vă rugăm completați toate câmpurile obligatorii din pasul curent înainte de a salva.");
            } else {
                alert("Vă rugăm completați toate câmpurile obligatorii.");
            }
            return;
        }

        const rowData = { date: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric'}) }; 
        if (form) {
             const formData = new FormData(form);
             formData.forEach((value, key) => { rowData[key] = value.trim(); });
        } else if (document.body.classList.contains("collab-view")) {
            return;
        } else {
            console.error("Formularul 'exercitiuForm' nu a fost găsit.");
            return;
        }

        const user = auth.currentUser;
        if (!user) {
            alert("Trebuie să fiți autentificat pentru a salva datele.");
            window.location.href = "login.html"; return;
        }
        rowData.ownerUid = user.uid;
        rowData.timestamp = Timestamp.fromDate(new Date()); 
        
        const addButton = document.getElementById("addButton");
        let originalAddButtonText = "";
        if(addButton) {
            originalAddButtonText = addButton.textContent;
            addButton.textContent = "Se salvează și se generează...";
            addButton.disabled = true;
        }
        
        const confirmationMessage = document.getElementById('confirmationMessage');
        if(confirmationMessage) confirmationMessage.style.display = 'none';

        try {
            const docRef = await addDoc(collection(db, "raspunsuri"), rowData);
            rowData.id = docRef.id; 
            console.log(`Psiho Fișă: Răspuns salvat cu ID: ${docRef.id}. Se generează feedback AI...`);
            if (addButton) addButton.textContent = "Se generează AI...";

            const feedbackGenerat = await genereazaSiProceseazaFeedbackAI(rowData, docRef.id);
            const docSnapshot = await getDoc(docRef); 
            if (docSnapshot.exists()) {
                adaugaCard({ id: docSnapshot.id, ...docSnapshot.data() });
            } else { 
                 rowData.feedback_history = feedbackGenerat && !feedbackGenerat.error ? [feedbackGenerat] : [];
                adaugaCard(rowData);
            }
            
            if (form) { 
                 form.reset(); currentStep = 1; 
                 document.querySelectorAll('.form-step').forEach(step => step.classList.remove('form-step-active'));
                 const firstStepEl = document.getElementById('step-1');
                 if(firstStepEl) firstStepEl.classList.add('form-step-active');
                 updateProgressBar();
            }

            if (confirmationMessage) {
                if (feedbackGenerat && !feedbackGenerat.error && !feedbackGenerat.error_parsing) {
                    confirmationMessage.textContent = 'Fișa a fost salvată și feedback-ul AI generat cu succes! Îl puteți vedea în noul card.';
                    confirmationMessage.className = 'confirmation-message success';
                } else if (feedbackGenerat && (feedbackGenerat.error || feedbackGenerat.error_parsing)) {
                     confirmationMessage.textContent = `Fișa a fost salvată. Feedback AI: ${feedbackGenerat.rawText || 'A apărut o problemă la generarea sau parsarea feedback-ului AI.'}`;
                     confirmationMessage.className = (feedbackGenerat.rawText && feedbackGenerat.rawText.toLowerCase().includes("limit")) ? 'confirmation-message warning' : 'confirmation-message error';
                } else {
                     confirmationMessage.textContent = 'Fișa a fost salvată, dar feedback-ul AI nu a putut fi generat sau procesat corect.';
                     confirmationMessage.className = 'confirmation-message error';
                }
                confirmationMessage.style.display = 'block';
                 setTimeout(() => { if(confirmationMessage) confirmationMessage.style.display = 'none'; }, 9000);
            }
        } catch (error) {
            console.error("Psiho Fișă: Eroare la salvare sau generare feedback:", error);
            if (confirmationMessage) {
                confirmationMessage.textContent = 'Eroare la salvarea fișei. Încercați din nou. Verificați consola.';
                confirmationMessage.className = 'confirmation-message error';
                confirmationMessage.style.display = 'block';
                setTimeout(() => { if(confirmationMessage) confirmationMessage.style.display = 'none'; }, 7000);
            } else {
                alert("A apărut o eroare la salvare. Verificați consola.");
            }
        } finally {
            if(addButton) {
                addButton.textContent = originalAddButtonText;
                addButton.disabled = false;
            }
        }
    }
    function afiseazaIstoricFeedback(containerElement, feedbackHistory) {
    containerElement.innerHTML = ''; 

    if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
        const noHistoryMsg = document.createElement("p");
        noHistoryMsg.textContent = "Niciun feedback AI generat anterior pentru această fișă.";
        noHistoryMsg.style.fontStyle = "italic";
        noHistoryMsg.style.fontSize = "0.9em";
        noHistoryMsg.style.textAlign = "center";
        noHistoryMsg.style.padding = "10px 0";
        containerElement.appendChild(noHistoryMsg);
        return;
    }

    const historyTitle = document.createElement("h4");
    historyTitle.style.color = "#4A90E2";
    historyTitle.style.marginTop = "20px";
    historyTitle.style.marginBottom = "10px";
    historyTitle.textContent = "🗂️ Istoric Feedback AI:";
    containerElement.appendChild(historyTitle);

    feedbackHistory.slice().reverse().forEach((entry, index) => { 
        if (!entry || typeof entry !== 'object') {
            console.warn("Intrare invalidă în istoricul de feedback, va fi ignorată:", entry);
            return; 
        }
        
        const itemContainer = document.createElement("div");
        itemContainer.className = "feedback-entry-card"; 

        const timestampAndModel = document.createElement("p");
        timestampAndModel.className = "feedback-timestamp";
        timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> generat la: <strong>${new Date(entry.timestamp || Date.now()).toLocaleString("ro-RO")}</strong> (Model: ${entry.model || 'N/A'})`;
        itemContainer.appendChild(timestampAndModel);

        // Verifică dacă intrarea este o eroare completă
        const entryIsError = entry.error || (entry.paragraf && typeof entry.paragraf === 'string' && entry.paragraf.toUpperCase().startsWith("EROARE:")) || (entry.empatie_initiala && typeof entry.empatie_initiala === 'string' && entry.empatie_initiala.toUpperCase().startsWith("EROARE:"));

        if (entryIsError) {
            const errorP = document.createElement("p");
            errorP.style.color = "red";
            errorP.style.fontWeight = "bold";
            errorP.innerHTML = (entry.paragraf || entry.empatie_initiala || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
            itemContainer.appendChild(errorP);
            containerElement.appendChild(itemContainer);
            return; 
        }
        if (entry.error_parsing) {
             const parsingWarningP = document.createElement("p");
             parsingWarningP.style.color = "orange";
             parsingWarningP.style.fontStyle = "italic";
             parsingWarningP.textContent = "Atenție: Unele secțiuni din acest feedback AI nu au putut fi parsate corect.";
             itemContainer.appendChild(parsingWarningP);
        }

        const isNewFormat = typeof entry.empatie_initiala === 'string';
        const isLikelyOldFormat = typeof entry.paragraf === 'string' && typeof entry.empatie_initiala === 'undefined';

        if (isNewFormat) {
            const newFormatSections = [
                { title: "💬 Empatie Inițială", key: "empatie_initiala", isList: false },
                { title: "🌟 Puncte Forte Observate", key: "puncte_forte", isList: false },
                { title: "🔄 Tipare Principale", key: "tipare_principale", isList: false },
                { title: "🔗 Conexiuni Cheie", key: "conexiuni_cheie", isList: false },
                { title: "🔍 Distorsiuni Identificate", key: "distorsiuni_identificate", isList: true },
                { title: "🧠 Scheme Activate", key: "scheme_activate", isList: true },
                { title: "🎭 Moduri Implicate", key: "moduri_implicate", isList: false },
                { title: "💪 Perspectiva Adultului Sănătos", key: "perspectiva_adult_sanatos", isList: false },
                { title: "❓ Întrebare Finală de Reflecție", key: "intrebare_finala_reflectie", isList: false },
                { title: "👟 Sugestie Mic Pas Următor", key: "sugestie_mic_pas", isList: false },
                { title: "💖 Încurajare Finală", key: "incurajare_finala", isList: false }
            ];

            newFormatSections.forEach(sectionConfig => {
                const sectionDiv = document.createElement("div");
                sectionDiv.className = "feedback-section";
                const sectionTitleElement = document.createElement("h5");
                sectionTitleElement.textContent = sectionConfig.title + ":";
                sectionDiv.appendChild(sectionTitleElement);

                let contentText = entry[sectionConfig.key]; 

                if (typeof contentText === 'string' && contentText.trim() !== "" && !contentText.startsWith("(Secțiune neextrasă")) {
                    const titleWithoutEmoji = sectionConfig.title.replace(/(\p{Emoji_Presentation}|\p{Extended_Pictographic}|💬|🌟|🔄|🔗|🔍|🧠|🎭|💪|❓|👟|💖)\s*/gu, '').trim();
                    const patternTitleText = new RegExp(`^${titleWithoutEmoji.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}:?\\s*`, "im");
                    contentText = contentText.replace(patternTitleText, "").trim();

                    if (sectionConfig.isList && (contentText.includes('* ') || contentText.includes('- '))) { 
                        const listElement = document.createElement("ul");
                        const items = contentText.split(/\s*\n?\s*[\*-]\s+/) 
                                          .map(item => item.trim())
                                          .filter(item => item.length > 0);
                        if (items.length === 0 && (contentText.startsWith("* ") || contentText.startsWith("- "))) {
                            items.push(contentText.substring(2).trim());
                        }

                        items.forEach(itemText => {
                            const listItem = document.createElement("li");
                            listItem.innerHTML = itemText.replace(/\n/g, '<br>');
                            listElement.appendChild(listItem);
                        });
                        sectionDiv.appendChild(listElement);
                    } else {
                        const paragraphElement = document.createElement("p");
                        paragraphElement.innerHTML = contentText.replace(/\n/g, '<br>');
                        sectionDiv.appendChild(paragraphElement);
                    }
                } else {
                    const unavailableText = document.createElement("p");
                    unavailableText.style.fontStyle = "italic";
                    unavailableText.textContent = (contentText && contentText.startsWith("(Secțiune neextrasă")) ? contentText : "Indisponibil sau secțiune goală.";
                    sectionDiv.appendChild(unavailableText);
                }
                itemContainer.appendChild(sectionDiv);
            });

        } else if (isLikelyOldFormat) {
            const oldFormatSections = [
                { title: "✍️ Paragraf Empatic", key: "paragraf", isList: false },
                { title: "❓ Întrebare de Reflecție", key: "intrebare", isList: false },
                { title: "🛠️ Recomandare Terapeutică", key: "recomandare", isList: false },
                { title: "🔍 Distorsiuni Cognitive", key: "distorsiuni", isList: true },
                { title: "🧠 Scheme Cognitive", key: "scheme", isList: true },
                { title: "🧍‍♂️ Evaluare Adult Sănătos", key: "adult_sanatos_eval", isList: false }
            ];

            oldFormatSections.forEach(sectionConfig => {
                const sectionDiv = document.createElement("div");
                sectionDiv.className = "feedback-section";
                const sectionTitleElement = document.createElement("h5");
                sectionTitleElement.textContent = sectionConfig.title + ":";
                sectionDiv.appendChild(sectionTitleElement);
                let contentText = entry[sectionConfig.key];
                if (typeof contentText === 'string' && contentText.trim() !== "") {
                    if (sectionConfig.isList && (contentText.includes('* ') || contentText.includes('- '))) {
                        const listElement = document.createElement("ul");
                        const items = contentText.split(/\s*\n?\s*[\*-]\s+/)
                                          .map(item => item.trim())
                                          .filter(item => item.length > 0);
                        if (items.length === 0 && (contentText.startsWith("* ") || contentText.startsWith("- "))) {
                            items.push(contentText.substring(2).trim());
                        }
                        items.forEach(itemText => {
                            const listItem = document.createElement("li");
                            listItem.innerHTML = itemText.replace(/\n/g, '<br>');
                            listElement.appendChild(listItem);
                        });
                        sectionDiv.appendChild(listElement);
                    } else {
                        const paragraphElement = document.createElement("p");
                        paragraphElement.innerHTML = contentText.replace(/\n/g, '<br>');
                        sectionDiv.appendChild(paragraphElement);
                    }
                } else {
                    const unavailableText = document.createElement("p");
                    unavailableText.style.fontStyle = "italic";
                    unavailableText.textContent = "Indisponibil sau secțiune goală.";
                    sectionDiv.appendChild(unavailableText);
                }
                itemContainer.appendChild(sectionDiv);
            });
        } else {
            console.warn("Format de feedback necunoscut în istoric (nici nou, nici vechi):", entry);
            const unknownFormatDiv = document.createElement("div");
            unknownFormatDiv.className = "feedback-section";
            const titleEl = document.createElement("h5");
            titleEl.textContent = "⁉️ Conținut Feedback (format necunoscut):";
            unknownFormatDiv.appendChild(titleEl);
            const contentP = document.createElement("p");
            try { 
              contentP.innerHTML = `<pre>${JSON.stringify(entry, null, 2).replace(/\n/g, '<br>')}</pre>`;
            } catch (e) { contentP.textContent = "Nu s-a putut afișa conținutul detaliat (eroare la serializare).";}
            unknownFormatDiv.appendChild(contentP);
            itemContainer.appendChild(unknownFormatDiv);
        }
        containerElement.appendChild(itemContainer);
    });
}


    function adaugaCard(rowData) {
        // ... (Funcția adaugaCard - cu noua structură HTML și evenimente)
        const cardViewContainer = document.getElementById("cardViewContainer");
        let card = cardViewContainer.querySelector(`.response-card[data-id="${rowData.id}"]`);

        const entryDate = rowData.date || (rowData.timestamp?.toDate ? new Date(rowData.timestamp.toDate()).toLocaleDateString("ro-RO", {day: '2-digit', month: '2-digit', year: 'numeric'}) : 'Dată necunoscută');
        const cardTitle = `Fișă ${entryDate} - ${(rowData.situatie || 'Situație nedefinită').substring(0, 45)}...`;

        if (!card) { 
            card = document.createElement("div");
            card.className = "response-card"; 
            card.setAttribute("data-id", rowData.id);

            let detailsContentHtml = `
                <h4 style="margin-top:0;">Explorarea situației și a nevoilor</h4>
                <p><strong>Care este situația?</strong> ${rowData.situatie || 'N/A'}</p>
                <p><strong>Ce îmi trece prin minte?</strong> ${rowData.ganduri || 'N/A'}</p>
                <p><strong>Cum mă face acel gând să mă simt?</strong> ${rowData.emotii || 'N/A'}</p>
                <p><strong>Ce mod este activ?</strong> ${rowData.mod_activ || 'N/A'}</p>
                <p><strong>Ce comportament simți că adopți?</strong> ${rowData.comportament || 'N/A'}</p>
                <p><strong>Care sunt nevoile tale mai profunde?</strong> ${rowData.nevoi_profunde || 'N/A'}</p>
                <p><strong>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</strong> ${rowData.ajutor_comportament || 'N/A'}</p>
                <p><strong>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</strong> ${rowData.adult_sanatos || 'N/A'}</p>
                <hr>
                <h4>Analiza gândurilor și a percepțiilor</h4>
                <p><strong>Ce mă face să cred că gândul automat este adevărat?</strong> ${rowData.dovezi_adevar || 'N/A'}</p>
                <p><strong>Ce mă face să cred că nu este adevărat?</strong> ${rowData.dovezi_fals || 'N/A'}</p>
                <p><strong>Există o explicație alternativă?</strong> ${rowData.explicatie_alternativa || 'N/A'}</p>
                <p><strong>Care este cel mai rău lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_negativ || 'N/A'}</p>
                <p><strong>Care este cel mai bun lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_optimist || 'N/A'}</p>
                <p><strong>Care este cel mai realist rezultat?</strong> ${rowData.rezultat_realist || 'N/A'}</p>
                <p><strong>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</strong> ${rowData.schimbare_gandire || 'N/A'}</p>
                <p><strong>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</strong> ${rowData.sfat_prieten || 'N/A'}</p>
                <hr>
                <h4>Întrebări pentru claritate și reflecție suplimentară</h4>
                <p><strong>Văd doar partea rea a lucrurilor?</strong> ${rowData.partea_rea || 'N/A'}</p>
                <p><strong>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</strong> ${rowData.responsabilitate || 'N/A'}</p>
                <p><strong>Mă condamn în baza unui singur eveniment?</strong> ${rowData.condamnare || 'N/A'}</p>
                <p><strong>Privesc situația în termeni extremi?</strong> ${rowData.termeni_extremi || 'N/A'}</p>
                <p><strong>Exagerez situația?</strong> ${rowData.exagerare || 'N/A'}</p>
                <p><strong>Există și alți factori responsabili?</strong> ${rowData.factori_responsabili || 'N/A'}</p>
                <p><strong>Am sărit direct la concluzii?</strong> ${rowData.concluzii || 'N/A'}</p>
                <p><strong>Îmi pun întrebări fără răspuns?</strong> ${rowData.intrebari_fara_raspuns || 'N/A'}</p>
                <p><strong>Mă concentrez doar asupra slăbiciunilor mele?</strong> ${rowData.slabiciuni || 'N/A'}</p>
                <p><strong>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</strong> ${rowData.cum_ar_trebui || 'N/A'}</p>
                <p><strong>Mă aștept să fiu perfect?</strong> ${rowData.perfectiune || 'N/A'}</p>
            `;

            card.innerHTML = `
                <div class="card-header">
                    <span>${cardTitle}</span>
                    <span class="card-date">${entryDate}</span>
                </div>
                <div class="card-content">
                    <details class="journal-entry-details">
                        <summary>Vezi/Ascunde detaliile fișei completate</summary>
                        <div class="journal-entry-content-text">${detailsContentHtml}</div>
                    </details>
                    <h4 class="ai-feedback-title">Feedback AI <span style="font-weight:300; font-style:italic; font-size:0.85em;">(PsihoGPT)</span></h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                        <button class="regenerate-feedback-button" title="Regenerează Feedback AI pentru această fișă">Regenerează</button>
                        <button class="delete-last-feedback-button" title="Șterge Ultimul Feedback AI">Șterge Ultimul</button>
                        <button class="delete-all-feedback-button" title="Șterge Tot Istoricul Feedback AI">Șterge Istoric AI</button>
                        <button class="delete-journal-entry-button" title="Șterge Fișa Completă">Șterge Fișa</button>
                    </div>
                </div>
            `;

            card.querySelector('.card-header').addEventListener('click', (e) => {
                if (!e.target.closest('button') && !e.target.closest('details')) card.classList.toggle('open');
            });

            // REGENERARE
            card.querySelector('.regenerate-feedback-button').addEventListener('click', async (event) => {
                event.stopPropagation();
                const button = event.target;
                const originalButtonText = button.textContent;
                button.textContent = 'Se generează...'; button.disabled = true;
                const confirmationMsg = document.getElementById('confirmationMessage');
                if(confirmationMsg) confirmationMsg.style.display = 'none';
                
                try {
                    const docSnapshot = await getDoc(doc(db, "raspunsuri", rowData.id));
                    if (!docSnapshot.exists()) {
                         if(confirmationMsg) { confirmationMsg.textContent = 'Eroare: Fișa nu mai există.'; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block';} else { alert("Fișa nu mai există.");}
                         return; 
                    }
                    const currentCardData = { id: docSnapshot.id, ...docSnapshot.data() };
                    const newFeedback = await genereazaSiProceseazaFeedbackAI(currentCardData, currentCardData.id); 
                    
                    const updatedDoc = await getDoc(doc(db, "raspunsuri", currentCardData.id));
                    if (updatedDoc.exists()) {
                       afiseazaIstoricFeedback(card.querySelector('.ai-feedback-history-container'), updatedDoc.data().feedback_history || []);
                        const message = newFeedback && !newFeedback.error && !newFeedback.error_parsing ? "Noul feedback AI a fost generat și adăugat!" : `Feedback AI: ${newFeedback.rawText || 'Problemă la generare.'}`;
                        if(confirmationMsg) { confirmationMsg.textContent = message; confirmationMsg.className = `confirmation-message ${newFeedback && !newFeedback.error && !newFeedback.error_parsing ? 'success' : 'error'}`; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);} else {alert(message);}
                    }
                } catch (error) {
                    console.error("Eroare la regenerare (psihoterapie):", error);
                    if(confirmationMsg) { confirmationMsg.textContent = 'Eroare la regenerarea feedback-ului.'; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);} else {alert("Eroare la regenerarea feedback-ului AI.");}
                } finally {
                    button.textContent = originalButtonText; button.disabled = false;
                }
            });

            // ȘTERGE ULTIMUL
            card.querySelector('.delete-last-feedback-button').addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!confirm("Ștergi ultimul feedback AI pentru această fișă?")) return;
                const button = e.target; const originalText = button.textContent;
                button.textContent = "Se șterge..."; button.disabled = true;
                const confirmationMsg = document.getElementById('confirmationMessage');
                if(confirmationMsg) confirmationMsg.style.display = 'none';

                try {
                    const entryDocRef = doc(db, "raspunsuri", rowData.id);
                    const entrySnap = await getDoc(entryDocRef);
                    if (!entrySnap.exists() || !entrySnap.data().feedback_history?.length) {
                         const msg = "Nu există feedback de șters.";
                         if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message warning'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none';}, 7000);} else {alert(msg);}
                         return;
                    }
                    const history = entrySnap.data().feedback_history;
                    history.pop(); 
                    const updateData = { feedback_history: history };
                    // Logic to update/remove individual latest feedback fields if they exist
                    const latestFeedbackEntry = history.length > 0 ? history[history.length -1] : null;
                    const fieldsToPotentiallyUpdate = ["empatie_initiala", "puncte_forte", "tipare_principale", "conexiuni_cheie", "distorsiuni_identificate", "scheme_activate", "moduri_implicate", "perspectiva_adult_sanatos", "intrebare_finala_reflectie", "sugestie_mic_pas", "incurajare_finala", "paragraf", "intrebare", "recomandare", "distorsiuni", "scheme", "adult_sanatos_eval", "model", "timestamp", "error", "error_parsing"];
                    
                    fieldsToPotentiallyUpdate.forEach(fKey => {
                        if(latestFeedbackEntry && latestFeedbackEntry.hasOwnProperty(fKey)) {
                            updateData[`feedback_${fKey}`] = latestFeedbackEntry[fKey];
                        } else if (latestFeedbackEntry && latestFeedbackEntry.hasOwnProperty(`feedback_${fKey}`)){ // just in case
                            updateData[`feedback_${fKey}`] = latestFeedbackEntry[`feedback_${fKey}`];
                        } else {
                             updateData[`feedback_${fKey}`] = deleteField();
                        }
                    });
                    //Ensure rawText is not stored at root if not needed or is part of latestFeedbackEntry structure
                     if (latestFeedbackEntry && latestFeedbackEntry.hasOwnProperty('rawText')) {
                         // updateData['feedback_rawText'] = latestFeedbackEntry.rawText; // Optional, if you decide to store it
                     } else {
                        // updateData['feedback_rawText'] = deleteField();
                     }


                    await updateDoc(entryDocRef, updateData);
                    afiseazaIstoricFeedback(card.querySelector('.ai-feedback-history-container'), history);
                    const msg = "Ultimul feedback AI șters.";
                    if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message success'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);} else { alert(msg); }
                } catch (err) {
                    console.error("Eroare ștergere ultim feedback (psihoterapie):", err);
                    const msg = "Eroare la ștergerea feedback-ului.";
                    if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);} else { alert(msg); }
                } finally {
                    button.textContent = originalText; button.disabled = false;
                }
            });
        
            // ȘTERGE TOT ISTORICUL
            card.querySelector('.delete-all-feedback-button').addEventListener('click', async (event) => {
                event.stopPropagation(); 
                if (confirm(`Sigur ștergi TOT istoricul de feedback AI pentru fișa "${(rowData.situatie || '').substring(0,20)}..."? Ireversibil.`)) {
                    const button = event.target; const originalText = button.textContent;
                    button.textContent = 'Se șterge...'; button.disabled = true;
                    const confirmationMsg = document.getElementById('confirmationMessage');
                    if(confirmationMsg) confirmationMsg.style.display = 'none';
                    try {
                        const docRef = doc(db, "raspunsuri", rowData.id); 
                        const fieldsToDelete = { feedback_history: [] }; // Set to empty array
                        const commonFeedbackKeys = ["empatie_initiala", "puncte_forte", "tipare_principale", "conexiuni_cheie", "distorsiuni_identificate", "scheme_activate", "moduri_implicate", "perspectiva_adult_sanatos", "intrebare_finala_reflectie", "sugestie_mic_pas", "incurajare_finala", "paragraf", "intrebare", "recomandare", "distorsiuni", "scheme", "adult_sanatos_eval", "model", "timestamp", "error", "error_parsing", "rawText"]; // include rawText here if you stored it
                        commonFeedbackKeys.forEach(fKey => fieldsToDelete[`feedback_${fKey}`] = deleteField());
                        
                        await updateDoc(docRef, fieldsToDelete);
                        afiseazaIstoricFeedback(card.querySelector('.ai-feedback-history-container'), []); 
                        const msg = "Tot istoricul feedback-ului AI a fost șters!";
                        if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message success'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);} else {alert(msg);}
                    } catch (error) {
                        console.error("Eroare la ștergerea istoricului (psihoterapie):", error);
                        const msg = "Eroare la ștergerea istoricului.";
                        if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);} else {alert(msg);}
                    } finally {
                        button.textContent = originalText; button.disabled = false;
                    }
                }
            });

            // ȘTERGE FIȘA
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { 
                e.stopPropagation(); 
                stergeCard(rowData.id, card); 
            });


            const noEntriesMsg = cardViewContainer.querySelector('.no-entries-message');
            if (noEntriesMsg) noEntriesMsg.remove();

            if (cardViewContainer.firstChild && cardViewContainer.firstChild.nodeName !== 'P') {
                cardViewContainer.insertBefore(card, cardViewContainer.firstChild);
            } else {
                if (cardViewContainer.firstChild && cardViewContainer.firstChild.nodeName === 'P') cardViewContainer.innerHTML = '';
                cardViewContainer.appendChild(card);
            }
        } else { 
             card.querySelector('.card-header span:first-child').textContent = cardTitle;
             // Actualizează <details> dacă rowData s-a schimbat (puțin probabil în acest flux)
             card.querySelector('.journal-entry-content-text').innerHTML = `
                <h4 style="margin-top:0;">Explorarea situației și a nevoilor</h4>
                <p><strong>Care este situația?</strong> ${rowData.situatie || 'N/A'}</p>
                <p><strong>Ce îmi trece prin minte?</strong> ${rowData.ganduri || 'N/A'}</p>
                <p><strong>Cum mă face acel gând să mă simt?</strong> ${rowData.emotii || 'N/A'}</p>
                <p><strong>Ce mod este activ?</strong> ${rowData.mod_activ || 'N/A'}</p>
                <p><strong>Ce comportament simți că adopți?</strong> ${rowData.comportament || 'N/A'}</p>
                <p><strong>Care sunt nevoile tale mai profunde?</strong> ${rowData.nevoi_profunde || 'N/A'}</p>
                <p><strong>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</strong> ${rowData.ajutor_comportament || 'N/A'}</p>
                <p><strong>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</strong> ${rowData.adult_sanatos || 'N/A'}</p>
                <hr>
                <h4>Analiza gândurilor și a percepțiilor</h4>
                <p><strong>Ce mă face să cred că gândul automat este adevărat?</strong> ${rowData.dovezi_adevar || 'N/A'}</p>
                <p><strong>Ce mă face să cred că nu este adevărat?</strong> ${rowData.dovezi_fals || 'N/A'}</p>
                <p><strong>Există o explicație alternativă?</strong> ${rowData.explicatie_alternativa || 'N/A'}</p>
                <p><strong>Care este cel mai rău lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_negativ || 'N/A'}</p>
                <p><strong>Care este cel mai bun lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_optimist || 'N/A'}</p>
                <p><strong>Care este cel mai realist rezultat?</strong> ${rowData.rezultat_realist || 'N/A'}</p>
                <p><strong>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</strong> ${rowData.schimbare_gandire || 'N/A'}</p>
                <p><strong>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</strong> ${rowData.sfat_prieten || 'N/A'}</p>
                <hr>
                <h4>Întrebări pentru claritate și reflecție suplimentară</h4>
                <p><strong>Văd doar partea rea a lucrurilor?</strong> ${rowData.partea_rea || 'N/A'}</p>
                <p><strong>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</strong> ${rowData.responsabilitate || 'N/A'}</p>
                <p><strong>Mă condamn în baza unui singur eveniment?</strong> ${rowData.condamnare || 'N/A'}</p>
                <p><strong>Privesc situația în termeni extremi?</strong> ${rowData.termeni_extremi || 'N/A'}</p>
                <p><strong>Exagerez situația?</strong> ${rowData.exagerare || 'N/A'}</p>
                <p><strong>Există și alți factori responsabili?</strong> ${rowData.factori_responsabili || 'N/A'}</p>
                <p><strong>Am sărit direct la concluzii?</strong> ${rowData.concluzii || 'N/A'}</p>
                <p><strong>Îmi pun întrebări fără răspuns?</strong> ${rowData.intrebari_fara_raspuns || 'N/A'}</p>
                <p><strong>Mă concentrez doar asupra slăbiciunilor mele?</strong> ${rowData.slabiciuni || 'N/A'}</p>
                <p><strong>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</strong> ${rowData.cum_ar_trebui || 'N/A'}</p>
                <p><strong>Mă aștept să fiu perfect?</strong> ${rowData.perfectiune || 'N/A'}</p>
             `;
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) {
           afiseazaIstoricFeedback(feedbackContainer, rowData.feedback_history || []);
        }
    }


    async function loadTableData(userId, collabIdForLoad = null, ownerIdForCollabView = null) {
        // ... (Funcția loadTableData - cu corecții minore pentru mesaje și class names)
         const cardViewContainer = document.getElementById("cardViewContainer");
        if ((!userId && !ownerIdForCollabView) || !cardViewContainer) {
            if (cardViewContainer) cardViewContainer.innerHTML = '<p class="error-loading-message">Datele nu pot fi încărcate (informații utilizator invalide).</p>';
            return;
        }
        if (collabIdForLoad && dataAlreadyLoaded && document.body.classList.contains('collab-view-loaded')) return;
        
        let loadingMsg = cardViewContainer.querySelector(".loading-message");
        if (!cardViewContainer.querySelector('.response-card') && !cardViewContainer.querySelector('.no-entries-message') && !loadingMsg) {
            loadingMsg = document.createElement("p"); loadingMsg.className = "loading-message";
            loadingMsg.textContent = collabIdForLoad ? "Se încarcă fișele partajate..." : "Se încarcă fișele tale...";
            cardViewContainer.innerHTML = ''; cardViewContainer.appendChild(loadingMsg);
        }

        try {
            let q;
            const collectionRef = collection(db, "raspunsuri");
            if (ownerIdForCollabView) { 
                q = query(collectionRef, where("ownerUid", "==", ownerIdForCollabView), orderBy("timestamp", "desc"));
            } else if (userId) { 
                q = query(collectionRef, where("ownerUid", "==", userId), orderBy("timestamp", "desc"));
            } else { if (loadingMsg) loadingMsg.remove(); return; }

            const querySnapshot = await getDocs(q);
            if (loadingMsg) loadingMsg.remove();

            const currentCardsMap = new Map();
            cardViewContainer.querySelectorAll('.response-card').forEach(card => currentCardsMap.set(card.dataset.id, card));
            
            const newDocsData = [];
            querySnapshot.forEach((docSnap) => {
                newDocsData.push({ id: docSnap.id, ...docSnap.data() });
                if (currentCardsMap.has(docSnap.id)) currentCardsMap.delete(docSnap.id);
            });
            currentCardsMap.forEach(oldCard => oldCard.remove());
            
            if (newDocsData.length === 0 && !cardViewContainer.querySelector('.response-card')) {
                if (!cardViewContainer.querySelector('.no-entries-message')) {
                    const noEntriesMsgElement = document.createElement("p");
                    noEntriesMsgElement.className = "no-entries-message";
                    noEntriesMsgElement.textContent = collabIdForLoad ? "Nicio fișă partajată nu a fost găsită." : "Nicio fișă de monitorizare. Completează una pentru a începe!";
                    cardViewContainer.appendChild(noEntriesMsgElement);
                }
            } else {
                 const noEntriesMsgIfAny = cardViewContainer.querySelector('.no-entries-message');
                 if (noEntriesMsgIfAny) noEntriesMsgIfAny.remove();
                 newDocsData.forEach(docData => adaugaCard(docData));
            }
            if (collabIdForLoad) { dataAlreadyLoaded = true; document.body.classList.add('collab-view-loaded'); }
        } catch (error) {
            console.error("Psiho Fișă: Eroare la încărcarea cardurilor:", error.message, error.stack);
            if (loadingMsg) loadingMsg.remove();
            if(!cardViewContainer.querySelector('.response-card') && !cardViewContainer.querySelector('.error-loading-message')) {
                const errorMsgElement = document.createElement("p"); errorMsgElement.className = "error-loading-message";
                errorMsgElement.textContent = "Eroare la încărcarea fișelor. Reîncărcați pagina.";
                const noEntriesMsg = cardViewContainer.querySelector('.no-entries-message');
                if(noEntriesMsg) noEntriesMsg.remove();
                cardViewContainer.appendChild(errorMsgElement);
            }
        }
    }

    async function stergeCard(id, cardElement) { 
        // ... (codul funcției stergeCard - rămâne la fel, dar asigură consistența mesajului 'no-entries')
         if (confirm("Sunteți sigur că doriți să ștergeți această fișă și tot feedback-ul AI asociat? Această acțiune este ireversibilă.")) {
            const confirmationMsg = document.getElementById('confirmationMessage');
            if(confirmationMsg) confirmationMsg.style.display = 'none';
            try {
                await deleteDoc(doc(db, "raspunsuri", id));
                cardElement.remove();
                const container = document.getElementById("cardViewContainer");
                if(container && !container.querySelector('.response-card') && !container.querySelector('.no-entries-message')) {
                    const noEntriesMsgElement = document.createElement("p");
                    noEntriesMsgElement.className = "no-entries-message";
                    noEntriesMsgElement.textContent = "Nicio fișă de monitorizare. Completează una pentru a începe!";
                    container.appendChild(noEntriesMsgElement);
                }
                console.log(`Psiho Fișă: Fișa ${id} a fost ștearsă.`);
                if(confirmationMsg){
                     confirmationMsg.textContent = "Fișa a fost ștearsă cu succes!";
                     confirmationMsg.className = "confirmation-message success";
                     confirmationMsg.style.display = "block";
                     setTimeout(()=> {if(confirmationMsg) confirmationMsg.style.display = "none"}, 5000);
                } else {
                    alert("Fișa a fost ștearsă cu succes!");
                }
            } catch (error) {
                console.error("Psiho Fișă: Eroare la ștergerea fișei:", error);
                if(confirmationMsg){
                     confirmationMsg.textContent = "Eroare la ștergerea fișei. Verificați consola.";
                     confirmationMsg.className = "confirmation-message error";
                     confirmationMsg.style.display = "block";
                     setTimeout(()=> {if(confirmationMsg) confirmationMsg.style.display = "none"}, 5000);
                } else {
                    alert("Eroare la ștergerea fișei.");
                }
            }
        }
    }

    async function generateCollaborationLink() {
        // ... (codul funcției generateCollaborationLink - rămâne la fel)
        const user = auth.currentUser;
        if (!user) { alert("Trebuie să fiți autentificat pentru a genera un link de colaborare."); return; }
        const existingCollabQuery = query(collection(db, "collaborations"), where("owner", "==", user.uid), limit(1)); 
        const querySnapshot = await getDocs(existingCollabQuery);
        let pinCode;
        if (!querySnapshot.empty) {
            const collabDoc = querySnapshot.docs[0];
            const collabLink = `${window.location.origin}${window.location.pathname}?collabId=${collabDoc.id}`;
            const existingPin = collabDoc.data().pin;
            const renew = confirm(`Ai deja un link de colaborare activ (PIN: ${existingPin}).\nLink: ${collabLink}\n\nDorești să generezi un PIN nou pentru acest link? Anularea va păstra PIN-ul existent.`);
            if (renew) {
                 pinCode = prompt("Introduceți un nou cod PIN numeric (minim 4 cifre):");
                 if (pinCode && /^\d{4,}$/.test(pinCode)) {
                    await updateDoc(doc(db, "collaborations", collabDoc.id), { pin: pinCode, updatedAt: Timestamp.fromDate(new Date()) });
                    prompt(`PIN actualizat! Link-ul de colaborare rămâne același. Noul PIN este: ${pinCode}.\nLink: ${collabLink}`, `Link: ${collabLink}\nPIN nou: ${pinCode}`);
                 } else if(pinCode !== null) { alert("Cod PIN invalid. Trebuie să fie numeric și minim 4 cifre. PIN-ul vechi a fost păstrat."); }
            } else { prompt(`Link de colaborare existent (PIN: ${existingPin}). Îl poți redistribui:\nLink și PIN:`, `${collabLink} (PIN: ${existingPin})`); }
            return; 
        }
        pinCode = prompt("Introduceți un cod PIN numeric (minim 4 cifre) pentru noul link de colaborare:");
        if (!pinCode || !/^\d{4,}$/.test(pinCode)) { alert("Cod PIN invalid. Trebuie să fie numeric și să conțină cel puțin 4 cifre."); return; }
        try {
            const docRef = await addDoc(collection(db, "collaborations"), {  owner: user.uid, pin: pinCode, createdAt: Timestamp.fromDate(new Date()) });
            const collaborationLink = `${window.location.origin}${window.location.pathname}?collabId=${docRef.id}`;
            prompt(`Link de colaborare generat! Distribuie acest link ÎMPREUNĂ cu codul PIN.\nLink: ${collaborationLink}\nPIN: ${pinCode}`, `Link: ${collaborationLink} (PIN: ${pinCode})`);
        } catch (error) { console.error("Eroare la generarea link-ului de colaborare:", error); alert("A apărut o eroare la generarea linkului."); }
    }

    window.addEventListener('DOMContentLoaded', async () => {
        // ... (codul event listener-ului DOMContentLoaded - rămâne la fel, dar verifică și mesajul de confirmare)
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');
        const confirmationMessageElement = document.getElementById('confirmationMessage'); // Cache it

        if (collabId) {
            dataAlreadyLoaded = false; 
            document.body.classList.add("collab-view"); 
            ['exercitiuForm', 'generateLinkButton', '.form-container > h2.main-form-title', '.form-container > p:not(#confirmationMessage)', '.form-container .progress-bar'].forEach(sel => {
                const el = document.querySelector(sel);
                if (el) el.style.display = 'none'; 
            });
            
            const formContainer = document.querySelector('.form-container');
            if (formContainer && !formContainer.querySelector('h2.collab-title')) {
                const collabTitle = document.createElement('h2');
                collabTitle.className = 'collab-title'; collabTitle.style.textAlign = 'center';
                collabTitle.textContent = 'Vizualizare Fișe Partajate';
                formContainer.insertBefore(collabTitle, formContainer.firstChild);
            }
            // Ascunde mesajul de confirmare în modul colaborare, nu e relevant aici
            if(confirmationMessageElement) confirmationMessageElement.style.display = 'none';
            
            setTimeout(async () => { 
                const pin = prompt("Introduceți codul PIN pentru a vizualiza fișele de colaborare:");
                if (!pin) { alert("PIN-ul este necesar. Redirecționare."); window.location.href = "login.html"; return; }
                try {
                    const collabDocRef = doc(db, "collaborations", collabId);
                    const collabSnapshot = await getDoc(collabDocRef);
                    if (collabSnapshot.exists()) {
                        const collabData = collabSnapshot.data();
                        if (collabData.pin === pin) {
                            document.title = "Vizualizare Fișe Partajate - Psiho";
                            const formContTitle = document.querySelector('.form-container h2.collab-title');
                            if (formContTitle) formContTitle.textContent = `Fișe Partajate (Vizualizare)`;
                            await loadTableData(null, collabId, collabData.owner); 
                        } else { alert("PIN incorect. Redirecționare."); window.location.href = "login.html"; }
                    } else { alert("Link invalid/expirat. Redirecționare."); window.location.href = "login.html"; }
                } catch (error) {
                    console.error("Eroare accesare date colaborare:", error);
                    alert("Eroare accesare date. Verificați link/PIN. Redirecționare."); window.location.href = "login.html";
                }
            }, 100);
        } else {
             // Asigură-te că elementele specifice non-collab sunt vizibile dacă NU suntem în collab view
            document.getElementById('generateLinkButton')?.style.display !== 'none' ? document.getElementById('generateLinkButton').style.display = '' : null;
        }
    });
    </script>
    <style>
        /* CSS combinat și ajustat */
        body {
            font-family: 'Ubuntu', 'Roboto', 'Montserrat', 'Nunito Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            margin: 0; padding: 20px; background: #f0f2f5; 
            color: #333a40; line-height: 1.6;
        }
        .form-container {
            max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
            transition: transform 0.3s ease;
        }
        .progress-bar {width: 100%; background-color: #e9ecef; border-radius: 25px; overflow: hidden; margin-bottom: 25px; height: 12px;}
        .progress {height: 100%; width: 0; background-color: #5c85d6; transition: width 0.4s ease;}
        .question-card {
            margin-bottom: 22px; padding: 20px; background: #fdfdff; 
            border-radius: 8px; box-shadow: 0 3px 8px rgba(0,0,0,0.05);
            border: 1px solid #eef2f7;
        }
        .question-card h3 {
            font-weight: 500; font-size: 1.15em; margin-top: 0; margin-bottom: 10px; color: #334155;
            text-align: left;
        }
        .question-card p {
            font-weight: 400; font-size: 0.95em; margin-bottom: 15px; color: #475569; line-height: 1.65;
            text-align: left;
        }
        .form-container h2.main-form-title {
             font-size: 1.7em; margin-bottom: 10px; text-align: center; color: #2c3840; font-weight: 500;
        }
         .form-container h2.collab-title {
             font-size: 1.6em; margin-bottom: 20px; text-align: center; color: #2c3840; font-weight: 500;
        }
        .form-container > p:not(#confirmationMessage):not(.loading-message):not(.no-entries-message):not(.error-loading-message) {
            text-align: center; margin-top: -5px; margin-bottom: 25px; font-size: 0.95em; color: #556575;
        }
        textarea { 
            width: 100%; padding: 12px 15px; font-size: 1em;
            font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
            resize: vertical; min-height: 70px; 
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
        }
        textarea:focus {border-color: #5c85d6; box-shadow: inset 0 1px 2px rgba(0,0,0,0.06), 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;}
        .form-step-active {display: block; animation: fadeInFormStep 0.5s ease-in-out;}
        @keyframes fadeInFormStep { 0% {opacity: 0; transform: translateY(12px);} 100% {opacity: 1; transform: translateY(0);} }
        .form-step {display: none;}
        .step-navigation {text-align: center; margin-top: 25px; display: flex; justify-content: space-between; gap:15px;}
        .step-navigation button, button#addButton {
            padding: 11px 22px; font-family: inherit; font-size: 1em; font-weight: 500; 
            color: white; border: none; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, transform 0.15s ease-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step-navigation button#prevButton { background-color: #6c757d; }
        .step-navigation button#prevButton:hover { background-color: #5a6268; transform: translateY(-1px); }
        .step-navigation button#nextButton { background-color: #5c85d6; }
        .step-navigation button#nextButton:hover { background-color: #4a6fb5; transform: translateY(-1px); }
        button#addButton { background-color: #28a745; display:block; width:100%; margin-top:20px; font-size: 1.05em;}
        button#addButton:hover:not(:disabled) { background-color: #218838; transform: translateY(-1px); }
        .step-navigation button:disabled, button#addButton:disabled { 
            background: #b0c4de !important; color: #707c8b !important; 
            cursor: not-allowed !important; box-shadow: none !important; transform: translateY(0) !important;
        }
        .confirmation-message, 
        .no-entries-message, .loading-message, .error-loading-message { 
            text-align: center; margin-top:20px; font-style: italic; 
            color: #556575; font-size: 1em; padding:12px; border-radius: 6px; 
        }
        .confirmation-message { font-style: normal; font-weight:500; animation: fadeIn 0.4s; display:none;}
        .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border:1px solid #b3d9c0; }
        .confirmation-message.error   { background-color: #fdecea; color: #b32d21; border:1px solid #f8c6c1; }
        .confirmation-message.warning { background-color: #fff8e1; color: #795508; border:1px solid #ffecb3; }
        .error-loading-message        { color: #c0392b; font-weight: 500; background-color: #fdecea; border:1px solid #f8c6c1;}
        .loading-message              { background-color: #e9f0ff; border:1px solid #d1dfff;}
        @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
        
        h3#cardViewTitle {
            color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
            font-size: 1.4em; margin-top: 40px; 
        }
        .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
        .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
        .response-card .card-header {
            font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
            padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
            display: flex; justify-content: space-between; align-items: center;
        }
        .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap; font-weight: 400;}
        .response-card .card-header::after {content: '▼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
        .response-card.open .card-header::after {transform: rotate(180deg);}
        .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
        .response-card.open .card-content { max-height: 8000px; padding: 20px 20px; }
        .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
        .journal-entry-details summary { 
            cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
            background-color: #f8f9fa; border-radius: 6px 6px 0 0; list-style-position: inside; 
        }
        .journal-entry-details summary:hover { background-color: #f1f3f6; }
        .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
        .journal-entry-content-text {
            padding: 12px; font-size: 0.95em; line-height: 1.65; color: #3e4c59; 
            max-height: 450px; overflow-y: auto;
        }
        .journal-entry-content-text hr {margin: 15px 0; border: 0; border-top: 1px dashed #dde2e7;}
        .journal-entry-content-text h4 {
             font-size: 1.05em; color: #5c85d6; margin-top: 15px; margin-bottom:8px; font-weight: 500;
        }
        .journal-entry-content-text p { margin-bottom: 10px; }
        .journal-entry-content-text p strong { font-weight: 500; color: #1e293b; margin-right: 5px; }
        .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
        .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }
        .response-card > .card-content > h4.ai-feedback-title { /* Clasa adaugata in HTML */
            color: #5c85d6; font-weight: 500; margin-top: 0px; 
            margin-bottom: 15px; font-size: 1.1em; 
            border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
        }
        .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }
        .ai-feedback-history-container { margin-top: 10px; }
        .feedback-entry-card { 
            background:#fdfdff; padding: 15px; border: 1px solid #e7ecf2;
            border-left: 4px solid #5c85d6; border-radius:8px; margin-bottom:15px; 
            font-size:0.95em; line-height:1.6; box-shadow: 0 2px 5px rgba(0,0,0,0.03);
        }
        .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
        .card-actions { 
            text-align: right; margin-top: 20px; padding-top: 15px; 
            border-top: 1px solid #eef2f7; display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
        }
        .card-actions button {
            padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
            transition: all 0.2s; border: 1px solid transparent; cursor: pointer;
        }
        button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
        button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
        button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
        button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
        button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
        button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
        button.delete-all-feedback-button { background-color:transparent; color: #9b2c2c; border-color: #fed7d7;} 
        button.delete-all-feedback-button:hover { background-color: #9b2c2c; color: white;}
        .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
        .content-ai .ai-main-section-title, 
        .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 { 
            font-weight: 600; color: #3b74d7; margin-top: 1.2em; margin-bottom: 0.6em; 
            font-size: 1.05em; padding-bottom: 4px;
        }
        .content-ai .ai-main-section-title:first-child, 
        .content-ai h1:first-child, .content-ai h2:first-child, 
        .content-ai h3:first-child, .content-ai h4:first-child { margin-top: 0.3em; }
        .content-ai p.ai-text-paragraph { margin-bottom: 0.9em; }
        .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; } 
        .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; } 
        .content-ai ul.ai-list, .content-ai ol.ai-list {
            margin-left: 5px; padding-left: 22px; margin-bottom: 0.9em; list-style-position: outside;
        }
        .content-ai .ai-list-item { margin-bottom: 0.5em; }
        .content-ai .ai-list-item::marker { color: #4a69bd; font-weight: bold; } 
        .content-ai .ai-text-error {
            color: #c0392b; font-weight: 500; background-color: #fff5f5; 
            padding: 10px 12px; border-radius: 4px; border: 1px solid #fecaca; border-left: 4px solid #ef4444;
            white-space: pre-wrap; font-size: 0.9em;
        }
        .chat-container {
            display: none; flex-direction: column; position: fixed; bottom: 20px; right: 20px;
            width: clamp(350px, 40vw, 450px); max-height: calc(100vh - 90px); 
            background: #ffffff; border-radius: 16px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 1000; padding: 0; box-sizing: border-box; overflow: hidden;
            font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        }
        .chat-container h3 {
            text-align: center; color: #334155; margin: 0; padding: 16px 20px;
            font-size: 1.1em; font-weight: 500; background-color: #f8f9fc;
            border-bottom: 1px solid #e9edf2; flex-shrink: 0;
        }
        #chatMessages {
            flex-grow: 1; overflow-y: auto; padding: 18px; background: #ffffff;
            display: flex; flex-direction: column; gap: 12px;
        }
        #chatMessages::-webkit-scrollbar { width: 6px; }
        #chatMessages::-webkit-scrollbar-track { background: #f0f2f5; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb { background: #bfc8d3; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb:hover { background: #a8b3bf; }
        .chat-message {
            padding: 11px 16px; border-radius: 18px; max-width: 83%;
            word-wrap: break-word; line-height: 1.55;
            box-shadow: 0 2px 5px rgba(0,0,0,0.06);
            font-size: 0.96em; font-weight: 400; position: relative;
        }
        .user-message {
            background: linear-gradient(135deg, #5c85d6 0%, #3b6cb7 100%); 
            color: white; align-self: flex-end; margin-left: auto;
            border-bottom-right-radius: 6px; 
        }
        .ai-message {
            background: #f0f3f7; color: #2c3e50; align-self: flex-start;
            margin-right: auto; border-bottom-left-radius: 6px;
            font-family: 'Ubuntu', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
        }
         .ai-message em, .ai-message i { font-family: 'Ubuntu', inherit; font-style: italic; font-weight: 400; }
         .ai-message strong, .ai-message b { font-family: 'Ubuntu', inherit; font-weight: 700; }
        .ai-message.ai-error {
            background-color: #ffe3e3; color: #b71c1c; border: 1px solid #ffc5c5;
            font-family: 'Ubuntu', sans-serif;
        }
        .chat-input-area {
            padding: 15px 20px; border-top: 1px solid #e9edf2;
            background-color: #f8f9fc; flex-shrink: 0;
            display: flex; flex-direction: column; gap: 10px;
        }
        #chatInput {
            width: 100%; padding: 11px 16px; border-radius: 10px;
            border: 1px solid #d9e0ea; resize: none; min-height: 46px; max-height: 120px;
            box-sizing: border-box; font-family: 'Ubuntu', sans-serif;
            font-size: 0.96em; font-weight: 400; line-height: 1.5;
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #ffffff;
        }
        #chatInput:focus {
            border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.18);
            outline: none;
        }
        #sendChatMessageButton {
            padding: 11px 20px; width: 100%;
            font-family: 'Ubuntu', sans-serif; font-size: 1em; font-weight: 500; 
            background-color: #5c85d6; color: white; border: none;
            border-radius: 10px; transition: background-color 0.2s, transform 0.15s ease-out;
            cursor: pointer; margin-top:0; 
        }
        #sendChatMessageButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); }
        #sendChatMessageButton:disabled { background-color: #c3d9f0 !important; color: #7c8da3 !important; transform: translateY(0) !important;}
        #chatStatus {
            font-size: 0.85em; color: #6c757d; text-align: center;
            min-height: 1.2em; padding-bottom: 0; flex-shrink: 0; font-weight: 400;
        }
        #toggleChatButton {
            position: fixed; bottom: 25px; right: 25px; padding: 0; z-index: 1001;
            display: flex; align-items: center; justify-content: center;
            background-color: #5c85d6; color: white; border: none; border-radius: 50%;
            width: 58px; height: 58px; font-size: 26px; 
            box-shadow: 0 5px 15px rgba(92, 133, 214, 0.25);
            cursor: pointer; transition: all 0.3s ease;
        }
        #toggleChatButton:hover { background-color: #4a6fb5; transform: scale(1.1) rotate(10deg); box-shadow: 0 7px 20px rgba(74, 107, 181, 0.35); }
        
        @media (max-width: 820px) {
             .form-container, .card-view {padding:20px; margin-left:15px; margin-right:15px; max-width:calc(100% - 30px);}
        }
        @media (max-width: 768px) {
            body {padding:15px; font-size: 15px;}
            .form-container, .card-view {padding:15px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);} /* Ajustat padding/margin */
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.5em;} 
            h3#cardViewTitle {font-size: 1.25em;}
            .step-navigation button, button#addButton {font-size:0.95em; padding:10px 18px;} 
            .card-actions button {font-size:0.78em; padding:7px 10px; flex-basis:auto;}
            .response-card .card-header {font-size:1.05em;}
            .question-card h3 {font-size:1.1em;}
            .question-card p {font-size:0.92em;}
            .journal-entry-content-text { font-size: 0.92em;}
            .chat-container { 
                width: calc(100% - 30px); max-height: calc(100vh - 100px); 
                bottom: 15px; left: 15px; right: auto; 
                border-radius: 12px; 
            }
            .chat-container h3 { padding: 14px 15px; font-size: 1.05em; }
            #chatMessages { padding: 15px; gap: 10px; } 
            .chat-message { padding: 10px 14px; font-size: 0.92em; max-width: 88%; border-radius: 16px; }
            #toggleChatButton { width: 55px; height: 55px; font-size: 24px; bottom: 20px; right: 20px;}
            .chat-input-area { padding: 12px 15px; gap: 8px; }
            #chatInput { padding: 10px 14px; font-size: 0.92em; min-height: 44px; border-radius: 10px; }
            #sendChatMessageButton { padding: 10px 15px; font-size: 0.95em; border-radius: 10px; }
        }
        @media (max-width: 480px) {
            body {padding:10px; font-size: 14px;}
            .form-container, .card-view {padding:12px; margin-left:5px; margin-right:5px; max-width:calc(100% - 10px);}
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.35em;} h3#cardViewTitle {font-size: 1.2em;}
            .question-card h3, .response-card .card-header {font-size:1em;}
            .question-card p {font-size:0.9em;}
            .journal-entry-content-text { font-size: 0.9em;}
            textarea {font-size:0.95em; padding:10px; min-height: 60px;}
            .step-navigation button, button#addButton {font-size:0.9em; padding:9px 15px;}
            .card-actions button {font-size:0.75em; padding:6px 8px; flex-basis: calc(50% - 5px);}
            .response-card .card-header {padding:12px 15px; flex-direction: column; align-items: flex-start; gap: 4px;}
            .response-card .card-header::after { align-self: flex-end; margin-top: -1.3em; } 
            .chat-container { max-height: calc(100vh - 80px); bottom: 10px; left: 10px; width: calc(100% - 20px); border-radius: 10px; }
            .chat-container h3 { font-size: 1em; padding: 12px 15px; }
            #chatMessages { padding: 12px; gap: 8px; }
            .chat-message { font-size: 0.9em; padding: 9px 12px; border-radius: 14px; }
            .chat-input-area { padding: 10px 12px; gap: 8px;}
            #chatInput {font-size: 0.9em; min-height: 42px; padding: 9px 12px; border-radius: 8px;}
            #sendChatMessageButton {font-size: 0.9em; padding: 9px 12px; border-radius: 8px;}
            #toggleChatButton { width: 50px; height: 50px; font-size: 22px; bottom: 15px; right: 15px; }
        }

/* Asigură-te că aceste reguli sunt prezente și corecte */
.form-step {
    display: none; /* Ascunde pașii inactivi */
}
.form-step-active {
    display: block; /* AFIȘEAZĂ pasul activ */
    animation: fadeInFormStep 0.5s ease-in-out;
}
@keyframes fadeInFormStep { 
    0% {opacity: 0; transform: translateY(12px);} 
    100% {opacity: 1; transform: translateY(0);} 
}

/* Verifică să nu existe o altă regulă care ar putea ascunde .question-card */
.question-card {
    margin-bottom: 22px; 
    padding: 20px; 
    background: #fdfdff; 
    border-radius: 8px; 
    box-shadow: 0 3px 8px rgba(0,0,0,0.05);
    border: 1px solid #eef2f7;
    /* Nu ar trebui să aibă display: none aici! */
}  

.form-step {
    display: none; 
}
.form-step-active {
    display: block; /* Important! */
    animation: fadeInFormStep 0.5s ease-in-out;
}

.question-card {
    /* ... stilurile existente pentru aspectul cardului ... */
    /* Asigură-te că nu ai aici 'display: none' care ar putea interfera */
}
    </style>
</head>
<body>
     <div class="form-container">
        <h2 class="main-form-title">Fișă Monitorizare</h2> <!-- Adăugat o clasă pentru a o putea ascunde selectiv -->
        <p>Completează fiecare întrebare pentru a înțelege mai bine situațiile tale. Fiecare secțiune reprezintă o parte importantă a reflecției tale. În acest exercițiu, îți voi ghida fiecare pas, astfel încât să poți explora în profunzime gândurile, emoțiile și comportamentele tale.</p>
    
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    
        <form id="exercitiuForm" novalidate>
            <!-- PASUL 1 -->
            <div class="question-card form-step form-step-active" id="step-1">
                <h3>Care este situația?</h3>
                <p>Te rog să descrii contextul care a declanșat emoțiile sau comportamentul tău. Încearcă să fii cât mai specific și detaliat. Aceasta poate fi o situație concretă din viața de zi cu zi în care te-ai simțit copleșit, stresat sau într-o altă stare emoțională intensă.</p>
                <textarea name="situatie" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-2">
                <h3>Ce îmi trece prin minte?</h3>
                <p>Îți cer să identifici gândurile automate care au apărut în această situație. Acestea sunt gânduri rapide, involuntare, care îți trec prin minte în momentele de stres. Ce îți spui în acel moment? Este un gând critic sau îngrijorător?</p>
                <textarea name="ganduri" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-3">
                <h3>Cum mă face acel gând să mă simt?</h3>
                <p>Te rog să notezi emoțiile pe care le simți în urma acelui gând. Ce simți? Frică, tristețe, furie? Dă o intensitate emoției (de la 0 la 100) pentru a vedea cât de puternică este.</p>
                <textarea name="emotii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-4">
                <h3>Ce mod este activ?</h3>
                <p>Identifică modul în care te afli în această situație. Este un mod de copil vulnerabil, critic interior, sau poate adultul sănătos? Conștientizarea modului îți poate oferi o mai bună înțelegere a reacțiilor tale.</p>
                <textarea name="mod_activ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-5">
                <h3>Ce comportament simți că adopți?</h3>
                <p>Descrie comportamentul pe care îl manifești în această situație. Este un comportament de evitare, de confruntare, de sacrificiu de sine? Recunoașterea comportamentului te ajută să înțelegi mai bine cum reacționezi.</p>
                <textarea name="comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-6">
                <h3>Care sunt nevoile tale mai profunde?</h3>
                <p>Ce nevoi stau la baza acestor emoții și comportamente? Poate fi nevoia de siguranță, de validare, de acceptare? Identificarea acestor nevoi te poate ajuta să găsești strategii mai sănătoase pentru a le îndeplini.</p>
                <textarea name="nevoi_profunde" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-7">
                <h3>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</h3>
                <p>Reflectează dacă felul în care reacționezi te ajută cu adevărat să îți îndeplinești nevoile. Poate fi util să te gândești dacă există alternative mai eficiente.</p>
                <textarea name="ajutor_comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-8">
                <h3>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</h3>
                <p>Gândește-te la cum ar reacționa partea ta Adultă Sănătoasă în această situație. Cum ai putea să abordezi diferit pentru a avea grijă de tine și de nevoile tale?</p>
                <textarea name="adult_sanatos" rows="3" required></textarea>
            </div>

            <!-- PASUL 2 -->
            <div class="question-card form-step" id="step-9">
                <h3>Ce mă face să cred că gândul automat este adevărat?</h3>
                <p>Explorează motivele pentru care crezi că acest gând este adevărat. Ce dovezi ai care îți confirmă acest lucru? De multe ori, ne bazăm pe experiențe trecute sau frici pentru a justifica un gând.</p>
                <textarea name="dovezi_adevar" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-10">
                <h3>Ce mă face să cred că nu este adevărat?</h3>
                <p>Acum, să ne uităm la dovezile împotriva gândului tău. Există argumente sau experiențe care contrazic acest gând? Poate există o altă perspectivă pe care nu ai luat-o în considerare?</p>
                <textarea name="dovezi_fals" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-11">
                <h3>Există o explicație alternativă?</h3>
                <p>Uneori, există mai multe explicații pentru ceea ce se întâmplă. Ce alte interpretări ai putea avea pentru această situație? Gândește-te la alte posibilități care ar putea explica contextul.</p>
                <textarea name="explicatie_alternativa" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-12">
                <h3>Care este cel mai rău lucru care s-ar putea întâmpla?</h3>
                <p>Ce este cel mai rău care ar putea avea loc în această situație? Să identificăm acele frici catastrofale care adesea ne alimentează gândurile negative.</p>
                <textarea name="scenariu_negativ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-13">
                <h3>Care este cel mai bun lucru care s-ar putea întâmpla?</h3>
                <p>Pe de altă parte, care ar fi cel mai pozitiv scenariu? Uneori uităm să ne gândim și la posibilitățile bune. Cum ar arăta cel mai bun rezultat al acestei situații?</p>
                <textarea name="scenariu_optimist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-14">
                <h3>Care este cel mai realist rezultat?</h3>
                <p>După ce am explorat extremele, ce crezi că este cel mai probabil să se întâmple? Cum ar arăta un rezultat realist, ținând cont de toate perspectivele?</p>
                <textarea name="rezultat_realist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-15">
                <h3>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</h3>
                <p>Întreabă-te cum ar fi dacă ai aborda situația cu un alt tip de gândire. Cum ar influența asta emoțiile și comportamentele tale?</p>
                <textarea name="schimbare_gandire" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-16">
                <h3>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</h3>
                <p>Gândește-te la cum ai reacționa dacă un prieten drag ar avea aceleași gânduri. Ce i-ai spune pentru a-l sprijini? Cum ai încerca să-l încurajezi?</p>
                <textarea name="sfat_prieten" rows="3" required></textarea>
            </div>

            <!-- PASUL 3 -->
            <div class="question-card form-step" id="step-17">
                <h3>Văd doar partea rea a lucrurilor?</h3>
                <p>Este posibil să fii prins într-un tipar negativ de gândire, concentrându-te doar pe aspectele negative. Încearcă să observi dacă există și aspecte pozitive pe care le-ai ignorat.</p>
                <textarea name="partea_rea" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-18">
                <h3>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</h3>
                <p>Reflectează dacă îți asumi responsabilitatea pentru situații asupra cărora nu aveai control. Este important să îți dai seama de limitele influenței tale.</p>
                <textarea name="responsabilitate" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-19">
                <h3>Mă condamn în baza unui singur eveniment?</h3>
                <p>Îți evaluezi valoarea personală bazându-te pe un singur eveniment negativ? Amintește-ți că un eveniment nu definește cine ești în totalitate.</p>
                <textarea name="condamnare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-20">
                <h3>Privesc situația în termeni extremi?</h3>
                <p>Verifică dacă vezi situația doar în alb sau negru, fără nuanțe de gri. Gândirea extremă poate distorsiona realitatea.</p>
                <textarea name="termeni_extremi" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-21">
                <h3>Exagerez situația?</h3>
                <p>Îți amplifici reacțiile față de o situație? Încearcă să te gândești dacă ceea ce percepi este realist sau dacă exagerezi impactul situației.</p>
                <textarea name="exagerare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-22">
                <h3>Există și alți factori responsabili?</h3>
                <p>Există alți factori care contribuie la această situație, pe lângă tine? Este important să ai o perspectivă completă asupra cauzelor unei situații.</p>
                <textarea name="factori_responsabili" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-23">
                <h3>Am sărit direct la concluzii?</h3>
                <p>Te-ai grăbit să ajungi la o concluzie fără suficiente dovezi? Încearcă să observi dacă există alte posibilități care ar putea explica situația.</p>
                <textarea name="concluzii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-24">
                <h3>Îmi pun întrebări fără răspuns?</h3>
                <p>Te frământă întrebări care nu au un răspuns clar sau realist? Aceste întrebări pot fi o sursă majoră de anxietate.</p>
                <textarea name="intrebari_fara_raspuns" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-25">
                <h3>Mă concentrez doar asupra slăbiciunilor mele?</h3>
                <p>Ai tendința să te focalizezi doar pe slăbiciuni și să ignori punctele tale forte? Încearcă să îți recunoști și punctele pozitive.</p>
                <textarea name="slabiciuni" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-26">
                <h3>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</h3>
                <p>Ai tendința să te gândești mereu la cum ar trebui să fie lucrurile, în loc să accepți situația așa cum este? Acceptarea poate reduce stresul și anxietatea.</p>
                <textarea name="cum_ar_trebui" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-27">
                <h3>Mă aștept să fiu perfect?</h3>
                <p>Îți setezi standarde foarte înalte, imposibil de atins? Perfecționismul poate fi o sursă majoră de frustrare și descurajare.</p>
                <textarea name="perfectiune" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-28">
                <h3>Completare finalizată!</h3>
                <p>Felicitări pentru parcurgerea acestui exercițiu de auto-reflecție! Apasă butonul de mai jos pentru a salva datele și a genera un feedback automatizat, dacă este disponibil.</p>
                <p>Feedback-ul AI te poate ajuta să obții noi perspective. Dacă întâmpini probleme cu generarea (ex: erori de limită de utilizare sau cheie API invalidă), poți încerca din nou mai târziu sau contacta administratorul.</p>
            </div>

            <div class="step-navigation">
                <button type="button" id="prevButton">Înapoi</button>
                <button type="button" id="nextButton">Înainte</button>
            </div>
            <button type="button" id="addButton">Salvează și Generează Feedback AI</button>
        </form>

        <div id="confirmationMessage" class="confirmation-message"></div>

        <div class="collaboration-section" style="text-align:center; margin-top:30px; padding-bottom:10px; border-top: 1px solid #eef2f7; padding-top:20px;">
            <button type="button" id="generateLinkButton" style="background-color:#007bff; font-size:0.9em; padding:10px 20px; color:white; border:none; border-radius:8px; cursor:pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">Partajează Fișele (Generează Link)</button>
        </div>
    </div>
    
    <h3 id="cardViewTitle" style="text-align: center; margin-top: 40px; margin-bottom: 20px; color: #333a40; font-weight: 500;">Răspunsurile Tale și Istoricul Feedback-ului AI:</h3>
    
    <div class="card-view" id="cardViewContainer">
        <!-- Cardurile vor fi adăugate aici de JS -->
    </div>
    
    <div class="chat-container" id="chatContainer">
        <h3>Discută cu PsihoGPT</h3>
        <div id="chatMessages"></div>
        <textarea id="chatInput" rows="2" placeholder="Scrie mesajul tău... Apasă Enter pentru a trimite."></textarea>
        <button id="sendChatMessageButton" disabled>Trimite Mesaj</button>
        <p id="chatStatus"></p>
    </div>
    <button id="toggleChatButton" style="display: none;">💬</button>

    <div class="table-container" style="display: none;"> 
        <table>
            <thead> <tr> <th>Data</th><th>Situația</th><th>Gânduri</th><th>Emoții</th><th>Mod activ</th> <th>Comportament</th><th>Nevoile</th><th>Ajutor comport.</th><th>Adult Sănătos</th><th>Detalii</th> </tr> </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <br/>
</body>
</html>