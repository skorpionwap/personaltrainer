<!DOCTYPE html>
<html>
<head>
    <title>FiÈ™Äƒ Monitorizare - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, deleteField, doc, getDoc, updateDoc, arrayUnion, query, where, setDoc, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", 
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- CHEIA TA API GEMINI AICI (SA NU FIE PLACEHOLDER!)
    const GEMINI_MODEL_NAME_FEEDBACK = "gemini-1.5-flash-latest"; // Sau gemini-1.5-pro-latest etc.
    const GEMINI_MODEL_NAME_CHAT = "gemini-1.5-flash-latest";
    let genAI, geminiModelFeedback, geminiModelChat;

     if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "" && !GEMINI_API_KEY.startsWith("AIzaSyA_YOUR_KEY_HERE") && !GEMINI_API_KEY.includes("ÃŽNLOCUIEÈ˜TE")) {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_FEEDBACK });
            geminiModelChat = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_CHAT });
            console.log("Psiho FiÈ™Äƒ: SDK Gemini iniÈ›ializat. Model Feedback:", GEMINI_MODEL_NAME_FEEDBACK, "Model Chat:", GEMINI_MODEL_NAME_CHAT);
        } catch (e) {
            console.error("Psiho FiÈ™Äƒ: Eroare criticÄƒ la iniÈ›ializarea SDK Gemini:", e);
            alert("Psiho FiÈ™Äƒ: Eroare la iniÈ›ializarea serviciului AI. VerificaÈ›i cheia API Gemini. FuncÈ›ionalitatea AI va fi limitatÄƒ.");
            geminiModelFeedback = null; geminiModelChat = null;
        }
    } else  {
        const warningMsg = `Psiho FiÈ™Äƒ: Cheia API Gemini este goalÄƒ, un placeholder, sau lipseÈ™te. FuncÈ›ionalitatea AI va fi dezactivatÄƒ. VÄƒ rugÄƒm configuraÈ›i o cheie validÄƒ.`;
        console.warn(warningMsg);
        alert(warningMsg);
        geminiModelFeedback = null; geminiModelChat = null;
    }


    let currentStep = 1;
    let totalSteps = 0;
    let dataAlreadyLoaded = false;
    let chatSession = null;
    const CHAT_HISTORY_DOC_ID_PREFIX = "chatHistory_";
    let isChatInitialized = false;


    window.onload = function () {
        const formSteps = document.querySelectorAll('.form-step');
        if (formSteps.length > 0) { // VerificÄƒ dacÄƒ elementele formularului sunt prezente
            totalSteps = formSteps.length;
            updateProgressBar();
            document.getElementById("nextButton")?.addEventListener("click", nextStep);
            document.getElementById("prevButton")?.addEventListener("click", previousStep);
            document.getElementById("addButton")?.addEventListener("click", salveazaRaspunsSiGenereazaFeedback);
            document.getElementById("generateLinkButton")?.addEventListener("click", generateCollaborationLink);
        }


        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (!collabId) {
            onAuthStateChanged(auth, async (user) => {
                const toggleChatBtn = document.getElementById("toggleChatButton");
                const chatContainer = document.getElementById("chatContainer");

                if (user) {
                    console.log("Utilizator autentificat (fiÈ™Äƒ):", user.uid);
                    if (!dataAlreadyLoaded) {
                        // populateTableData(user.uid); // Aceasta funcÈ›ie oricum nu mai e folositÄƒ activ
                        loadTableData(user.uid);
                        dataAlreadyLoaded = true;
                    }
                    if(toggleChatBtn) toggleChatBtn.style.display = 'flex'; // SeteazÄƒ pe flex pentru a fi vizibil conform CSS
                } else {
                    console.log("Utilizator neautentificat, redirecÈ›ionare... (fiÈ™Äƒ)");
                    if(toggleChatBtn) toggleChatBtn.style.display = 'none';
                    if(chatContainer) chatContainer.style.display = 'none';
                    isChatInitialized = false;
                    chatSession = null;
                    window.location.href = "login.html";
                }
            });
        } else { // Mod colaborare
            const toggleChatBtn = document.getElementById("toggleChatButton");
            if(toggleChatBtn) toggleChatBtn.style.display = 'none';
            const chatContainer = document.getElementById("chatContainer");
            if(chatContainer) chatContainer.style.display = 'none';
             // Logica specificÄƒ pentru modul colaborare se va executa Ã®n DOMContentLoaded
        }
        
        document.getElementById("toggleChatButton")?.addEventListener("click", handleToggleChat);
        document.getElementById("sendChatMessageButton")?.addEventListener("click", handleSendChatMessage);
        document.getElementById("chatInput")?.addEventListener("keypress", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); 
                handleSendChatMessage();
            }
        });
    };

    function nextStep() {
        if (currentStep < totalSteps) {
            const currentStepEl = document.getElementById(`step-${currentStep}`);
            if(currentStepEl) currentStepEl.classList.remove('form-step-active');
            currentStep++;
            const nextStepEl = document.getElementById(`step-${currentStep}`);
            if(nextStepEl) nextStepEl.classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function previousStep() {
        if (currentStep > 1) {
            const currentStepEl = document.getElementById(`step-${currentStep}`);
            if(currentStepEl) currentStepEl.classList.remove('form-step-active');
            currentStep--;
            const prevStepEl = document.getElementById(`step-${currentStep}`);
            if(prevStepEl) prevStepEl.classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function updateProgressBar() {
        const progress = document.getElementById('progress');
        if(progress && totalSteps > 0) {
            const progressPercentage = (currentStep / totalSteps) * 100;
            progress.style.width = progressPercentage + '%';
        }
    }
    
    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) {
            console.error("Modelul Gemini specificat este invalid sau neiniÈ›ializat.", modelToUse === geminiModelChat ? "(Model Chat)" : "(Model Feedback FiÈ™Äƒ)");
            return "EROARE: Model AI neiniÈ›ializat. VerificÄƒ cheia API.";
        }
        try {
            console.log("Trimitem la Gemini (fiÈ™Äƒ, primele 200 caractere):", promptText.substring(0, 200));
            const requestPayload = {
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.55, maxOutputTokens: 4000, ...generationConfigOptions } // temp 0.55, max token specific fiÈ™ei
            };
            const result = await modelToUse.generateContent(requestPayload); 
            const response = result.response;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Gemini a oprit generarea prematur (fiÈ™Äƒ):", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    return `EROARE Gemini: Generare opritÄƒ (Motiv: ${response.candidates[0].finishReason}). Detalii: ${JSON.stringify(response.candidates[0].safetyRatings || 'N/A')}`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                console.error("Prompt blocat de Gemini (fiÈ™Äƒ):", response.promptFeedback.blockReasonDetail || response.promptFeedback.blockReason);
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Detalii: ${JSON.stringify(response.promptFeedback.blockReasonDetail || response.promptFeedback.safetyRatings || 'N/A')}`;
            } else {
                console.error("RÄƒspuns Gemini neaÈ™teptat sau gol (fiÈ™Äƒ):", JSON.stringify(response, null, 2));
                return "EROARE Gemini: RÄƒspuns invalid sau gol de la API.";
            }
        } catch (error) {
            console.error("Eroare detaliatÄƒ la callGeminiAPI (fiÈ™Äƒ):", error, error.stack);
            let errorMessage = `EROARE Gemini: ${error.message || "Eroare API necunoscutÄƒ"}`;
             if (error.toString().toLowerCase().includes("api key not valid") || 
                (error.message && error.message.toLowerCase().includes("permission denied")) ||
                (error.message && error.message.toLowerCase().includes("api_key_invalid")) ||
                (error.status && error.status === 403)) {
                 errorMessage = "EROARE: Cheia API Gemini nu este validÄƒ sau nu are permisiuni. VerificÄƒ restricÈ›iile din Google Cloud Console È™i cheia din cod. AsigurÄƒ-te cÄƒ domeniul " + (typeof window !== 'undefined' ? window.location.hostname : '') + " este permis.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429) || (error.toString().toLowerCase().includes("resource has been exhausted")) )) {
                errorMessage = "EROARE: Limita de utilizare (posibil gratuitÄƒ) a API-ului Gemini a fost depÄƒÈ™itÄƒ. ÃŽncearcÄƒ mai tÃ¢rziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety") || error.message.toLowerCase().includes("blocked due to safety_settings"))) {
                errorMessage = "EROARE Gemini: Generarea a fost opritÄƒ (posibil din motive de siguranÈ›Äƒ, conÈ›inut inadecvat, sau alte restricÈ›ii ale modelului). ÃŽncearcÄƒ un prompt diferit sau ajusteazÄƒ setÄƒrile de siguranÈ›Äƒ dacÄƒ ai acces.";
            }  else if (error.toString().toLowerCase().includes("404") && error.toString().toLowerCase().includes("model not found")) {
                 errorMessage = `EROARE Gemini: Modelul specificat (${modelToUse === geminiModelFeedback ? GEMINI_MODEL_NAME_FEEDBACK : GEMINI_MODEL_NAME_CHAT}) nu a fost gÄƒsit sau nu este suportat. VerificÄƒ numele modelului.`;
            }
            return errorMessage;
         }
    }

    async function genereazaSiProceseazaFeedbackAI(rowData, docId) {
      // PÄƒstrÄƒm promptul anterior pentru fiÈ™Äƒ, care era deja detaliat
      const prompt = `
AnalizeazÄƒ Ã®n profunzime aceastÄƒ fiÈ™Äƒ completÄƒ de auto-reflecÈ›ie. Utilizatorul a parcurs un exerciÈ›iu detaliat pentru a-È™i Ã®nÈ›elege o situaÈ›ie specificÄƒ. OferÄƒ feedback psihologic structurat, empatic È™i acÈ›ionabil. RespectÄƒ cu stricteÈ›e formatul È™i ordinea secÈ›iunilor de mai jos, folosind exact prefixele indicate (ex: \`EmpatieIniÈ›ialÄƒ:\`, \`PuncteForteObservate:\`). FoloseÈ™te Markdown pentru formatarea textului Ã®n interiorul fiecÄƒrei secÈ›iuni (ex: \`**Text bold**\`, \`*Text italic*\`, liste cu \`* Element\`).

**Datele Complete din FiÈ™a de ReflecÈ›ie a Utilizatorului:**

**SecÈ›iunea 1: Explorarea SituaÈ›iei È™i a Nevoilor**
*   Care este situaÈ›ia?: ${rowData.situatie || 'N/A'}
*   Ce Ã®mi trece prin minte (gÃ¢nduri automate)?: ${rowData.ganduri || 'N/A'}
*   Cum mÄƒ face acel gÃ¢nd sÄƒ mÄƒ simt (emoÈ›ii)?: ${rowData.emotii || 'N/A'}
*   Ce mod este activ?: ${rowData.mod_activ || 'N/A'}
*   Ce comportament simÈ›i cÄƒ adopÈ›i?: ${rowData.comportament || 'N/A'}
*   Care sunt nevoile tale mai profunde?: ${rowData.nevoi_profunde || 'N/A'}
*   MÄƒ ajutÄƒ comportamentul meu sÄƒ Ã®ndeplinesc aceste nevoi?: ${rowData.ajutor_comportament || 'N/A'}
*   Cum ar gÃ¢ndi È™i cum s-ar comporta Adultul SÄƒnÄƒtos (perspectiva utilizatorului)?: ${rowData.adult_sanatos || 'N/A'}

**SecÈ›iunea 2: Analiza GÃ¢ndurilor È™i a PercepÈ›iilor**
*   Ce mÄƒ face sÄƒ cred cÄƒ gÃ¢ndul automat este adevÄƒrat?: ${rowData.dovezi_adevar || 'N/A'}
*   Ce mÄƒ face sÄƒ cred cÄƒ nu este adevÄƒrat?: ${rowData.dovezi_fals || 'N/A'}
*   ExistÄƒ o explicaÈ›ie alternativÄƒ?: ${rowData.explicatie_alternativa || 'N/A'}
*   Care este cel mai rÄƒu lucru care s-ar putea Ã®ntÃ¢mpla?: ${rowData.scenariu_negativ || 'N/A'}
*   Care este cel mai bun lucru care s-ar putea Ã®ntÃ¢mpla?: ${rowData.scenariu_optimist || 'N/A'}
*   Care este cel mai realist rezultat?: ${rowData.rezultat_realist || 'N/A'}
*   Ce s-ar Ã®ntÃ¢mpla dacÄƒ mi-aÈ™ schimba modul de gÃ¢ndire?: ${rowData.schimbare_gandire || 'N/A'}
*   Ce i-aÈ™ spune unui prieten dacÄƒ ar fi Ã®n aceeaÈ™i situaÈ›ie?: ${rowData.sfat_prieten || 'N/A'}

**SecÈ›iunea 3: ÃŽntrebÄƒri pentru Claritate È™i ReflecÈ›ie SuplimentarÄƒ**
*   VÄƒd doar partea rea a lucrurilor?: ${rowData.partea_rea || 'N/A'}
*   ÃŽmi asum responsabilitatea pentru lucruri care nu au stat Ã®n puterea mea?: ${rowData.responsabilitate || 'N/A'}
*   MÄƒ condamn Ã®n baza unui singur eveniment?: ${rowData.condamnare || 'N/A'}
*   Privesc situaÈ›ia Ã®n termeni extremi (alb/negru)?: ${rowData.termeni_extremi || 'N/A'}
*   Exagerez situaÈ›ia?: ${rowData.exagerare || 'N/A'}
*   ExistÄƒ È™i alÈ›i factori responsabili?: ${rowData.factori_responsabili || 'N/A'}
*   Am sÄƒrit direct la concluzii?: ${rowData.concluzii || 'N/A'}
*   ÃŽmi pun Ã®ntrebÄƒri fÄƒrÄƒ rÄƒspuns?: ${rowData.intrebari_fara_raspuns || 'N/A'}
*   MÄƒ concentrez doar asupra slÄƒbiciunilor mele?: ${rowData.slabiciuni || 'N/A'}
*   MÄƒ zbat prea mult gÃ¢ndind la cum ar trebui sÄƒ fie lucrurile?: ${rowData.cum_ar_trebui || 'N/A'}
*   MÄƒ aÈ™tept sÄƒ fiu perfect?: ${rowData.perfectiune || 'N/A'}

**CERINÈšE PENTRU FEEDBACK-UL AI (foloseÈ™te prefixele EXACT aÈ™a cum sunt scrise È™i formatarea Markdown Ã®n interiorul rÄƒspunsurilor):**

EmpatieIniÈ›ialÄƒ: (1-2 propoziÈ›ii empatice scurte, recunoscÃ¢nd efortul utilizatorului.)

PuncteForteObservate: (IdentificÄƒ 1-2 aspecte pozitive sau de auto-conÈ™tientizare observate Ã®n rÄƒspunsurile utilizatorului.)

TiparePrincipale: (Descrie succint 1-3 tipare de gÃ¢ndire/emoÈ›ionale/comportamentale centrale care reies din fiÈ™Äƒ.)

ConexiuniCheie: (SintetizeazÄƒ legÄƒtura S-G-E-C-N (SituaÈ›ie-GÃ¢nd-EmoÈ›ie-Comportament-Nevoie) specificÄƒ acestei fiÈ™e, bazÃ¢ndu-te pe rÄƒspunsurile la '${rowData.ganduri}', '${rowData.emotii}', '${rowData.comportament}', '${rowData.nevoi_profunde}'.)

DistorsiuniIdentificate: (IdentificÄƒ 2-3 distorsiuni cognitive principale din rÄƒspunsuri. Pentru fiecare:
*   Numele Distorsiunii (ex: \`**Catastrofizare**\`)
*   O scurtÄƒ explicaÈ›ie a distorsiunii (1 propoziÈ›ie).
*   Un exemplu specific din rÄƒspunsurile utilizatorului care ilustreazÄƒ distorsiunea.
*   O Ã®ntrebare de contestare sau reflecÈ›ie pentru acea distorsiune (ex: "*Cum ar arÄƒta o perspectivÄƒ mai echilibratÄƒ asupra X?*").
ListeazÄƒ fiecare distorsiune ca un sub-punct separat.)

SchemeActivate: (SugereazÄƒ 1-2 scheme cognitive maladaptative timpurii care par a fi activate de situaÈ›ia descrisÄƒ (ex: Defectivitate/RuÈ™ine, Abandon, Deprivare EmoÈ›ionalÄƒ etc.). Pentru fiecare:
*   Numele Schemei (ex: \`**Schema de EÈ™ec**\`)
*   O scurtÄƒ descriere a cum se manifestÄƒ Ã®n general acea schemÄƒ (1-2 propoziÈ›ii).
*   Cum ar putea rÄƒspunsurile utilizatorului din aceastÄƒ fiÈ™Äƒ (gÃ¢nduri, emoÈ›ii, comportamente) sÄƒ reflecte activarea acestei scheme?
Fii speculativ È™i empatic, nu conclusiv. PrezintÄƒ ca sub-puncte.)

ModuriImplicate: (SugereazÄƒ pe scurt ce moduri din Terapia Schemelor ar putea fi active sau implicate, pe lÃ¢ngÄƒ cel menÈ›ionat de utilizator, dacÄƒ este cazul. Ex: Copil Vulnerabil, PÄƒrinte Punitiv, Protector DetaÈ™at. Fii concis.)

PerspectivaAdultSÄƒnÄƒtos: (ComenteazÄƒ rÄƒspunsul utilizatorului despre cum ar acÈ›iona Adultul SÄƒnÄƒtos ('${rowData.adult_sanatos}'). Este realist? Compasional? OferÄƒ sugestii pentru a Ã®ntÄƒri È™i mai mult aceastÄƒ perspectivÄƒ, incluzÃ¢nd:
    *   Cum ar putea Adultul SÄƒnÄƒtos sÄƒ interpreteze situaÈ›ia diferit?
    *   Ce gÃ¢nduri alternative ar putea cultiva?
    *   Cum ar gestiona emoÈ›iile Ã®ntr-un mod adaptativ?
    *   Ce comportamente constructive ar adopta pentru a-È™i Ã®mplini nevoile?
    *   Cum ar putea contracara activ schemele sau modurile disfuncÈ›ionale?)

ÃŽntrebareFinalÄƒReflecÈ›ie: (O Ã®ntrebare generalÄƒ, puternicÄƒ È™i deschisÄƒ, care sÄƒ Ã®ncurajeze utilizatorul sÄƒ integreze Ã®nvÄƒÈ›Äƒmintele din aceastÄƒ fiÈ™Äƒ Ã®n viaÈ›a sa de zi cu zi sau sÄƒ reflecteze la un aspect mai larg.)

SugestieMicPas: (O sugestie concretÄƒ, micÄƒ È™i realizabilÄƒ, pentru un pas pe care utilizatorul l-ar putea face Ã®n urmÄƒtoarele zile pentru a exersa o abilitate nouÄƒ, a contesta un gÃ¢nd, sau a acÈ›iona din perspectiva Adultului SÄƒnÄƒtos, bazat pe analiza fiÈ™ei.)

ÃŽncurajareFinalÄƒ: (1-2 propoziÈ›ii de Ã®ncurajare, validare È™i speranÈ›Äƒ.)

RÄƒspunde doar cu textul cerut conform structurii, fÄƒrÄƒ introduceri ("IatÄƒ feedback-ul...") sau concluzii suplimentare ("Sper cÄƒ acest feedback..."), Ã®n afara celor specificate. AsigurÄƒ-te cÄƒ fiecare secÈ›iune Ã®ncepe exact cu prefixul dat (ex: \`EmpatieIniÈ›ialÄƒ:\`).`;

      let feedbackRawText = null; // Vom stoca aici textul brut de la AI
      let modelFolosit = "N/A";

      if (geminiModelFeedback) {
        console.log("Psiho FiÈ™Äƒ: Solicitare feedback de la Gemini...");
        modelFolosit = `Gemini (${GEMINI_MODEL_NAME_FEEDBACK})`;
        feedbackRawText = await callGeminiAPI(prompt, geminiModelFeedback); // callGeminiAPI este funcÈ›ia deja existentÄƒ
      } else {
        console.warn("Psiho FiÈ™Äƒ: Gemini (geminiModelFeedback) nu este configurat. Nu se poate genera feedback AI.");
        // CreÄƒm un obiect de eroare compatibil cu structura de parsare
        return { 
            rawText: "EROARE: Serviciul de feedback AI (Gemini) nu este configurat corect pentru fiÈ™e. VerificÄƒ cheia API.",
            model: "Configurare EronatÄƒ", 
            timestamp: new Date().toISOString(), 
            error: true 
        };
      }

      // Parsarea feedback-ului brut Ã®n obiectul structurat
      const parsedFeedback = { 
        rawText: feedbackRawText, // SalvÄƒm textul brut
        model: modelFolosit, 
        timestamp: new Date().toISOString(), 
        error: false, 
        error_parsing: false 
      };

      if (!feedbackRawText || (typeof feedbackRawText === 'string' && feedbackRawText.toUpperCase().startsWith("EROARE:"))) {
        console.warn(`Psiho FiÈ™Äƒ: Eroare de la ${modelFolosit} la generarea feedback-ului:`, feedbackRawText);
        parsedFeedback.error = true; 
        // CÃ¢mpurile specifice nu vor fi populate dacÄƒ e eroare de la API,
        // dar rawText va conÈ›ine mesajul de eroare.
      } else {
          console.log("Psiho FiÈ™Äƒ: RÄƒspuns brut de la Gemini (feedback):\n---\n" + feedbackRawText + "\n---");
          const feedbackStructure = {
                empatie_initiala: /^EmpatieIniÈ›ialÄƒ:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                puncte_forte: /^PuncteForteObservate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                tipare_principale: /^TiparePrincipale:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                conexiuni_cheie: /^ConexiuniCheie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                distorsiuni_identificate: /^DistorsiuniIdentificate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                scheme_activate: /^SchemeActivate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                moduri_implicate: /^ModuriImplicate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                perspectiva_adult_sanatos: /^PerspectivaAdultSÄƒnÄƒtos:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                intrebare_finala_reflectie: /^ÃŽntrebareFinalÄƒReflecÈ›ie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                sugestie_mic_pas: /^SugestieMicPas:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
                incurajare_finala: /^ÃŽncurajareFinalÄƒ:\s*([\s\S]*?$)/im, // PÃ¢nÄƒ la sfÃ¢rÈ™it
            };
            
            let allParsingOk = true;
            for (const key in feedbackStructure) {
                const match = feedbackRawText.match(feedbackStructure[key]);
                if (match && match[1] && match[1].trim() !== "") {
                     parsedFeedback[key] = match[1].trim();
                } else {
                    console.warn(`Psiho FiÈ™Äƒ: Nu s-a putut extrage sau este gol conÈ›inutul pentru: '${key}'`);
                    parsedFeedback[key] = `(SecÈ›iune neextrasÄƒ sau goalÄƒ din rÄƒspunsul AI: ${key})`; // StocÄƒm un placeholder
                    allParsingOk = false;
                }
            }
            if (!allParsingOk) {
                console.warn("Psiho FiÈ™Äƒ: Cel puÈ›in o secÈ›iune nu a putut fi parsatÄƒ corect. VerificÄƒ formatul rÄƒspunsului AI È™i regex-urile.");
                parsedFeedback.error_parsing = true;
            }
      }


        if (docId) {
            const docRef = doc(db, "raspunsuri", docId);
            try {
                // Vom salva `parsedFeedback` direct Ã®n `feedback_history`.
                // È˜i vom actualiza È™i cÃ¢mpurile individuale, dacÄƒ este necesar pentru compatibilitate
                // sau dacÄƒ `afiseazaIstoricFeedback` nu se bazeazÄƒ exclusiv pe `rawText` din istoric.
                // Ideal, ar trebui sÄƒ ne bazÄƒm doar pe `rawText` din istoric pentru afiÈ™are.
                const updatePayload = { feedback_history: arrayUnion(parsedFeedback) };

                // AdaugÄƒ fiecare cÃ¢mp parsat direct la rÄƒdÄƒcina documentului, prefixat cu 'feedback_'
                // Acest lucru e mai mult pentru compatibilitate cu structura veche,
                // dar cel mai bine ar fi sÄƒ folosim DOAR parsedFeedback din history È™i sÄƒ adaptÄƒm afiÈ™area.
                 Object.keys(parsedFeedback).forEach(key => {
                     if (key !== 'rawText') { // Nu vrem sÄƒ duplicÄƒm rawText la rÄƒdÄƒcinÄƒ
                        updatePayload[`feedback_${key}`] = parsedFeedback[key];
                     }
                 });
                // AdaugÄƒ È™i rawText ca feedback_rawText pentru referinÈ›Äƒ, dacÄƒ doreÈ™ti
                // updatePayload['feedback_rawText'] = parsedFeedback.rawText;


                await updateDoc(docRef, updatePayload);
                console.log(`Psiho FiÈ™Äƒ: Feedback AI (model: ${modelFolosit}) salvat/actualizat pentru fiÈ™a ${docId}`);
            } catch (updateError) {
                console.error(`Psiho FiÈ™Äƒ: Eroare update Firestore feedback pentru fiÈ™a ${docId}:`, updateError);
            }
        }
        return parsedFeedback; // ReturneazÄƒ obiectul parsat complet
    }

    // --- CHAT FUNCTIONALITY ---
    // RÄƒmÃ¢ne Ã®n mare parte la fel ca Ã®nainte, dar cu ajustÄƒri pentru stil È™i gestionare erori Gemini.
    function displayChatMessage(message, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) return; 
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");
        
        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        messageClass.split(' ').forEach(cls => messageElement.classList.add(cls));

        // Folosim textContent pentru siguranÈ›Äƒ È™i pre-wrap pentru formatare
        messageElement.style.whiteSpace = "pre-wrap"; 
        // Parsare Markdown simplÄƒ pentru rÄƒspunsurile AI
        if (role === "AI" && message) {
            let htmlContent = message.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                                   .replace(/__(.*?)__/g, '<strong>$1</strong>')
                                   .replace(/\*(.*?)\*/g, '<em>$1</em>')
                                   .replace(/_(.*?)_/g, '<em>$1</em>')
                                   .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre style="background:#eef; padding:5px; border-radius:4px; white-space:pre-wrap; word-break:break-all;">${p1.trim()}</pre>`)
                                   .replace(/`([^`]+)`/g, '<code style="background:#eef; padding:1px 3px; border-radius:3px;">$1</code>');
             // ÃŽncercare de a formata liste simple
            htmlContent = htmlContent.split('\n').map(line => {
                if (line.match(/^\s*[\*\-\+]\s+/)) {
                    return `<li>${line.replace(/^\s*[\*\-\+]\s+/, '')}</li>`;
                }
                return line;
            }).join('\n');
            if (htmlContent.includes("<li>")) {
                htmlContent = `<ul>${htmlContent.replace(/<li>(.*?)<\/li>(?!\s*<ul)/g, '<li>$1</li>').replace(/\n<\/ul>\n<ul>/g, '')}</ul>`; // EvitÄƒ spargerea listelor
            }

            messageElement.innerHTML = htmlContent.replace(/\n/g, '<br>'); // ÃŽnlocuieÈ™te \n cu <br> la final

        } else {
            messageElement.textContent = message; 
        }


        messagesDiv.appendChild(messageElement);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    async function loadChatHistory(userId) {
        if (!userId) return [];
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists() && docSnap.data().messages && Array.isArray(docSnap.data().messages)) {
                const messages = docSnap.data().messages;
                messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                return messages;
            }
            return []; 
        } catch (error) {
            console.error("Eroare la Ã®ncÄƒrcarea istoricului de chat din Firestore:", error);
            return [];
        }
    }
    
    async function saveChatMessage(userId, messageObject) {
        if (!userId || !messageObject || typeof messageObject.content !== 'string' || messageObject.content.trim() === "") return;
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            await updateDoc(historyDocRef, { messages: arrayUnion(messageObject) }, { merge: true });
        } catch (error) { // Documentul nu existÄƒ, Ã®l creÄƒm
            if (error.code === 'not-found' || error.message.includes("No document to update")) {
                 await setDoc(historyDocRef, { messages: [messageObject] });
            } else {
                console.error("Eroare la salvarea mesajului de chat Ã®n Firestore:", error);
            }
        }
    }
    
    async function initializeAndStartChatSession(userId) {
        const chatStatus = document.getElementById("chatStatus");
        const sendButton = document.getElementById("sendChatMessageButton");
        const messagesDiv = document.getElementById("chatMessages");

        if (sendButton) sendButton.disabled = true;
        if (chatStatus) chatStatus.textContent = "IniÈ›ializare chat AI...";
        if (messagesDiv) messagesDiv.innerHTML = ''; 

        if (!geminiModelChat) {
            if (chatStatus) chatStatus.textContent = "EROARE: Modelul AI Chat nu este disponibil.";
            displayChatMessage("Serviciul de chat AI nu este disponibil momentan. VerificÄƒ cheia API Gemini sau contacteazÄƒ administratorul.", "AI-error");
            return null; 
        }
        
        isChatInitialized = false; 

        let initialContextSummary = "REZUMAT DIN FIÈ˜ELE ANTERIOARE (ULTIMELE 3 COMPLETATE DE UTILIZATOR):\n";
        try {
            if (userId) {
                const q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId), orderBy("date", "desc"), limit(3)); 
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    querySnapshot.forEach(docSnap => {
                        const data = docSnap.data();
                        const entryDate = data.date || (data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleDateString("ro-RO") : 'N/A');
                        initialContextSummary += ` - FiÈ™Äƒ (${entryDate}): Situatia - ${(data.situatie || "").substring(0, 60)}...; Ganduri - ${(data.ganduri || "").substring(0, 60)}...; Emotii - ${data.emotii || 'N/A'}.\n`;
                    });
                } else { initialContextSummary += "Nicio fiÈ™Äƒ de monitorizare recentÄƒ gÄƒsitÄƒ.\n"; }
            }
        } catch(e) { 
            console.error("Eroare la Ã®ncÄƒrcarea contextului din fiÈ™e pentru chat:", e); 
            initialContextSummary += "Eroare la Ã®ncÄƒrcarea contextului din fiÈ™e.\n";
        }

        const systemInstructionText = `# ROL PRINCIPAL È˜I PERSONA:
Tu eÈ™ti PsihoGPT (alias Dr. Elena/Daniel â€“ alege o identitate caldÄƒ È™i profesionalÄƒ). EÈ™ti un asistent AI avansat pentru auto-reflecÈ›ie È™i explorare psihologicÄƒ ghidatÄƒ, specializat Ã®n Terapie Cognitiv-ComportamentalÄƒ (TCC), Terapia Schemelor, Terapia prin Acceptare È™i Angajament (ACT), È™i principii ale Terapiei Dialectic-Comportamentale (DBT). Te adresezi utilizatorului cu "tu", Ã®ntr-un mod respectuos È™i empatic.

# MISIUNE È˜I ABORDARE TERAPEUTICÄ‚:
Misiunea ta este sÄƒ ajuÈ›i utilizatorul sÄƒ exploreze gÃ¢nduri, emoÈ›ii, comportamente È™i nevoi profunde, sÄƒ identifice tipare È™i sÄƒ dezvolte strategii de coping sÄƒnÄƒtoase. Vei ghida utilizatorul sÄƒ:
1.  Identifice È™i sÄƒ Ã®nÈ›eleagÄƒ **Schemele Maladaptative Timpurii** (explicÄƒ pe scurt conceptul la nevoie, È™i dacÄƒ pare relevant din contextul discuÈ›iei sau fiÈ™elor).
2.  Analizeze **Distorsiunile Cognitive** È™i sÄƒ le reformuleze.
3.  Dezvolte abilitÄƒÈ›i de **Reglare EmoÈ›ionalÄƒ** È™i **ToleranÈ›Äƒ la Disconfort**.
4.  Clarifice **Valori Personale** È™i sÄƒ stabileascÄƒ **Obiective SMART** aliniate cu acestea.
5.  ÃŽmbunÄƒtÄƒÈ›eascÄƒ **Stima de Sine** È™i **Auto-Compasiunea** (inspirÄƒ-te din Kristin Neff, BrenÃ© Brown).
6.  Exploreze **RelaÈ›ia cu Sine È™i cu CeilalÈ›i**, inclusiv dinamici de ataÈ™ament È™i limite sÄƒnÄƒtoase.

# PRINCIPII DE INTERACÈšIUNE È˜I COMUNICARE:
1.  **Empatie, CÄƒldurÄƒ È™i Non-JudecatÄƒ:** Prioritatea ta absolutÄƒ. CreeazÄƒ un spaÈ›iu sigur È™i validant.
2.  **Ascultare ActivÄƒ È™i ÃŽntrebÄƒri Deschise:** FormuleazÄƒ Ã®ntrebÄƒri care stimuleazÄƒ reflecÈ›ia profundÄƒ (ex: "Ce anume te face sÄƒ simÈ›i/crezi asta?", "Cum se manifestÄƒ asta Ã®n corpul tÄƒu?", "ExistÄƒ È™i o altÄƒ perspectivÄƒ posibilÄƒ?", "Ce nevoie crezi cÄƒ Ã®ncearcÄƒ sÄƒ Ã®È›i comunice aceastÄƒ emoÈ›ie/situaÈ›ie?").
3.  **Validare EmoÈ›ionalÄƒ:** ValideazÄƒ trÄƒirile utilizatorului Ã®nainte de a explora sau a oferi perspective (ex: "ÃŽnÈ›eleg cÄƒ te simÈ›i copleÈ™it/trist/furios. E firesc sÄƒ simÈ›i aÈ™a Ã®n aceastÄƒ situaÈ›ie.").
4.  **PsihoeducaÈ›ie DozatÄƒ È™i RelevantÄƒ:** DacÄƒ introduci un concept (schemÄƒ, distorsiune), explicÄƒ-l concis È™i verificÄƒ dacÄƒ rezoneazÄƒ cu utilizatorul. FoloseÈ™te metafore simple dacÄƒ e cazul. EvitÄƒ jargonul excesiv.
5.  **Focus pe Resurse È™i Puncte Forte:** AjutÄƒ utilizatorul sÄƒ identifice È™i sÄƒ mobilizeze resursele interioare È™i punctele forte.
6.  **Colaborare È™i Ritm Adaptat:** AdapteazÄƒ-te la ritmul utilizatorului. VerificÄƒ periodic Ã®nÈ›elegerea È™i utilitatea discuÈ›iei ("Cum È›i se pare ce am discutat pÃ¢nÄƒ acum?", "Este acest exerciÈ›iu util pentru tine?").
7.  **Non-Directivitate ResponsabilÄƒ:** NU oferi diagnostice medicale sau psihologice. NU oferi sfaturi directe care Ã®nlocuiesc terapia umanÄƒ. Scopul tÄƒu este auto-reflecÈ›ia ghidatÄƒ.
8.  **Utilizarea Contextului (Discret):** FoloseÈ™te REZUMATUL FIÈ˜ELOR ANTERIOARE È™i istoricul discuÈ›iei curente pentru a Ã®nÈ›elege mai bine. ReferÄƒ-te la ele cu tact ("Am observat cÄƒ Ã®n una din fiÈ™ele tale ai menÈ›ionat X. SimÈ›i cÄƒ existÄƒ o legÄƒturÄƒ cu ce explorÄƒm acum?").
9.  **Concizie È™i Claritate:** RÄƒspunsuri concise (2-5 propoziÈ›ii ideal), cu paragrafe scurte. Un singur "punct" terapeutic per mesaj; aÈ™teaptÄƒ replica. FoloseÈ™te Markdown pentru formatare (bold, italic, liste scurte).
10. **ConfidenÈ›ialitate È™i SiguranÈ›Äƒ:** ReaminteÈ™te discret, dacÄƒ e nevoie, cÄƒ eÈ™ti un AI È™i discuÈ›iile nu Ã®nlocuiesc sfatul unui profesionist uman, È™i cÄƒ datele sunt tratate conform politicilor de confidenÈ›ialitate (fÄƒrÄƒ a intra Ã®n detalii tehnice). DacÄƒ utilizatorul exprimÄƒ gÃ¢nduri de auto-vÄƒtÄƒmare sau vÄƒtÄƒmare a altora, ghideazÄƒ-l ferm È™i empatic cÄƒtre resurse de ajutor specializat (ex: numere de urgenÈ›Äƒ, linii de suport). ACEASTA ESTE O PRIORITATE.

# STRUCTURÄ‚ SUPEVIZATÄ‚ A "È˜EDINÈšEI" DE CHAT (FlexibilÄƒ):
*   **Etapa 1 (Conectare IniÈ›ialÄƒ, ~1-5 replici):** Salut, check-in emoÈ›ional general, stabilirea intenÈ›iei/temei discuÈ›iei.
*   **Etapa 2 (Explorare È™i Lucru Central, ~5-20 replici):** Aprofundarea temei, aplicarea de tehnici (ex: restructurare cognitivÄƒ, exerciÈ›ii de imagerie scurte textuale, explorarea valorilor), generare de insight-uri.
*   **Etapa 3 (Integrare È™i ÃŽncheiere, ~2-5 replici):** Sumarizarea ideilor cheie, identificarea unui mic pas practic pentru sÄƒptÄƒmÃ¢na urmÄƒtoare, validare finalÄƒ, Ã®ncurajare.

Context din ultimele fiÈ™e completate de utilizator (foloseÈ™te-l cu discreÈ›ie È™i inteligenÈ›Äƒ):
${initialContextSummary}---
Acum, Ã®ncepe conversaÈ›ia cu un salut cald È™i o Ã®ntrebare de deschidere.`;

        const aiGreeting = "Salut! Sunt PsihoGPT, asistentul tÄƒu AI pentru reflecÈ›ie È™i explorare interioarÄƒ. Cum te simÈ›i astÄƒzi È™i despre ce È›i-ar plÄƒcea sÄƒ discutÄƒm sau sÄƒ reflectÄƒm Ã®mpreunÄƒ?";

        let historyForGeminiInitialization = [];
        // NU mai trimitem Ã®ntregul systemInstructionText ca prim mesaj, Gemini Ã®l ia din setÄƒrile modelului sau ca `system_instruction` Ã®n request.
        // ÃŽncepem direct cu un salut È™i istoricul real dacÄƒ existÄƒ.
        // historyForGeminiInitialization.push({ role: "user", parts: [{ text: systemInstructionText }] }); 
        // historyForGeminiInitialization.push({ role: "model", parts: [{ text: aiGreeting }] });      

        let loadedHistoryFromDB = await loadChatHistory(userId);
        
        // Construim istoricul pentru API
        loadedHistoryFromDB.forEach(msg => {
            historyForGeminiInitialization.push({
                role: msg.role === "AI" || msg.role === "model" ? "model" : "user", // NormalizÄƒm rolul
                parts: [{ text: msg.content || "" }]
            });
        });
        // DacÄƒ istoricul e gol, adÄƒugÄƒm un prim mesaj model cu salutul.
        // Altfel, AI-ul va continua de unde a rÄƒmas.
        if (historyForGeminiInitialization.length === 0) {
             historyForGeminiInitialization.push({ role: "model", parts: [{text: aiGreeting}] });
        }


        try {
            // Acum, `systemInstructionText` ar trebui ideal pasat la `getGenerativeModel` ca `systemInstruction`
            // Sau ca parte a obiectului `startChat` dacÄƒ API-ul suportÄƒ `system_instruction` acolo.
            // Versiunea actualÄƒ a `GoogleGenerativeAI` SDK (v0.9.0 la momentul scrierii)
            // suportÄƒ `systemInstruction` Ã®n `getGenerativeModel` sau ca prim mesaj Ã®n `history`.
            // Pentru consistenÈ›Äƒ È™i control, trimiterea ca prim mesaj USER pare mai robustÄƒ pe mai multe modele.
            const chatConfig = {
                history: [{ role: "user", parts: [{ text: systemInstructionText }] }, ...historyForGeminiInitialization], // System prompt primul
                generationConfig: { 
                    temperature: 0.75, // Temp mai mare pt creativitate chat
                    // maxOutputTokens: // poate fi setat
                }
            };

            chatSession = geminiModelChat.startChat(chatConfig);
            console.log("Psiho FiÈ™Äƒ: Sesiune chat Gemini iniÈ›ializatÄƒ. Istoric trimis:", chatConfig.history.length, "mesaje.");
            if (chatStatus) chatStatus.textContent = "Chat pregÄƒtit.";
            
            // AfiÈ™Äƒm doar istoricul real din DB, fÄƒrÄƒ system prompt È™i fÄƒrÄƒ a repeta salutul dacÄƒ deja e Ã®n istoric
            if (messagesDiv) messagesDiv.innerHTML = ''; // CurÄƒÈ›Äƒm mesajele vechi din UI
            loadedHistoryFromDB.forEach(msg => {
                 displayChatMessage(msg.content, msg.role === "model" ? "AI" : "user");
            });
            // DacÄƒ istoricul era gol, AI-ul va saluta primul (conform logicii de mai sus)
            // DacÄƒ istoricul nu era gol, nu mai afiÈ™Äƒm salutul extra aici.
            if (loadedHistoryFromDB.length === 0) {
                 displayChatMessage(aiGreeting, "AI"); // AfiÈ™Äƒm salutul dacÄƒ e prima oarÄƒ
                 await saveChatMessage(userId, {role: "model", content: aiGreeting, timestamp: new Date().toISOString() });
            }

            isChatInitialized = true;
            if (sendButton) sendButton.disabled = false;

        } catch(initError) {
            console.error("Psiho FiÈ™Äƒ: Eroare la iniÈ›ializarea sesiunii de chat Gemini:", initError, initError.stack);
            if (chatStatus) chatStatus.textContent = "Eroare AI Chat. ReÃ®ncercaÈ›i.";
            displayChatMessage("A apÄƒrut o problemÄƒ tehnicÄƒ la pornirea chat-ului. VÄƒ rugÄƒm sÄƒ Ã®nchideÈ›i È™i redeschideÈ›i fereastra de chat sau sÄƒ Ã®ncercaÈ›i mai tÃ¢rziu.", "AI-error");
            isChatInitialized = false;
            chatSession = null;
            if (sendButton) sendButton.disabled = true;
            return null;
        }
        return chatSession;
    }

    async function handleSendChatMessage() {
        const chatInput = document.getElementById("chatInput");
        const sendButton = document.getElementById("sendChatMessageButton");
        const chatStatus = document.getElementById("chatStatus");

        if (!chatInput || !sendButton || !chatStatus) return;

        const messageText = chatInput.value.trim();
        if (messageText === "") return;

        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesarÄƒ pentru a folosi chat-ul.");
            window.location.href = "login.html"; return;
        }

        displayChatMessage(messageText, "user");
        const userMessageForDB = { role: "user", content: messageText, timestamp: new Date().toISOString() };
        await saveChatMessage(user.uid, userMessageForDB);
        
        chatInput.value = ""; 
        sendButton.disabled = true;
        chatStatus.textContent = "PsihoGPT analizeazÄƒ...";

        if (!chatSession || !isChatInitialized) {
            console.log("Psiho FiÈ™Äƒ: Sesiunea de chat nu este (re)iniÈ›ializatÄƒ, se Ã®ncearcÄƒ acum...");
            chatSession = await initializeAndStartChatSession(user.uid); 
            if(!chatSession) { 
                chatStatus.textContent = "Eroare chat. ReÃ®ncÄƒrcaÈ›i.";
                sendButton.disabled = true; 
                return; 
            }
        }
        
        try {
            const result = await chatSession.sendMessage(messageText); 
            const response = result.response;
            let aiResponseText = "Nu am putut genera un rÄƒspuns momentan. ÃŽncercaÈ›i din nou.";
            let isBlockedBySafety = false;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                aiResponseText = response.candidates[0].content.parts[0].text;
                 if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Psiho FiÈ™Äƒ: RÄƒspuns Gemini (chat) oprit prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    aiResponseText = `AI-ul a oprit generarea (Motiv: ${response.candidates[0].finishReason}). Este posibil sÄƒ fie din cauza filtrelor de siguranÈ›Äƒ. ÃŽncercaÈ›i sÄƒ reformulaÈ›i.`;
                    isBlockedBySafety = true; // MarcÄƒm ca blocat pentru stilizare
                }
            } else if (response?.promptFeedback?.blockReason) {
                 console.warn("Psiho FiÈ™Äƒ: Prompt blocat (chat):", response.promptFeedback.blockReason, response.promptFeedback.safetyRatings);
                 aiResponseText = `Mesajul tÄƒu sau rÄƒspunsul AI a fost blocat (Motiv: ${response.promptFeedback.blockReason}). RevizuieÈ™te conÈ›inutul sau Ã®ncearcÄƒ o altÄƒ formulare.`;
                 isBlockedBySafety = true;
            }
            
            displayChatMessage(aiResponseText, isBlockedBySafety ? "AI-error" : "AI");

            const aiMessageForDB = { role: "model", content: aiResponseText, timestamp: new Date().toISOString() };
            await saveChatMessage(user.uid, aiMessageForDB);
            chatStatus.textContent = "Chat pregÄƒtit.";

        } catch (error) {
            console.error("Psiho FiÈ™Äƒ: Eroare la trimiterea/procesarea mesajului Gemini (chat):", error, error.stack);
            chatStatus.textContent = "Eroare Ã®n comunicarea cu AI.";
            let displayError = "Ne pare rÄƒu, a apÄƒrut o eroare de comunicare cu asistentul AI. VÄƒ rugÄƒm Ã®ncercaÈ›i din nou.";
             if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429))) {
                 displayError = "Limita de utilizare a serviciului AI a fost atinsÄƒ. VÄƒ rugÄƒm Ã®ncercaÈ›i mai tÃ¢rziu.";
            } else if (error.message && (error.message.toLowerCase().includes("safety") || (error.message.toLowerCase().includes("blocked")) )) {
                 displayError = "Mesajul sau rÄƒspunsul AI a fost blocat, posibil din motive de siguranÈ›Äƒ. ÃŽncercaÈ›i sÄƒ reformulaÈ›i.";
            } else if (error.message && error.message.toLowerCase().includes("api key not valid")){
                displayError = "Cheia API pentru serviciul AI nu este validÄƒ. ContactaÈ›i administratorul."
            }
            displayChatMessage(displayError, "AI-error");
            isChatInitialized = false; 
            chatSession = null;
        } finally {
            if(geminiModelChat && isChatInitialized) { 
                 sendButton.disabled = false;
            } else {
                 sendButton.disabled = true; 
                 chatStatus.textContent = "Chat AI indisponibil.";
            }
            chatInput.focus();
        }
    }

    async function handleToggleChat() {
        const user = auth.currentUser;
        if (!user) { alert("Autentificarea este necesarÄƒ pentru chat."); window.location.href = "login.html"; return; }

        const chatContainer = document.getElementById("chatContainer");
        const toggleButton = document.getElementById("toggleChatButton");
        const sendButton = document.getElementById("sendChatMessageButton");
        if (!chatContainer || !toggleButton) return;

        if (chatContainer.style.display === "none" || chatContainer.style.display === "") {
            chatContainer.style.display = "flex"; 
            toggleButton.innerHTML = "âž–"; // Sau o iconiÈ›Äƒ SVG de Ã®nchidere
            if (!isChatInitialized || !chatSession) { 
                const sessionOK = await initializeAndStartChatSession(user.uid);
                if (sendButton) sendButton.disabled = !sessionOK;
            } else if (sendButton) {
                 sendButton.disabled = !geminiModelChat;
            }
            document.getElementById("chatInput")?.focus();
        } else {
            chatContainer.style.display = "none";
            toggleButton.innerHTML = "ðŸ’¬"; // Sau o iconiÈ›Äƒ SVG de chat
        }
    }

    // --- END CHAT FUNCTIONALITY ---


    async function salveazaRaspunsSiGenereazaFeedback() {
        const form = document.getElementById("exercitiuForm");
        // Validarea formularului
        if (form && !form.checkValidity()) { // VerificÄƒ dacÄƒ 'form' existÄƒ
            form.reportValidity();
            const currentStepElement = document.querySelector('.form-step-active');
            const firstInvalidField = currentStepElement?.querySelector(':invalid:not(fieldset)'); // Exclude fieldset
            if (firstInvalidField) {
                firstInvalidField.focus();
                alert("VÄƒ rugÄƒm completaÈ›i toate cÃ¢mpurile obligatorii din pasul curent Ã®nainte de a salva.");
            } else {
                alert("VÄƒ rugÄƒm completaÈ›i toate cÃ¢mpurile obligatorii.");
            }
            return;
        }


        const rowData = { date: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric'}) }; 
        if (form) { // ColecteazÄƒ datele doar dacÄƒ formularul e prezent
             const formData = new FormData(form);
             formData.forEach((value, key) => { rowData[key] = value.trim(); });
        } else if (document.body.classList.contains("collab-view")) {
            console.warn("TentativÄƒ de salvare Ã®n modul colaborare, unde formularul nu este activ. Se anuleazÄƒ.");
            return; // Nu se salveazÄƒ nimic Ã®n modul colaborare
        } else {
            console.error("Formularul 'exercitiuForm' nu a fost gÄƒsit È™i nu suntem Ã®n modul colaborare.");
            return;
        }


        const user = auth.currentUser;
        if (!user) {
            alert("Trebuie sÄƒ fiÈ›i autentificat pentru a salva datele.");
            window.location.href = "login.html"; return;
        }
        rowData.ownerUid = user.uid;
        rowData.timestamp = Timestamp.fromDate(new Date()); // AdaugÄƒ un timestamp Firebase
        
        const addButton = document.getElementById("addButton");
        let originalAddButtonText = "";
        if(addButton) {
            originalAddButtonText = addButton.textContent;
            addButton.textContent = "Se salveazÄƒ È™i se genereazÄƒ...";
            addButton.disabled = true;
        }
        
        const confirmationMessage = document.getElementById('confirmationMessage');
        if(confirmationMessage) confirmationMessage.style.display = 'none';

        try {
            const docRef = await addDoc(collection(db, "raspunsuri"), rowData);
            rowData.id = docRef.id; 
            console.log(`Psiho FiÈ™Äƒ: RÄƒspuns salvat cu ID: ${docRef.id}. Se genereazÄƒ feedback AI...`);

            if (addButton) addButton.textContent = "Se genereazÄƒ AI..."; // ActualizeazÄƒ textul butonului

            const feedbackGenerat = await genereazaSiProceseazaFeedbackAI(rowData, docRef.id);
            
            const docSnapshot = await getDoc(docRef); // Re-fetch pentru a avea È™i feedback-ul
            if (docSnapshot.exists()) {
                adaugaCard({ id: docSnapshot.id, ...docSnapshot.data() });
            } else { // Fallback dacÄƒ docSnapshot nu e gata imediat (puÈ›in probabil)
                //  rowData are deja feedback-ul ataÈ™at de la genereazaSiProceseazaFeedbackAI Ã®n Firestore
                //  Pentru afiÈ™are imediatÄƒ, ne bazÄƒm pe feedback_history creat
                 rowData.feedback_history = feedbackGenerat && !feedbackGenerat.error ? [feedbackGenerat] : [];
                adaugaCard(rowData);
            }
            
            if (form) { // ReseteazÄƒ formularul doar dacÄƒ existÄƒ
                 form.reset(); 
                 currentStep = 1; 
                 document.querySelectorAll('.form-step').forEach(step => step.classList.remove('form-step-active'));
                 const firstStepEl = document.getElementById('step-1');
                 if(firstStepEl) firstStepEl.classList.add('form-step-active');
                 updateProgressBar();
            }


            if (confirmationMessage) {
                if (feedbackGenerat && !feedbackGenerat.error && !feedbackGenerat.error_parsing) {
                    confirmationMessage.textContent = 'FiÈ™a a fost salvatÄƒ È™i feedback-ul AI generat cu succes! ÃŽl puteÈ›i vedea Ã®n noul card.';
                    confirmationMessage.className = 'confirmation-message success';
                } else if (feedbackGenerat && (feedbackGenerat.error || feedbackGenerat.error_parsing)) {
                     confirmationMessage.textContent = `FiÈ™a a fost salvatÄƒ. Feedback AI: ${feedbackGenerat.rawText || 'A apÄƒrut o problemÄƒ la generarea sau parsarea feedback-ului AI.'}`;
                     confirmationMessage.className = (feedbackGenerat.rawText && feedbackGenerat.rawText.toLowerCase().includes("limit")) ? 'confirmation-message warning' : 'confirmation-message error';
                } else {
                     confirmationMessage.textContent = 'FiÈ™a a fost salvatÄƒ, dar feedback-ul AI nu a putut fi generat sau procesat corect.';
                     confirmationMessage.className = 'confirmation-message error';
                }
                confirmationMessage.style.display = 'block';
                 setTimeout(() => { if(confirmationMessage) confirmationMessage.style.display = 'none'; }, 9000);
            }


        } catch (error) {
            console.error("Psiho FiÈ™Äƒ: Eroare la salvarea Ã®n Firestore sau generarea feedback-ului AI:", error);
            alert("A apÄƒrut o eroare la salvare. VÄƒ rugÄƒm Ã®ncercaÈ›i din nou.");
            if (confirmationMessage) {
                confirmationMessage.textContent = 'Eroare la salvarea fiÈ™ei. ÃŽncercaÈ›i din nou. VerificaÈ›i consola pentru detalii.';
                confirmationMessage.className = 'confirmation-message error';
                confirmationMessage.style.display = 'block';
                setTimeout(() => { if(confirmationMessage) confirmationMessage.style.display = 'none'; }, 7000);
            }
        } finally {
            if(addButton) {
                addButton.textContent = originalAddButtonText;
                addButton.disabled = false;
            }
        }
    }

    // FuncÈ›ia de afiÈ™are istoric adaptatÄƒ din jurnal.html
    function afiseazaIstoricFeedback(containerEl, feedbackHistory) {
        containerEl.innerHTML = ''; 

        if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
            const noHistoryMsg = document.createElement("p");
            noHistoryMsg.textContent = "Niciun feedback AI generat anterior pentru aceastÄƒ fiÈ™Äƒ.";
            noHistoryMsg.className = "no-feedback-message"; 
            containerEl.appendChild(noHistoryMsg);
            return;
        }

        feedbackHistory.slice().reverse().forEach((entry, index) => {
            if (!entry || typeof entry !== 'object') {
                console.warn("Intrare invalidÄƒ Ã®n istoricul de feedback (psihoterapie), va fi ignoratÄƒ:", entry);
                return; 
            }
            const itemContainer = document.createElement("div");
            itemContainer.className = "feedback-entry-card"; 

            const timestampAndModel = document.createElement("p");
            timestampAndModel.className = "feedback-timestamp";
            const modelInfo = entry.model || 'N/A';
            timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp || Date.now()).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - Model: ${modelInfo})`;
            itemContainer.appendChild(timestampAndModel);

            const contentWrapper = document.createElement("div"); 
            contentWrapper.className = "content-ai"; 

            const isCompleteError = entry.error || 
                                    (entry.rawText && typeof entry.rawText === 'string' && entry.rawText.toUpperCase().startsWith("EROARE:"));

            if (isCompleteError) {
                const errorP = document.createElement("p");
                errorP.className = "ai-text-error"; 
                errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
                contentWrapper.appendChild(errorP);
            } else {
                let textToProcess = entry.rawText;
                if (!textToProcess) { 
                    console.warn("Feedback (psihoterapie): 'rawText' lipseÈ™te. Se Ã®ncearcÄƒ reconstruirea.");
                    // ÃŽncercare de a reconstrui din cÃ¢mpurile parsate dacÄƒ rawText lipseÈ™te (pentru compatibilitate)
                    let reconstructedFields = [];
                    const fieldOrder = ["empatie_initiala", "puncte_forte", "tipare_principale", "conexiuni_cheie", "distorsiuni_identificate", "scheme_activate", "moduri_implicate", "perspectiva_adult_sanatos", "intrebare_finala_reflectie", "sugestie_mic_pas", "incurajare_finala", "paragraf", "intrebare", "recomandare", "distorsiuni", "scheme", "adult_sanatos_eval"];
                    fieldOrder.forEach(key => {
                        // VerificÄƒm dacÄƒ `entry[key]` este direct sau `entry['feedback_' + key]` (cum era Ã®nainte)
                        const value = entry[key] || entry[`feedback_${key}`];
                        if (value && typeof value === 'string' && !value.startsWith("(SecÈ›iune neextrasÄƒ")) {
                            const title = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            reconstructedFields.push(`**${title}:**\n${value}`);
                        }
                    });
                    textToProcess = reconstructedFields.join("\n\n") || "ConÈ›inutul detaliat nu este disponibil Ã®n formatul brut (raw).";
                     if (entry.error_parsing) {
                        textToProcess = "AtenÈ›ie: Unele secÈ›iuni din acest feedback AI nu au putut fi parsate corect la generarea iniÈ›ialÄƒ.\n\n" + textToProcess;
                    }
                }
                if (!textToProcess) textToProcess = "ConÈ›inut indisponibil.";

                let finalHtmlElements = []; 
                const lines = textToProcess.split('\n');
                let currentParagraphContent = [];
                let inList = false;
                let currentListElement = null;

                for (const line of lines) {
                    const matchTitle = line.match(/^\s*(?:(\*\*|###|\##|\#)\s*([^#*]+)\s*(?:\1)?\s*)$/);
                    if (matchTitle && matchTitle[2] && matchTitle[2].trim().length > 0) {
                        if (currentParagraphContent.length > 0) { 
                            const p = document.createElement('p'); p.className = 'ai-text-paragraph';
                            let pHtml = currentParagraphContent.join('<br>');
                            pHtml = pHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            pHtml = pHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = pHtml; finalHtmlElements.push(p); currentParagraphContent = [];
                        }
                        if (inList && currentListElement) { finalHtmlElements.push(currentListElement); inList = false; currentListElement = null; }
                        const tMarker = matchTitle[1]; let tLevel = 2;
                        if (tMarker.startsWith('#')) { tLevel = tMarker.length; if (tLevel > 4) tLevel = 4; }
                        const tEl = document.createElement(`h${tLevel}`); tEl.className = 'ai-main-section-title';
                        let tText = matchTitle[2].trim().replace(/\*\*(.*?)\*\*/g, '$1').replace(/__(.*?)__/g, '$1');
                        tEl.textContent = tText; finalHtmlElements.push(tEl); continue;
                    }

                    const matchListItem = line.match(/^\s*([\*\-\+]|\d+\.)\s+(.*)/);
                    if (matchListItem) {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p'); p.className = 'ai-text-paragraph';
                            let pHtml = currentParagraphContent.join('<br>');
                            pHtml = pHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            pHtml = pHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = pHtml; finalHtmlElements.push(p); currentParagraphContent = [];
                        }
                        if (!inList) {
                            inList = true; currentListElement = document.createElement(matchListItem[1].match(/\d+\./) ? 'ol' : 'ul');
                            currentListElement.className = 'ai-list';
                        } else {
                            const newListOrd = !!matchListItem[1].match(/\d+\./);
                            const currListOrd = currentListElement.tagName === 'OL';
                            if (newListOrd !== currListOrd) {
                                finalHtmlElements.push(currentListElement);
                                currentListElement = document.createElement(newListOrd ? 'ol' : 'ul');
                                currentListElement.className = 'ai-list';
                            }
                        }
                        const li = document.createElement('li'); li.className = 'ai-list-item';
                        let iHtml = matchListItem[2];
                        iHtml = iHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                        iHtml = iHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                        li.innerHTML = iHtml; currentListElement.appendChild(li); continue;
                    }
                    if (inList && currentListElement) { finalHtmlElements.push(currentListElement); inList = false; currentListElement = null; }

                    if (line.trim() === "") {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p'); p.className = 'ai-text-paragraph';
                            let pHtml = currentParagraphContent.join('<br>');
                            pHtml = pHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            pHtml = pHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = pHtml; finalHtmlElements.push(p); currentParagraphContent = [];
                        }
                    } else { currentParagraphContent.push(line); }
                }
                if (currentParagraphContent.length > 0) {
                    const p = document.createElement('p'); p.className = 'ai-text-paragraph';
                    let pHtml = currentParagraphContent.join('<br>');
                    pHtml = pHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                    pHtml = pHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                    p.innerHTML = pHtml; finalHtmlElements.push(p);
                }
                if (inList && currentListElement) { finalHtmlElements.push(currentListElement); }
                finalHtmlElements.forEach(el => contentWrapper.appendChild(el));
            }
            itemContainer.appendChild(contentWrapper);
            containerEl.appendChild(itemContainer);
        });
    }

    // ModificatÄƒ pentru stilul nou (rÄƒmÃ¢ne `adaugaCard` specific fiÈ™ierului, dar cu noua structurÄƒ)
    function adaugaCard(rowData) {
        const cardViewContainer = document.getElementById("cardViewContainer");
        let card = cardViewContainer.querySelector(`.response-card[data-id="${rowData.id}"]`);

        const entryDate = rowData.date || (rowData.timestamp?.seconds ? new Date(rowData.timestamp.seconds * 1000).toLocaleDateString("ro-RO", {day: '2-digit', month: '2-digit', year: 'numeric'}) : 'DatÄƒ necunoscutÄƒ');
        const cardTitle = `FiÈ™Äƒ ${entryDate} - ${(rowData.situatie || 'SituaÈ›ie nedefinitÄƒ').substring(0, 45)}...`;

        if (!card) { 
            card = document.createElement("div");
            card.className = "response-card"; // Stil general
            card.setAttribute("data-id", rowData.id);

            let detailsContentHtml = `
                <h4>Explorarea situaÈ›iei È™i a nevoilor</h4>
                <p><strong>Care este situaÈ›ia?</strong> ${rowData.situatie || 'N/A'}</p>
                <p><strong>Ce Ã®mi trece prin minte?</strong> ${rowData.ganduri || 'N/A'}</p>
                <p><strong>Cum mÄƒ face acel gÃ¢nd sÄƒ mÄƒ simt?</strong> ${rowData.emotii || 'N/A'}</p>
                <p><strong>Ce mod este activ?</strong> ${rowData.mod_activ || 'N/A'}</p>
                <p><strong>Ce comportament simÈ›i cÄƒ adopÈ›i?</strong> ${rowData.comportament || 'N/A'}</p>
                <p><strong>Care sunt nevoile tale mai profunde?</strong> ${rowData.nevoi_profunde || 'N/A'}</p>
                <p><strong>MÄƒ ajutÄƒ comportamentul meu sÄƒ Ã®ndeplinesc aceste nevoi?</strong> ${rowData.ajutor_comportament || 'N/A'}</p>
                <p><strong>Cum ar gÃ¢ndi È™i cum s-ar comporta Adultul SÄƒnÄƒtos?</strong> ${rowData.adult_sanatos || 'N/A'}</p>
                <hr>
                <h4>Analiza gÃ¢ndurilor È™i a percepÈ›iilor</h4>
                <p><strong>Ce mÄƒ face sÄƒ cred cÄƒ gÃ¢ndul automat este adevÄƒrat?</strong> ${rowData.dovezi_adevar || 'N/A'}</p>
                <p><strong>Ce mÄƒ face sÄƒ cred cÄƒ nu este adevÄƒrat?</strong> ${rowData.dovezi_fals || 'N/A'}</p>
                <p><strong>ExistÄƒ o explicaÈ›ie alternativÄƒ?</strong> ${rowData.explicatie_alternativa || 'N/A'}</p>
                <p><strong>Care este cel mai rÄƒu lucru care s-ar putea Ã®ntÃ¢mpla?</strong> ${rowData.scenariu_negativ || 'N/A'}</p>
                <p><strong>Care este cel mai bun lucru care s-ar putea Ã®ntÃ¢mpla?</strong> ${rowData.scenariu_optimist || 'N/A'}</p>
                <p><strong>Care este cel mai realist rezultat?</strong> ${rowData.rezultat_realist || 'N/A'}</p>
                <p><strong>Ce s-ar Ã®ntÃ¢mpla dacÄƒ mi-aÈ™ schimba modul de gÃ¢ndire?</strong> ${rowData.schimbare_gandire || 'N/A'}</p>
                <p><strong>Ce i-aÈ™ spune unui prieten dacÄƒ ar fi Ã®n aceeaÈ™i situaÈ›ie?</strong> ${rowData.sfat_prieten || 'N/A'}</p>
                <hr>
                <h4>ÃŽntrebÄƒri pentru claritate È™i reflecÈ›ie suplimentarÄƒ</h4>
                <p><strong>VÄƒd doar partea rea a lucrurilor?</strong> ${rowData.partea_rea || 'N/A'}</p>
                <p><strong>ÃŽmi asum responsabilitatea pentru lucruri care nu au stat Ã®n puterea mea?</strong> ${rowData.responsabilitate || 'N/A'}</p>
                <p><strong>MÄƒ condamn Ã®n baza unui singur eveniment?</strong> ${rowData.condamnare || 'N/A'}</p>
                <p><strong>Privesc situaÈ›ia Ã®n termeni extremi?</strong> ${rowData.termeni_extremi || 'N/A'}</p>
                <p><strong>Exagerez situaÈ›ia?</strong> ${rowData.exagerare || 'N/A'}</p>
                <p><strong>ExistÄƒ È™i alÈ›i factori responsabili?</strong> ${rowData.factori_responsabili || 'N/A'}</p>
                <p><strong>Am sÄƒrit direct la concluzii?</strong> ${rowData.concluzii || 'N/A'}</p>
                <p><strong>ÃŽmi pun Ã®ntrebÄƒri fÄƒrÄƒ rÄƒspuns?</strong> ${rowData.intrebari_fara_raspuns || 'N/A'}</p>
                <p><strong>MÄƒ concentrez doar asupra slÄƒbiciunilor mele?</strong> ${rowData.slabiciuni || 'N/A'}</p>
                <p><strong>MÄƒ zbat prea mult gÃ¢ndind la cum ar trebui sÄƒ fie lucrurile?</strong> ${rowData.cum_ar_trebui || 'N/A'}</p>
                <p><strong>MÄƒ aÈ™tept sÄƒ fiu perfect?</strong> ${rowData.perfectiune || 'N/A'}</p>
            `;

            card.innerHTML = `
                <div class="card-header">
                    <span>${cardTitle}</span>
                    <span class="card-date">${entryDate}</span>
                </div>
                <div class="card-content">
                    <details class="journal-entry-details">
                        <summary>Vezi/Ascunde detaliile fiÈ™ei completate</summary>
                        <div class="journal-entry-content-text">${detailsContentHtml}</div>
                    </details>
                    <h4>Feedback AI <span style="font-weight:300; font-style:italic; font-size:0.85em;">(PsihoGPT)</span></h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                        <button class="regenerate-feedback-button" title="RegenereazÄƒ Feedback AI pentru aceastÄƒ fiÈ™Äƒ">RegenereazÄƒ</button>
                        <button class="delete-last-feedback-button" title="È˜terge Ultimul Feedback AI">È˜terge Ultimul</button>
                        <button class="delete-all-feedback-button" title="È˜terge Tot Istoricul Feedback AI">È˜terge Istoric AI</button>
                        <button class="delete-journal-entry-button" title="È˜terge FiÈ™a CompletÄƒ">È˜terge FiÈ™a</button>
                    </div>
                </div>
            `;

            card.querySelector('.card-header').addEventListener('click', (e) => {
                if (!e.target.closest('button') && !e.target.closest('details')) card.classList.toggle('open');
            });
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); /* logica regenerare dinainte */ });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); /* logica delete ultimul feedback dinainte */ });
            card.querySelector('.delete-all-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); /* logica delete tot istoricul dinainte */ });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeCard(rowData.id, card); });


            const noEntriesMsg = cardViewContainer.querySelector('.no-entries-message');
            if (noEntriesMsg) noEntriesMsg.remove();

            if (cardViewContainer.firstChild && cardViewContainer.firstChild.nodeName !== 'P') {
                cardViewContainer.insertBefore(card, cardViewContainer.firstChild);
            } else {
                if (cardViewContainer.firstChild && cardViewContainer.firstChild.nodeName === 'P') cardViewContainer.innerHTML = '';
                cardViewContainer.appendChild(card);
            }
        } else { 
             card.querySelector('.card-header span:first-child').textContent = cardTitle;
             // ActualizeazÄƒ È™i conÈ›inutul <details> dacÄƒ datele fiÈ™ei s-ar schimba
             // Aceasta e mai complex dacÄƒ structura internÄƒ a detailsContentHtml se schimbÄƒ mult
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) {
           afiseazaIstoricFeedback(feedbackContainer, rowData.feedback_history || []);
        }
    }


    async function loadTableData(userId, collabIdForLoad = null, ownerIdForCollabView = null) {
        const cardViewContainer = document.getElementById("cardViewContainer");
        if ((!userId && !ownerIdForCollabView) || !cardViewContainer) {
            console.warn("loadTableData (fiÈ™Äƒ) apelat fÄƒrÄƒ userId/ownerId sau containerul de carduri nu existÄƒ.");
            if (cardViewContainer) cardViewContainer.innerHTML = '<p class="error-loading-message">Datele nu pot fi Ã®ncÄƒrcate (lipsÄƒ informaÈ›ii utilizator).</p>';
            return;
        }

        if (collabIdForLoad && dataAlreadyLoaded && document.body.classList.contains('collab-view-loaded')) { 
            return;
        }
        
        let loadingMsg = cardViewContainer.querySelector(".loading-message");
        if (!cardViewContainer.querySelector('.response-card') && !cardViewContainer.querySelector('.no-entries-message') && !loadingMsg) {
            loadingMsg = document.createElement("p");
            loadingMsg.className = "loading-message";
            loadingMsg.textContent = collabIdForLoad ? "Se Ã®ncarcÄƒ fiÈ™ele partajate..." : "Se Ã®ncarcÄƒ fiÈ™ele tale...";
            cardViewContainer.innerHTML = ''; // CurÄƒÈ›Äƒ Ã®nainte de a adÄƒuga mesajul de Ã®ncÄƒrcare
            cardViewContainer.appendChild(loadingMsg);
        }


        try {
            let q;
            const collectionRef = collection(db, "raspunsuri");
            if (ownerIdForCollabView) { 
                q = query(collectionRef, where("ownerUid", "==", ownerIdForCollabView), orderBy("timestamp", "desc"));
            } else if (userId) { 
                q = query(collectionRef, where("ownerUid", "==", userId), orderBy("timestamp", "desc"));
            } else { return; }

            const querySnapshot = await getDocs(q);
            if (loadingMsg) loadingMsg.remove();

            const currentCardsMap = new Map();
            cardViewContainer.querySelectorAll('.response-card').forEach(card => currentCardsMap.set(card.dataset.id, card));
            
            const newDocsData = [];
            querySnapshot.forEach((docSnap) => {
                newDocsData.push({ id: docSnap.id, ...docSnap.data() });
                if (currentCardsMap.has(docSnap.id)) currentCardsMap.delete(docSnap.id);
            });
            currentCardsMap.forEach(oldCard => oldCard.remove());
            
            if (newDocsData.length === 0 && !cardViewContainer.querySelector('.response-card')) {
                if (!cardViewContainer.querySelector('.no-entries-message')) {
                    const noEntriesMsg = document.createElement("p");
                    noEntriesMsg.className = "no-entries-message";
                    noEntriesMsg.textContent = collabIdForLoad ? "Nicio fiÈ™Äƒ partajatÄƒ gÄƒsitÄƒ." : "Nicio fiÈ™Äƒ de monitorizare. CompleteazÄƒ una pentru a Ã®ncepe!";
                    cardViewContainer.appendChild(noEntriesMsg);
                }
            } else {
                 const noEntriesMsgIfAny = cardViewContainer.querySelector('.no-entries-message');
                 if (noEntriesMsgIfAny) noEntriesMsgIfAny.remove();
                 newDocsData.forEach(docData => adaugaCard(docData)); // adaugaCard a fost deja actualizatÄƒ
            }

            if (collabIdForLoad) {
                dataAlreadyLoaded = true; 
                document.body.classList.add('collab-view-loaded');
            }

        } catch (error) {
            console.error("Psiho FiÈ™Äƒ: Eroare la Ã®ncÄƒrcarea cardurilor:", error.message, error.stack);
            if (loadingMsg) loadingMsg.remove();
            if(!cardViewContainer.querySelector('.response-card') && !cardViewContainer.querySelector('.error-loading-message')) {
                const errorMsgElement = document.createElement("p");
                errorMsgElement.className = "error-loading-message";
                errorMsgElement.textContent = "Eroare la Ã®ncÄƒrcarea fiÈ™elor. VÄƒ rugÄƒm reÃ®ncÄƒrcaÈ›i pagina.";
                const noEntriesMsg = cardViewContainer.querySelector('.no-entries-message');
                if(noEntriesMsg) noEntriesMsg.remove();
                cardViewContainer.appendChild(errorMsgElement);
            }
        }
    }

    async function stergeCard(id, cardElement) { 
        if (confirm("SunteÈ›i sigur cÄƒ doriÈ›i sÄƒ È™tergeÈ›i aceastÄƒ fiÈ™Äƒ È™i tot feedback-ul AI asociat? AceastÄƒ acÈ›iune este ireversibilÄƒ.")) {
            try {
                await deleteDoc(doc(db, "raspunsuri", id));
                cardElement.remove();
                const container = document.getElementById("cardViewContainer"); // FoloseÈ™te cardViewContainer
                if(container && !container.querySelector('.response-card') && !container.querySelector('.no-entries-message')) {
                    const noEntriesMsg = document.createElement("p");
                    noEntriesMsg.className = "no-entries-message";
                    noEntriesMsg.textContent = "Nicio fiÈ™Äƒ de monitorizare. CompleteazÄƒ una pentru a Ã®ncepe!";
                    container.appendChild(noEntriesMsg);
                }
                console.log(`Psiho FiÈ™Äƒ: FiÈ™a ${id} a fost È™tearsÄƒ.`);
                // Nu mai afiÈ™Äƒm alert, mesajul de confirmare e gestionat Ã®n salveaza...
            } catch (error) {
                console.error("Psiho FiÈ™Äƒ: Eroare la È™tergerea fiÈ™ei:", error);
                alert("Eroare la È™tergerea fiÈ™ei. VerificaÈ›i consola.");
            }
        }
    }

    async function generateCollaborationLink() {
        // ... (Logica generateCollaborationLink rÄƒmÃ¢ne aceeaÈ™i)
         const user = auth.currentUser;
        if (!user) {
            alert("Trebuie sÄƒ fiÈ›i autentificat pentru a genera un link de colaborare.");
            return;
        }
        
        const existingCollabQuery = query(collection(db, "collaborations"), where("owner", "==", user.uid), limit(1)); 
        const querySnapshot = await getDocs(existingCollabQuery);

        let pinCode;
        if (!querySnapshot.empty) {
            const collabDoc = querySnapshot.docs[0];
            const collabLink = `${window.location.origin}${window.location.pathname}?collabId=${collabDoc.id}`;
            const existingPin = collabDoc.data().pin;
            
            const renew = confirm(`Ai deja un link de colaborare activ (PIN: ${existingPin}).\nLink: ${collabLink}\n\nDoreÈ™ti sÄƒ generezi un PIN nou pentru acest link? Anularea va pÄƒstra PIN-ul existent.`);
            if (renew) {
                 pinCode = prompt("IntroduceÈ›i un nou cod PIN numeric (minim 4 cifre):");
                 if (pinCode && /^\d{4,}$/.test(pinCode)) {
                    await updateDoc(doc(db, "collaborations", collabDoc.id), { pin: pinCode, updatedAt: new Date() });
                    prompt(`PIN actualizat! Link-ul de colaborare rÄƒmÃ¢ne acelaÈ™i. Noul PIN este: ${pinCode}.\nLink: ${collabLink}`, `Link: ${collabLink}\nPIN nou: ${pinCode}`);
                 } else if(pinCode !== null) { 
                    alert("Cod PIN invalid. Trebuie sÄƒ fie numeric È™i minim 4 cifre. PIN-ul vechi a fost pÄƒstrat.");
                 }
            } else { 
                 prompt(`Link de colaborare existent (PIN: ${existingPin}). ÃŽl poÈ›i redistribui:\nLink È™i PIN:`, `${collabLink} (PIN: ${existingPin})`);
            }
            return; 
        }

        pinCode = prompt("IntroduceÈ›i un cod PIN numeric (minim 4 cifre) pentru noul link de colaborare:");
        if (!pinCode || !/^\d{4,}$/.test(pinCode)) { 
            alert("Cod PIN invalid. Trebuie sÄƒ fie numeric È™i sÄƒ conÈ›inÄƒ cel puÈ›in 4 cifre.");
            return;
        }
        try {
            const docRef = await addDoc(collection(db, "collaborations"), { 
                owner: user.uid, 
                pin: pinCode, 
                createdAt: Timestamp.fromDate(new Date()) // Folosim Timestamp Firebase
            });
            const collaborationLink = `${window.location.origin}${window.location.pathname}?collabId=${docRef.id}`;
            prompt(`Link de colaborare generat! Distribuie acest link ÃŽMPREUNÄ‚ cu codul PIN.\nLink: ${collaborationLink}\nPIN: ${pinCode}`, `Link: ${collaborationLink} (PIN: ${pinCode})`);
        } catch (error) {
            console.error("Eroare la generarea link-ului de colaborare:", error);
            alert("A apÄƒrut o eroare la generarea linkului.");
        }
    }

    window.addEventListener('DOMContentLoaded', async () => {
        // ... (Logica DOMContentLoaded pentru modul colaborare rÄƒmÃ¢ne aceeaÈ™i)
        console.log("DOMContentLoaded (fiÈ™Äƒ) - Se verificÄƒ pentru modul colaborare.");
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (collabId) {
            dataAlreadyLoaded = false; 
            document.body.classList.add("collab-view"); 
            // Ascunde elementele care nu sunt relevante pentru modul colaborare
            ['exercitiuForm', 'generateLinkButton', '.form-container > h2.main-form-title', '.form-container > p:not(#confirmationMessage)', '.form-container .progress-bar', '.table-container'].forEach(sel => {
                const el = document.querySelector(sel);
                if (el) el.style.display = 'none'; 
            });
            
            const formContainer = document.querySelector('.form-container');
            if (formContainer && !formContainer.querySelector('h2.collab-title')) {
                const collabTitle = document.createElement('h2');
                collabTitle.className = 'collab-title';
                collabTitle.style.textAlign = 'center';
                collabTitle.textContent = 'Vizualizare FiÈ™e Colaborare';
                formContainer.insertBefore(collabTitle, formContainer.firstChild); // AdaugÄƒ titlul la Ã®nceput
            }

            
            setTimeout(async () => { // Mic delay pentru a permite UI-ului sÄƒ se actualizeze
                const pin = prompt("IntroduceÈ›i codul PIN pentru a vizualiza fiÈ™ele de colaborare:");
                if (!pin) {
                    alert("PIN-ul este necesar pentru a continua. VeÈ›i fi redirecÈ›ionat."); window.location.href = "login.html"; return;
                }
                try {
                    const collabDocRef = doc(db, "collaborations", collabId);
                    const collabSnapshot = await getDoc(collabDocRef);
                    if (collabSnapshot.exists()) {
                        const collabData = collabSnapshot.data();
                        if (collabData.pin === pin) {
                            console.log("Psiho FiÈ™Äƒ (Collab): PIN corect. ÃŽncÄƒrcare date pentru owner:", collabData.owner);
                            document.title = "Vizualizare FiÈ™e Partajate - Psiho";
                            const formContainerTitle = document.querySelector('.form-container h2.collab-title');
                            if (formContainerTitle) formContainerTitle.textContent = "FiÈ™e Partajate (Colaborare)";
                            
                            await loadTableData(null, collabId, collabData.owner); 
                        } else {
                            alert("PIN incorect. VeÈ›i fi redirecÈ›ionat."); window.location.href = "login.html";
                        }
                    } else {
                        alert("Link de colaborare invalid sau expirat. VeÈ›i fi redirecÈ›ionat."); window.location.href = "login.html";
                    }
                } catch (error) {
                    console.error("Psiho FiÈ™Äƒ (Collab): Eroare la accesarea datelor de colaborare:", error);
                    alert("Eroare la accesarea datelor de colaborare. VerificaÈ›i link-ul È™i PIN-ul. VeÈ›i fi redirecÈ›ionat."); window.location.href = "login.html";
                }
            }, 100);
        }
    });
    </script>
    <style>
        /* Stilurile pentru FORMULARUL MULTI-STEP (rÄƒmÃ¢n specifice aici) */
        body { /* BazÄƒ Ubuntu, apoi alte fonturi pot suprascrie */
            font-family: 'Ubuntu', 'Roboto', 'Montserrat', 'Nunito Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            margin: 0; padding: 20px; background: #f0f2f5; /* Fundal similar cu jurnal */
            color: #333a40; line-height: 1.6;
        }
        .form-container {
            max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
            /* border: 3px solid #87CEFA; */ /* EliminÄƒm bordura specificÄƒ, lÄƒsÄƒm umbra */
            transition: transform 0.3s ease;
        }
        /* .form-container:hover {transform: scale(1.005);} */ /* Hover subtil */
        
        .progress-bar {width: 100%; background-color: #e9ecef; border-radius: 25px; overflow: hidden; margin-bottom: 25px; height: 12px;}
        .progress {height: 100%; width: 0; background-color: #5c85d6; transition: width 0.4s ease;}

        .question-card { /* Stilizarea cardului individual al Ã®ntrebÄƒrii din formular */
            margin-bottom: 22px; padding: 20px; background: #fdfdff; 
            border-radius: 8px; box-shadow: 0 3px 8px rgba(0,0,0,0.05);
            border: 1px solid #eef2f7;
        }
        .question-card h3 { /* Titlul Ã®ntrebÄƒrii */
            font-weight: 500; font-size: 1.15em; margin-top: 0; margin-bottom: 10px; color: #334155;
            text-align: left; /* Aliniere la stÃ¢nga pentru Ã®ntrebÄƒri */
        }
        .question-card p { /* Descrierea Ã®ntrebÄƒrii */
            font-weight: 400; font-size: 0.95em; margin-bottom: 15px; color: #475569; line-height: 1.65;
            text-align: left;
        }
        .form-container h2.main-form-title { /* Titlul principal al formularului */
             font-size: 1.7em; margin-bottom: 10px; text-align: center; color: #2c3840; font-weight: 500;
        }
         .form-container h2.collab-title {
             font-size: 1.6em; margin-bottom: 20px; text-align: center; color: #2c3840; font-weight: 500;
        }
        .form-container > p:not(#confirmationMessage):not(.loading-message):not(.no-entries-message):not(.error-loading-message) { /* Paragraful descriptiv general */
            text-align: center; margin-top: -5px; margin-bottom: 25px; font-size: 0.95em; color: #556575;
        }


        textarea { 
            width: 100%; /* Ia toatÄƒ lÄƒÈ›imea disponibilÄƒ minus padding/border */
            padding: 12px 15px; font-size: 1em;
            font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
            resize: vertical; min-height: 70px; 
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
        }
        textarea:focus {border-color: #5c85d6; box-shadow: inset 0 1px 2px rgba(0,0,0,0.06), 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;}

        /* Butoanele din formularul multi-step */
        .form-step-active {display: block; animation: fadeInFormStep 0.5s ease-in-out;}
        @keyframes fadeInFormStep { 0% {opacity: 0; transform: translateY(12px);} 100% {opacity: 1; transform: translateY(0);} }
        .form-step {display: none;}
        .step-navigation {text-align: center; margin-top: 25px; display: flex; justify-content: space-between; gap:15px;}
        .step-navigation button, button#addButton { /* Stil comun pentru navigare È™i submit */
            padding: 11px 22px;
            font-family: inherit; font-size: 1em; font-weight: 500; 
            color: white; border: none; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, transform 0.15s ease-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step-navigation button#prevButton { background-color: #6c757d; }
        .step-navigation button#prevButton:hover { background-color: #5a6268; transform: translateY(-1px); }
        .step-navigation button#nextButton { background-color: #5c85d6; }
        .step-navigation button#nextButton:hover { background-color: #4a6fb5; transform: translateY(-1px); }
        
        button#addButton { background-color: #28a745; display:block; width:100%; margin-top:20px; font-size: 1.05em;}
        button#addButton:hover:not(:disabled) { background-color: #218838; transform: translateY(-1px); }
        .step-navigation button:disabled, button#addButton:disabled { 
            background: #b0c4de !important; color: #707c8b !important; 
            cursor: not-allowed !important; box-shadow: none !important; transform: translateY(0) !important;
        }


        /* Unificarea Stilurilor pentru Mesaje de Confirmare È™i Stare (preluate din jurnal.html) */
        .confirmation-message, 
        .no-entries-message, .loading-message, .error-loading-message { 
            text-align: center; margin-top:20px; font-style: italic; 
            color: #556575; font-size: 1em; padding:12px;
            border-radius: 6px; 
        }
        .confirmation-message { font-style: normal; font-weight:500; animation: fadeIn 0.4s; display:none;}
        .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border:1px solid #b3d9c0; }
        .confirmation-message.error   { background-color: #fdecea; color: #b32d21; border:1px solid #f8c6c1; }
        .confirmation-message.warning { background-color: #fff8e1; color: #795508; border:1px solid #ffecb3; }
        .error-loading-message        { color: #c0392b; font-weight: 500; background-color: #fdecea; border:1px solid #f8c6c1;}
        .loading-message              { background-color: #e9f0ff; border:1px solid #d1dfff;}
        @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }

        /* === STILURI PENTRU CARDURI È˜I FEEDBACK AI (preluate din jurnal.html) === */
        h3#cardViewTitle { /* Titlul de deasupra cardurilor */
            color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
            font-size: 1.4em; margin-top: 40px; 
        }
        .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
        .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
        .response-card .card-header {
            font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
            padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
            display: flex; justify-content: space-between; align-items: center;
        }
        .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap; font-weight: 400;}

        .response-card .card-header::after {content: 'â–¼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
        .response-card.open .card-header::after {transform: rotate(180deg);}
        .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
        .response-card.open .card-content { max-height: 8000px; /* Generos pentru fiÈ™e lungi */ padding: 20px 20px; }
        
        .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
        .journal-entry-details summary { 
            cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
            background-color: #f8f9fa; border-radius: 6px 6px 0 0; 
            list-style-position: inside; 
        }
        .journal-entry-details summary:hover { background-color: #f1f3f6; }
        .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
        .journal-entry-content-text { /* Acum stilizeazÄƒ div-ul care conÈ›ine P-urile fiÈ™ei */
            padding: 12px; font-size: 0.95em; line-height: 1.65; color: #3e4c59; 
            max-height: 450px; overflow-y: auto;
        }
        .journal-entry-content-text hr {margin: 15px 0; border: 0; border-top: 1px dashed #dde2e7;}
        .journal-entry-content-text h4 { /* Stil pentru subtitlurile din conÈ›inutul fiÈ™ei */
             font-size: 1.05em; color: #5c85d6; margin-top: 15px; margin-bottom:8px; font-weight: 500;
        }
        .journal-entry-content-text p { 
            margin-bottom: 10px;
        }
        .journal-entry-content-text p strong {
            font-weight: 500; color: #1e293b; margin-right: 5px;
        }
        .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
        .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }

        .response-card > .card-content > h4 { /* Titlul pentru "Feedback AI" */
            color: #5c85d6; font-weight: 500; margin-top: 0px; /* Ajustat cÄƒ acum e primul dupÄƒ details */
            margin-bottom: 15px; font-size: 1.1em; /* PuÈ›in mai mare */
            border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
        }

        .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }

        .ai-feedback-history-container { margin-top: 10px; }
        .feedback-entry-card { 
            background:#fdfdff; padding: 15px; 
            border: 1px solid #e7ecf2;
            border-left: 4px solid #5c85d6; 
            border-radius:8px; margin-bottom:15px; 
            font-size:0.95em; line-height:1.6;
            box-shadow: 0 2px 5px rgba(0,0,0,0.03);
        }
        .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
        
        .card-actions { 
            text-align: right; margin-top: 20px; padding-top: 15px; 
            border-top: 1px solid #eef2f7; 
            display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
        }
        .card-actions button {
            padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
            transition: all 0.2s; border: 1px solid transparent; cursor: pointer;
        }
        button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
        button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
        button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
        button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
        button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
        button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
        button.delete-all-feedback-button { background-color:transparent; color: #9b2c2c; border-color: #fed7d7;} 
        button.delete-all-feedback-button:hover { background-color: #9b2c2c; color: white;}

        .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
        .content-ai .ai-main-section-title, 
        .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 { 
            font-weight: 600; color: #3b74d7; 
            margin-top: 1.2em; margin-bottom: 0.6em; font-size: 1.05em; 
            padding-bottom: 4px;
        }
        .content-ai .ai-main-section-title:first-child, 
        .content-ai h1:first-child, .content-ai h2:first-child, 
        .content-ai h3:first-child, .content-ai h4:first-child { margin-top: 0.3em; }
        .content-ai p.ai-text-paragraph { margin-bottom: 0.9em; }
        .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; } 
        .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; } 
        .content-ai ul.ai-list, .content-ai ol.ai-list {
            margin-left: 5px; padding-left: 22px; margin-bottom: 0.9em; list-style-position: outside;
        }
        .content-ai .ai-list-item { margin-bottom: 0.5em; }
        .content-ai .ai-list-item::marker { color: #4a69bd; font-weight: bold; } 
        .content-ai .ai-text-error {
            color: #c0392b; font-weight: 500; background-color: #fff5f5; 
            padding: 10px 12px; border-radius: 4px; border: 1px solid #fecaca; border-left: 4px solid #ef4444;
            white-space: pre-wrap; font-size: 0.9em;
        }
        /* --- SFÃ‚RÈ˜IT STILURI CARDURI È˜I FEEDBACK --- */

        /* --- STILURI CHAT (preluate dinainte, verificate pt Ubuntu) --- */
        .chat-container {
            display: none; /* IniÈ›ial ascuns, afiÈ™at de JS */
            flex-direction: column; position: fixed; bottom: 20px; right: 20px;
            width: clamp(350px, 40vw, 450px); max-height: calc(100vh - 90px); /* Redus puÈ›in max-height */
            background: #ffffff; border-radius: 16px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 1000; padding: 0; box-sizing: border-box; overflow: hidden;
            font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        }
        .chat-container h3 { /* Titlul chatului */
            text-align: center; color: #334155; margin: 0; padding: 16px 20px;
            font-size: 1.1em; font-weight: 500; background-color: #f8f9fc;
            border-bottom: 1px solid #e9edf2; flex-shrink: 0;
        }
        #chatMessages {
            flex-grow: 1; overflow-y: auto; padding: 18px; background: #ffffff;
            display: flex; flex-direction: column; gap: 12px;
        }
        #chatMessages::-webkit-scrollbar { width: 6px; }
        #chatMessages::-webkit-scrollbar-track { background: #f0f2f5; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb { background: #bfc8d3; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb:hover { background: #a8b3bf; }
        .chat-message {
            padding: 11px 16px; border-radius: 18px; max-width: 83%;
            word-wrap: break-word; line-height: 1.55;
            box-shadow: 0 2px 5px rgba(0,0,0,0.06);
            font-size: 0.96em; font-weight: 400; position: relative;
        }
        .user-message {
            background: linear-gradient(135deg, #5c85d6 0%, #3b6cb7 100%); /* Adaptat la culoarea principalÄƒ */
            color: white; align-self: flex-end; margin-left: auto;
            border-bottom-right-radius: 6px; 
        }
        .ai-message {
            background: #f0f3f7; color: #2c3e50; align-self: flex-start;
            margin-right: auto; border-bottom-left-radius: 6px;
            font-family: 'Ubuntu', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace; /* Fallback pt code */
        }
         .ai-message em, .ai-message i { font-family: 'Ubuntu', inherit; font-style: italic; font-weight: 400; }
         .ai-message strong, .ai-message b { font-family: 'Ubuntu', inherit; font-weight: 700; }
        .ai-message.ai-error {
            background-color: #ffe3e3; color: #b71c1c; border: 1px solid #ffc5c5;
            font-family: 'Ubuntu', sans-serif; /* ForÈ›Äƒm fontul normal pt erori */
        }
        .chat-input-area {
            padding: 15px 20px; border-top: 1px solid #e9edf2;
            background-color: #f8f9fc; flex-shrink: 0;
            display: flex; flex-direction: column; gap: 10px;
        }
        #chatInput { /* Textarea din chat */
            width: 100%; padding: 11px 16px; border-radius: 10px;
            border: 1px solid #d9e0ea; resize: none; min-height: 46px; max-height: 120px;
            box-sizing: border-box; font-family: 'Ubuntu', sans-serif;
            font-size: 0.96em; font-weight: 400; line-height: 1.5;
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #ffffff;
        }
        #chatInput:focus {
            border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.18);
            outline: none;
        }
        #sendChatMessageButton { /* Butonul din chat */
            padding: 11px 20px; width: 100%;
            font-family: 'Ubuntu', sans-serif; font-size: 1em; font-weight: 500; 
            background-color: #5c85d6; color: white; border: none;
            border-radius: 10px; transition: background-color 0.2s, transform 0.15s ease-out;
            cursor: pointer; margin-top:0; /* Suprascrie margin-top de la butoanele generale */
        }
        #sendChatMessageButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); }
        #sendChatMessageButton:disabled { background-color: #c3d9f0 !important; color: #7c8da3 !important; transform: translateY(0) !important;}
        #chatStatus {
            font-size: 0.85em; color: #6c757d; text-align: center;
            min-height: 1.2em; padding-bottom: 0; flex-shrink: 0; font-weight: 400;
        }
        #toggleChatButton { /* Butonul plutitor de chat */
            position: fixed; bottom: 25px; right: 25px; padding: 0; z-index: 1001;
            display: flex; /* AfiÈ™at de JS */ align-items: center; justify-content: center;
            background-color: #5c85d6; color: white; border: none; border-radius: 50%;
            width: 58px; height: 58px; font-size: 26px; 
            box-shadow: 0 5px 15px rgba(92, 133, 214, 0.25);
            cursor: pointer; transition: all 0.3s ease;
        }
        #toggleChatButton:hover { background-color: #4a6fb5; transform: scale(1.1) rotate(10deg); box-shadow: 0 7px 20px rgba(74, 107, 181, 0.35); }
        /* --- SFÃ‚RÈ˜IT STILURI CHAT --- */


        /* Stiluri generale pentru Responsive */
        @media (max-width: 820px) { /* Breakpoint adÄƒugat pentru .form-container È™i .card-view */
             .form-container, .card-view {padding:20px; margin-left:15px; margin-right:15px; max-width:calc(100% - 30px);}
        }

        @media (max-width: 768px) {
            body {padding:15px; font-size: 15px;}
            .form-container, .card-view {padding:20px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);}
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.5em;} 
            h3#cardViewTitle {font-size: 1.25em;}
            .step-navigation button, button#addButton {font-size:0.95em; padding:10px 18px;} 
            .card-actions button {font-size:0.78em; padding:7px 10px; flex-basis:auto;}
            .response-card .card-header {font-size:1.05em;}
            .question-card h3 {font-size:1.1em;}
            .question-card p {font-size:0.92em;}
            .journal-entry-content-text { font-size: 0.92em;}
            
            /* Responsive Chat */
            .chat-container { 
                width: calc(100% - 30px); max-height: calc(100vh - 100px); 
                bottom: 15px; left: 15px; right: auto; /* Aliniere la stÃ¢nga pe mobil */
                border-radius: 12px; 
            }
            .chat-container h3 { padding: 14px 15px; font-size: 1.05em; }
            #chatMessages { padding: 15px; gap: 10px; } 
            .chat-message { padding: 10px 14px; font-size: 0.92em; max-width: 88%; border-radius: 16px; }
            #toggleChatButton { width: 55px; height: 55px; font-size: 24px; bottom: 20px; right: 20px;}
            .chat-input-area { padding: 12px 15px; gap: 8px; }
            #chatInput { padding: 10px 14px; font-size: 0.92em; min-height: 44px; border-radius: 10px; }
            #sendChatMessageButton { padding: 10px 15px; font-size: 0.95em; border-radius: 10px; }
        }
        @media (max-width: 480px) {
            body {padding:10px; font-size: 14px;}
            .form-container, .card-view {padding:12px; margin-left:5px; margin-right:5px; max-width:calc(100% - 10px);}
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.35em;} h3#cardViewTitle {font-size: 1.2em;}
            .question-card h3, .response-card .card-header {font-size:1em;}
            .question-card p {font-size:0.9em;}
            .journal-entry-content-text { font-size: 0.9em;}
            textarea {font-size:0.95em; padding:10px; min-height: 60px;}
            .step-navigation button, button#addButton {font-size:0.9em; padding:9px 15px;}
            .card-actions button {font-size:0.75em; padding:6px 8px; flex-basis: calc(50% - 5px);}
            .response-card .card-header {padding:12px 15px; flex-direction: column; align-items: flex-start; gap: 4px;}
            .response-card .card-header::after { align-self: flex-end; margin-top: -1.3em; } /* Ajustare pentru iconiÈ›a expand */

            /* Responsive Chat */
            .chat-container { max-height: calc(100vh - 80px); bottom: 10px; left: 10px; width: calc(100% - 20px); border-radius: 10px; }
            .chat-container h3 { font-size: 1em; padding: 12px 15px; }
            #chatMessages { padding: 12px; gap: 8px; }
            .chat-message { font-size: 0.9em; padding: 9px 12px; border-radius: 14px; }
            .chat-input-area { padding: 10px 12px; gap: 8px;}
            #chatInput {font-size: 0.9em; min-height: 42px; padding: 9px 12px; border-radius: 8px;}
            #sendChatMessageButton {font-size: 0.9em; padding: 9px 12px; border-radius: 8px;}
            #toggleChatButton { width: 50px; height: 50px; font-size: 22px; bottom: 15px; right: 15px; }
        }

    </style>
</head>
<body>

    <div class="form-container">
        <h2 class="main-form-title">FiÈ™Äƒ de Monitorizare EmoÈ›ionalÄƒ È™i CognitivÄƒ</h2>
        <p>CompleteazÄƒ fiecare Ã®ntrebare pentru a explora Ã®n profunzime situaÈ›iile È™i reacÈ›iile tale. Acest exerciÈ›iu te ghideazÄƒ pas cu pas pentru a cÃ¢È™tiga claritate È™i a dezvolta noi perspective.</p>
    
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    
        <form id="exercitiuForm" novalidate>
            <!-- PASUL 1: Explorarea SituaÈ›iei È™i a Nevoilor -->
            <fieldset class="form-step form-step-active" id="step-1">
                 <legend class="sr-only">Pasul 1: Explorarea SituaÈ›iei È™i a Nevoilor</legend> <!-- Pentru accesibilitate -->
                <div class="question-card">
                    <h3>Care este situaÈ›ia?</h3>
                    <p>Descrie contextul specific care a declanÈ™at emoÈ›iile sau comportamentul. Fii cÃ¢t mai detaliat. (ex: o discuÈ›ie, un eveniment, un gÃ¢nd recurent)</p>
                    <textarea name="situatie" rows="3" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>Ce Ã®mi trece prin minte (gÃ¢nduri automate)?</h3>
                    <p>IdentificÄƒ gÃ¢ndurile rapide, involuntare, care au apÄƒrut. Ce È›i-ai spus Ã®n acel moment? Au fost critice, Ã®ngrijorÄƒtoare, anticipative?</p>
                    <textarea name="ganduri" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Cum mÄƒ face acel gÃ¢nd sÄƒ mÄƒ simt (emoÈ›ii)?</h3>
                    <p>NoteazÄƒ emoÈ›iile principale resimÈ›ite (ex: fricÄƒ, tristeÈ›e, furie, ruÈ™ine, vinovÄƒÈ›ie, bucurie etc.). PoÈ›i estima intensitatea pe o scalÄƒ de la 0 la 10.</p>
                    <textarea name="emotii" rows="3" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>Ce "mod" simÈ›i cÄƒ este activ?</h3>
                    <p>Din perspectiva Terapiei Schemelor, ce parte din tine pare sÄƒ fie la conducere? (ex: Copil Vulnerabil, Critic Punitiv, Protector DetaÈ™at, Adult SÄƒnÄƒtos etc.)</p>
                    <textarea name="mod_activ" rows="3" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>Ce comportament simÈ›i cÄƒ adopÈ›i (sau ai tendinÈ›a sÄƒ adopÈ›i)?</h3>
                    <p>Descrie acÈ›iunile concrete sau impulsurile comportamentale. (ex: evitare, retragere, confruntare, ruminaÈ›ie, cÄƒutarea reasigurÄƒrii, auto-liniÈ™tire etc.)</p>
                    <textarea name="comportament" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Care sunt nevoile tale mai profunde Ã®n aceastÄƒ situaÈ›ie?</h3>
                    <p>Ce nevoi emoÈ›ionale fundamentale par a fi neÃ®mplinite sau ameninÈ›ate? (ex: siguranÈ›Äƒ, validare, acceptare, conectare, autonomie, competenÈ›Äƒ)</p>
                    <textarea name="nevoi_profunde" rows="3" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>Comportamentul tÄƒu actual te ajutÄƒ sÄƒ Ã®ndeplineÈ™ti aceste nevoi pe termen lung?</h3>
                    <p>ReflecteazÄƒ sincer la eficacitatea pe termen lung a comportamentului tÄƒu Ã®n satisfacerea nevoilor identificate.</p>
                    <textarea name="ajutor_comportament" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Cum ar gÃ¢ndi, simÈ›i È™i s-ar comporta Adultul tÄƒu SÄƒnÄƒtos Ã®n aceastÄƒ situaÈ›ie?</h3>
                    <p>ImagineazÄƒ-È›i perspectiva ta cea mai Ã®nÈ›eleaptÄƒ, echilibratÄƒ È™i plinÄƒ de compasiune. Ce ar face diferit pentru a-È›i Ã®ndeplini nevoile Ã®ntr-un mod constructiv?</p>
                    <textarea name="adult_sanatos" rows="3" required></textarea>
                </div>
            </fieldset>

            <!-- PASUL 2: Analiza GÃ¢ndurilor È™i a PercepÈ›iilor -->
            <fieldset class="form-step" id="step-2">
                <legend class="sr-only">Pasul 2: Analiza GÃ¢ndurilor È™i a PercepÈ›iilor</legend>
                <div class="question-card">
                    <h3>Ce dovezi susÈ›in gÃ¢ndul tÄƒu automat principal (cÄƒ este adevÄƒrat)?</h3>
                    <p>ListeazÄƒ fapte concrete sau experienÈ›e care par sÄƒ confirme validitatea gÃ¢ndului tÄƒu iniÈ›ial.</p>
                    <textarea name="dovezi_adevar" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Ce dovezi contrazic gÃ¢ndul tÄƒu automat principal (cÄƒ nu este complet adevÄƒrat sau existÄƒ È™i alte aspecte)?</h3>
                    <p>CautÄƒ fapte, experienÈ›e sau perspective alternative care pun la Ã®ndoialÄƒ acurateÈ›ea absolutÄƒ a gÃ¢ndului tÄƒu.</p>
                    <textarea name="dovezi_fals" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>ExistÄƒ o explicaÈ›ie alternativÄƒ, mai echilibratÄƒ sau mai utilÄƒ, pentru situaÈ›ie?</h3>
                    <p>PoÈ›i reinterpreta situaÈ›ia Ã®ntr-un mod care sÄƒ fie mai puÈ›in negativ È™i mai constructiv? Aceasta este o reÃ®ncadrare (reframing).</p>
                    <textarea name="explicatie_alternativa" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Care este cel mai rÄƒu lucru care s-ar putea Ã®ntÃ¢mpla Ã®n mod realist? È˜i cÃ¢t de probabil este (0-100%)?</h3>
                    <p>ExploreazÄƒ scenariul cel mai negativ, dar Ã®ncearcÄƒ sÄƒ-l ancorezi Ã®n realitate È™i sÄƒ-i estimezi probabilitatea.</p>
                    <textarea name="scenariu_negativ" rows="3" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>Care este cel mai bun lucru care s-ar putea Ã®ntÃ¢mpla? È˜i cÃ¢t de probabil este?</h3>
                    <p>ContrabalanseazÄƒ explorÃ¢nd scenariul cel mai pozitiv È™i probabilitatea sa.</p>
                    <textarea name="scenariu_optimist" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Care este cel mai realist rezultat, luÃ¢nd Ã®n considerare toate perspectivele?</h3>
                    <p>ÃŽncearcÄƒ sÄƒ sintetizezi o viziune echilibratÄƒ asupra a ceea ce este cel mai probabil sÄƒ se Ã®ntÃ¢mple.</p>
                    <textarea name="rezultat_realist" rows="3" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Ce efect ar avea asupra ta (emoÈ›ii, comportament) dacÄƒ ai adopta o gÃ¢ndire mai echilibratÄƒ sau explicaÈ›ia alternativÄƒ?</h3>
                    <p>ImagineazÄƒ-È›i impactul schimbÄƒrii de perspectivÄƒ asupra stÄƒrii tale interioare È™i a acÈ›iunilor tale.</p>
                    <textarea name="schimbare_gandire" rows="3" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>Ce sfat i-ai oferi unui prieten drag aflat exact Ã®n aceeaÈ™i situaÈ›ie, cu aceleaÈ™i gÃ¢nduri È™i emoÈ›ii?</h3>
                    <p>Adesea suntem mai blÃ¢nzi È™i mai Ã®nÈ›elepÈ›i cu ceilalÈ›i. Ce perspectivÄƒ plinÄƒ de compasiune i-ai oferi?</p>
                    <textarea name="sfat_prieten" rows="3" required></textarea>
                </div>
            </fieldset>

            <!-- PASUL 3: ÃŽntrebÄƒri pentru Claritate È™i ReflecÈ›ie SuplimentarÄƒ (Detectarea Distorsiunilor) -->
            <fieldset class="form-step" id="step-3">
                <legend class="sr-only">Pasul 3: ÃŽntrebÄƒri pentru Claritate È™i Detectarea Distorsiunilor</legend>
                <div class="question-card">
                    <h3>VÄƒd doar partea rea a lucrurilor, ignorÃ¢nd aspectele pozitive sau neutre (Filtrare mentalÄƒ)?</h3>
                    <textarea name="partea_rea" rows="2" required></textarea>
                </div>
                <div class="question-card">
                    <h3>ÃŽmi asum responsabilitatea excesivÄƒ pentru lucruri care nu au stat (complet) Ã®n puterea mea (Personalizare)?</h3>
                    <textarea name="responsabilitate" rows="2" required></textarea>
                </div>
                <div class="question-card">
                    <h3>MÄƒ etichetez negativ pe mine sau pe alÈ›ii pe baza unui singur eveniment sau aspect (Etichetare)?</h3>
                    <textarea name="condamnare" rows="2" required></textarea> <!-- Am pÄƒstrat "condamnare" din structura ta, dar "etichetare" e termenul tehnic -->
                </div>
                <div class="question-card">
                    <h3>Privesc situaÈ›ia Ã®n termeni extremi, de tip "totul sau nimic", "alb sau negru" (GÃ¢ndire dihotomicÄƒ)?</h3>
                    <textarea name="termeni_extremi" rows="2" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Exagerez importanÈ›a negativelor È™i minimizez pozitivele (Maximizare/Minimizare sau Catastrofizare)?</h3>
                    <textarea name="exagerare" rows="2" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>Atribui cauza problemelor exclusiv altor factori externi, fÄƒrÄƒ a considera rolul meu (Externalizare)? Sau invers?</h3>
                    <p>Este important sÄƒ vedem rolul nostru, dar È™i al contextului. ExistÄƒ È™i alÈ›i factori contribuitori?</p>
                    <textarea name="factori_responsabili" rows="2" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Am sÄƒrit la concluzii negative fÄƒrÄƒ suficiente dovezi (InferenÈ›e arbitrare / Citirea gÃ¢ndurilor / Ghicirea viitorului)?</h3>
                    <textarea name="concluzii" rows="2" required></textarea>
                </div>
                <div class="question-card">
                    <h3>Folosesc des expresii de tip "ar trebui", "trebuie neapÄƒrat", impunÃ¢ndu-mi standarde rigide (Imperative categorice)?</h3>
                    <p>Aceste "legi" interne pot genera multÄƒ presiune È™i vinovÄƒÈ›ie.</p>
                    <textarea name="cum_ar_trebui" rows="2" required></textarea> <!-- Combinat cu "Ã®ntrebÄƒri fÄƒrÄƒ rÄƒspuns" -->
                </div>
                 <div class="question-card">
                    <h3>MÄƒ concentrez predominant asupra slÄƒbiciunilor mele, ignorÃ¢nd sau subestimÃ¢nd punctele forte?</h3>
                     <textarea name="slabiciuni" rows="2" required></textarea>
                </div>
                 <div class="question-card">
                    <h3>MÄƒ aÈ™tept sÄƒ fiu perfect(Äƒ) sau sÄƒ performez impecabil Ã®n majoritatea timpului (PerfecÈ›ionism)?</h3>
                    <textarea name="perfectiune" rows="2" required></textarea>
                </div>
                 <div class="question-card" style="display:none;"> <!-- ÃŽntrebare ascunsÄƒ, poate fi eliminatÄƒ -->
                    <h3>ÃŽmi pun Ã®ntrebÄƒri fÄƒrÄƒ rÄƒspuns?</h3>
                    <textarea name="intrebari_fara_raspuns" rows="1">N/A</textarea>
                </div>
            </fieldset>
            
            <!-- PASUL 4: Finalizare -->
            <fieldset class="form-step" id="step-4">
                <legend class="sr-only">Pasul 4: Finalizare</legend>
                 <div class="question-card">
                    <h3>Completare finalizatÄƒ!</h3>
                    <p>FelicitÄƒri pentru parcurgerea acestui exerciÈ›iu de auto-reflecÈ›ie! Ai fÄƒcut un pas important cÄƒtre o mai bunÄƒ Ã®nÈ›elegere de sine.</p>
                    <p>ApasÄƒ butonul de mai jos pentru a salva datele È™i a solicita un feedback personalizat de la asistentul AI, PsihoGPT. Acest feedback te poate ajuta sÄƒ obÈ›ii noi perspective È™i sÄƒ identifici direcÈ›ii de creÈ™tere.</p>
                    <p style="font-size:0.85em; color:#6c757d;"><em>NotÄƒ: DacÄƒ Ã®ntÃ¢mpini probleme la generarea feedback-ului AI (ex: erori de limitÄƒ de utilizare, cheie API invalidÄƒ), poÈ›i Ã®ncerca din nou mai tÃ¢rziu sau sÄƒ verifici setÄƒrile. FuncÈ›ionalitatea AI depinde de configurarea corectÄƒ a serviciului Gemini.</em></p>
                </div>
            </fieldset>


            <div class="step-navigation">
                <button type="button" id="prevButton">ÃŽnapoi</button>
                <button type="button" id="nextButton">ÃŽnainte</button>
            </div>
            <button type="button" id="addButton">SalveazÄƒ FiÈ™a È™i GenereazÄƒ Feedback AI</button>
        </form>

        <div id="confirmationMessage" class="confirmation-message">
            <!-- Mesajul va fi setat de JavaScript -->
        </div>

        <div class="collaboration-section" style="text-align:center; margin-top:30px; padding-bottom:10px; border-top: 1px solid #eef2f7; padding-top:20px;">
            <button type="button" id="generateLinkButton" style="background-color:#007bff; font-size:0.9em; padding:10px 20px;">PartajeazÄƒ FiÈ™ele (GenereazÄƒ Link)</button>
        </div>
    </div>
    
    <h3 id="cardViewTitle" style="text-align: center; margin-top: 40px; margin-bottom: 20px; color: #333a40; font-weight: 500;">RÄƒspunsurile Tale È™i Istoricul Feedback-ului AI:</h3>
    
    <div class="card-view" id="cardViewContainer">
        <!-- Cardurile cu rÄƒspunsuri È™i feedback AI vor fi adÄƒugate aici de JavaScript -->
    </div>
    
    <!-- Chat Container (structura rÄƒmÃ¢ne la fel) -->
    <div class="chat-container" id="chatContainer">
        <h3>DiscutÄƒ cu PsihoGPT</h3>
        <div id="chatMessages"></div>
        <textarea id="chatInput" rows="2" placeholder="Scrie mesajul tÄƒu... ApasÄƒ Enter pentru a trimite."></textarea>
        <button id="sendChatMessageButton" disabled>Trimite Mesaj</button>
        <p id="chatStatus"></p>
    </div>
    <button id="toggleChatButton" style="display: none;">ðŸ’¬</button>


    <div class="table-container" style="display: none;"> 
        <!-- Acest tabel nu mai este folosit activ pentru afiÈ™area datelor, cardurile sunt primare -->
        <table>
            <thead>
                <tr>
                    <th>Data</th><th>SituaÈ›ia</th><th>GÃ¢nduri</th><th>EmoÈ›ii</th><th>Mod activ</th>
                    <th>Comportament</th><th>Nevoile</th><th>Ajutor comport.</th><th>Adult SÄƒnÄƒtos</th><th>Detalii</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <br/>
</body>
</html>
