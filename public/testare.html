<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // Înlocuiește cu cheia ta reală
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÎNLOCUIEȘTE AICI !!!
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17"; // Sau modelul tău preferat
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configurată:", "'" + GEMINI_API_KEY + "'");

     if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") { // Am eliminat verificarea .startsWith()
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini inițializat. Model Feedback Jurnal:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare critică la inițializarea SDK Gemini:", e);
            let alertMessage = "Eroare la inițializarea serviciului AI pentru jurnal. Verificați cheia API Gemini și configurația.";
            if (e.message && e.message.toLowerCase().includes("api key not valid")) {
                alertMessage = "Cheia API Gemini nu este validă sau nu are permisiuni pentru modelul de jurnal. Verificați Google Cloud Console.";
            } else if (e.message && e.message.toLowerCase().includes("quota")) {
                alertMessage = "Limita de utilizare pentru API-ul Gemini a fost atinsă (posibil pentru modelul de jurnal).";
            }
            alert(alertMessage + " Funcționalitatea AI va fi limitată.");
            geminiModelJournalFeedback = null;
        }
    } else  {
        console.warn(`Jurnal Terapeutic: Cheia API Gemini este goală sau lipsește. Funcționalitatea AI va fi dezactivată.`);
        alert("Jurnal Terapeutic: Cheia API Gemini nu este configurată. Funcționalitatea AI pentru jurnal va fi dezactivată.");
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;
    let selectedPrompt = null; // Stochează obiectul promptului selectat

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
    };

    function toggleActivePrompt(show, promptData = null) {
        const box = document.getElementById('activePromptBox');
        const titleEl = document.getElementById('activePromptTitle');
        const contentEl = document.getElementById('activePromptContent');

        if (show && promptData) {
            selectedPrompt = promptData;
            titleEl.textContent = `Ghid activ: ${promptData.label}`;
            contentEl.textContent = promptData.text;
            box.style.display = 'block';
            // Scroll to the top of the prompt box content if it's long
            if(contentEl) contentEl.scrollTop = 0;
        } else {
            selectedPrompt = null;
            box.style.display = 'none';
        }
    }

    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [
            {
                label: "🌡️ Explorează o emoție",
                id: "explorare_emotie",
                text: "🌡️ *Astăzi simt...*\n" +
                      "Numește emoția dominantă: ________________\n\n" +
                      "🔍 *Unde o simt în corp?*\n" +
                      "Descrie senzațiile (tensiune, greutate, pulsație etc.): ________________\n\n" +
                      "💭 *Ce gânduri vin cu această emoție?*\n" +
                      "Notează gândurile automate, chiar dacă par „exagerate”: ________________\n\n" +
                      "📚 *În ce context a apărut?*\n" +
                      "Ce s-a întâmplat exact? Ce a declanșat-o? ________________\n\n" +
                      "💧 *Ce nevoie ar putea semnala?*\n" +
                      "De ce are nevoie această parte din tine? Ce lipsește? ________________\n\n" +
                      "💌 *Dacă aș avea compasiune pentru mine acum...*\n" +
                      "Ce mi-aș spune? Ce gest aș face pentru mine? ________________\n"
            },
            {
                label: "📝 Analizează o situație", // Păstrăm acest prompt clasic, poate fi util
                id: "analiza_situatie",
                text: "Situația care mă preocupă este: ________________\n\n" +
                      "Ce s-a întâmplat exact? (Fapte): ________________\n" +
                      "Interpretarea mea inițială (Gânduri automate): ________________\n" +
                      "Emoțiile principale: ________________\n" +
                      "O altă perspectivă (Reframing): ________________\n" +
                      "Ce am învățat/pot învăța? (Lecții): ________________\n"
            },
            {
                label: "🗣️ Dialog Voce Critică",
                id: "dialog_voce_critica",
                text: "🗣️ *Vocea mea interioară îmi spune...*\n" +
                      "(\"Ești slab\", \"Nu faci destul\", \"O să fii respins\"...): ________________\n\n" +
                      "😔 *Când aud acest mesaj, mă simt...*\n" +
                      "(emoții și senzații fizice): ________________\n\n" +
                      "🧒 *Această voce seamănă cu...*\n" +
                      "(E o voce veche? un părinte? un profesor? un fost partener?): ________________\n\n" +
                      "🧠 *Ce nevoie neîmplinită e în spatele acestui mesaj?*\n" +
                      "(Poate recunoaștere, protecție, control, apartenență?): ________________\n\n" +
                      "🧘 *Răspunsul meu ca Adult Sănătos ar fi...*\n" +
                      "(\"Apreciez că vrei să mă protejezi, dar acum aleg altceva.\"): ________________\n"
            },
            {
                label: "💖 Recunoștință & Resurse",
                id: "recunostinta_resurse",
                text: "💖 *Astăzi aleg să văd ce e bun...*\n" +
                      "Sunt recunoscător/oare pentru:\n" +
                      "1. ________________\n" +
                      "2. ________________\n" +
                      "3. ________________\n\n" +
                      "🌱 *O resursă interioară pe care mă pot baza astăzi este...*\n" +
                      "(ex: curaj, blândețe, claritate, capacitatea de a simți): ________________\n\n" +
                      "🛁 *Un gest de auto-îngrijire pe care îl pot face azi...*\n" +
                      "(chiar dacă e mic): ________________\n"
            },
            {
                label: "🌀 Ritual Reconstrucție Interioară",
                id: "ritual_reconstructie",
                text: `🧭 MASTER TEMPLATE – Scriere Terapeutică de Integrare și Vindecare\n` +
                      `Denumire: „Ritual de reconstrucție interioară”\n` +
                      `Scop: Eliberare, Clarificare, Conținere, Înțelepciune, Direcție\n\n` +
                      `I. 🔍 INVITAȚIE LA AUTENTICITATE\n` +
                      `„Ce parte din mine cere atenție acum?”\n\n` +
                      `   * Ce trăiesc cu adevărat, fără filtru, fără poveste cosmetizată?\n` +
                      `   * Ce mi-e rușine să simt sau să recunosc chiar și în scris?\n` +
                      `   * Ce parte din mine se simte exclusă, neauzită, ignorată?\n` +
                      `Răspuns: ________________\n\n` +
                      `II. 🌊 CONTAINERE EMOȚIONALE\n` +
                      `„Ce simte corpul meu? Unde locuiește durerea?”\n\n` +
                      `   * Unde simt emoția în corp? Cum se manifestă? (Tensiune, înțepături, etc.)\n` +
                      `   * Dacă ar avea o culoare, formă, textură – cum ar arăta?\n` +
                      `   * Pot respira în acea zonă 3 minute, fără să fug?\n` +
                      `Răspuns: ________________\n\n` +
                      `III. 🧠 DECODIFICARE NARATIVĂ\n` +
                      `„Ce poveste îmi spun? Este întreagă?”\n\n` +
                      `   * Ce narațiune inconștientă guvernează trăirea mea? (ex: „Nu sunt dorit.”)\n` +
                      `   * De unde vine această narațiune? Când am mai trăit ceva similar?\n` +
                      `   * Ce parte din mine (copil rănit, etc.) scrie această poveste?\n` +
                      `Răspuns: ________________\n\n` +
                      `IV. 🧩 INTEGRARE EXPLICATIVĂ\n` +
                      `„Ce înțeleg nou despre mine din această durere?”\n\n` +
                      `   * Ce nevoi profunde au fost ignorate sau negate?\n` +
                      `   * Ce am protejat, de fapt, prin reacția mea?\n` +
                      `   * Ce emoții contradictorii coexistă în mine și ce spun ele?\n` +
                      `Răspuns: ________________\n\n` +
                      `V. 🪞 COMPASIUNE ȘI BLÂNDEȚE\n` +
                      `„Cum pot fi părinte pentru mine acum?”\n\n` +
                      `   * Dacă mi-aș ține partea rănită în brațe, ce i-aș spune?\n` +
                      `   * Ce aș vrea să aud din partea unei figuri ideale de susținere?\n` +
                      `   * Pot lăsa iubirea, nu logica, să conducă acest moment?\n` +
                      `Răspuns: ________________\n\n` +
                      `VI. 🔮 RECONFIGURARE IDENTITARĂ\n` +
                      `„Cine sunt eu dincolo de această rană?”\n\n` +
                      `   * Ce adevăr despre mine rămâne valabil, chiar și în durere?\n` +
                      `   * Cine devin dacă învăț să stau cu mine în acest spațiu?\n` +
                      `   * Dacă aș fi un personaj simbolic acum, cine aș fi?\n` +
                      `Răspuns: ________________\n\n` +
                      `VII. ✍️ ACTUL SACRU DE ALEGERE\n` +
                      `„Ce aleg de azi, pentru mine?”\n\n` +
                      `   * Ce merită să las să plece?\n` +
                      `   * Ce îmi iau ca învățătură de încredere în viață?\n` +
                      `   * Ce ritual zilnic/mic obicei pot începe pentru a onora această transformare?\n` +
                      `Răspuns: ________________\n\n` +
                      `VIII. (Opțional) 📜 SCRISOARE-RITUAL\n` +
                      `Scrie o scrisoare către...\n` +
                      `Răspuns: ________________\n`
            }
        ];
        promptsContainerEl.innerHTML = '';
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "Inserează acest ghid în jurnal și afișează-l";
            button.onclick = () => {
                const insertText = prompt.text;
                if (journalTextarea.value.trim() !== "" && !confirm("Vrei să înlocuiești textul curent cu acest ghid? OK pentru a înlocui, Anulare pentru a adăuga la sfârșit.")) {
                    journalTextarea.value += "\n\n---\n" + insertText;
                } else {
                    journalTextarea.value = insertText;
                }
                toggleActivePrompt(true, prompt);
                journalTextarea.focus();
                // Scroll to the top of the textarea to see the newly inserted prompt
                journalTextarea.scrollTop = 0;
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) return "EROARE: Model AI neinițializat (jurnal).";
        try {
            console.log("Trimitem la Gemini (jurnal, primele 200 caractere):", promptText.substring(0, 200));
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.7, maxOutputTokens: 3500, ...generationConfigOptions } // Temp. 0.7, max token ajustat
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare oprită (Motiv: ${response.candidates[0].finishReason}). Detalii: ${JSON.stringify(response.candidates[0].safetyRatings)}`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Detalii: ${JSON.stringify(response.promptFeedback.blockReasonDetail || response.promptFeedback.safetyRatings)}`;
            }
            console.warn("Răspuns Gemini neașteptat sau gol:", JSON.stringify(response, null, 2));
            return "EROARE Gemini: Răspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            let userFriendlyError = `EROARE Gemini: ${error.message || "Eroare API necunoscută."}`;
            if (error.message && error.message.toLowerCase().includes("api key not valid")) {
                userFriendlyError = "EROARE: Cheia API Gemini nu este validă sau nu are permisiuni. Verificați configurația.";
            } else if (error.message && error.message.toLowerCase().includes("quota has been exceeded")) {
                userFriendlyError = "EROARE: Limita de utilizare API Gemini a fost depășită. Încercați mai târziu.";
            } else if (error.message && error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety")){
                 userFriendlyError = "EROARE Gemini: Generarea a fost oprită, posibil din motive de siguranță sau din cauza conținutului. Încercați să reformulați."
            }
            return userFriendlyError;
        }
    }
    
    function getSelectedPromptType() {
        if (selectedPrompt && selectedPrompt.id) {
            return selectedPrompt.id;
        }
        const journalContent = document.getElementById("journalContent")?.value || "";
        return detectPromptUsed(journalContent);
    }

    function detectPromptUsed(content) {
        if (!content) return "prompt_personalizat";
        content = content.toLowerCase();

        if (content.includes("ce parte din mine cere atenție acum") && content.includes("master template")) return "ritual_reconstructie";
        if (content.includes("vocea mea interioară îmi spune") || content.includes("vocea mea critică îmi spune")) return "dialog_voce_critica";
        if (content.includes("astăzi simt...") && content.includes("numește emoția dominantă:")) return "explorare_emotie";
        if (content.includes("astăzi aleg să văd ce e bun") && content.includes("sunt recunoscător/oare pentru:")) return "recunostinta_resurse";
        if (content.includes("situația care mă preocupă este:")) return "analiza_situatie";
        return "prompt_personalizat";
    }

    function buildAdaptiveAIPrompt(entryTitle, journalText, promptType) {
        let specificInstructions = "";
        let modelFocus = "feedback general și reflecție";

        let basePrompt = `Ești PsihoGPT – un terapeut AI avansat, extrem de empatic, cu o profundă înțelegere a psihologiei umane, antrenat în Terapie Cognitiv-Comportamentală (TCC), Terapia Schemelor, Terapia prin Acceptare și Angajament (ACT), Scrierea Expresivă și principii de mindfulness. Comunică într-un limbaj cald, validant și ușor de înțeles, dar păstrează profunzimea analitică. Folosește formatare Markdown pentru structurare (titluri cu \`**Titlu**\`, liste cu \`* Element listă\`, text bold cu \`**text bold**\` și italic cu \`*text italic*\` unde e cazul). Evită citatele direct din literatură dacă nu sunt absolut esențiale, concentrează-te pe limbajul tău.

Obiectivul tău este să oferi un feedback personalizat, constructiv și profund pentru următoarea intrare în jurnal. Nu oferi sfaturi medicale sau diagnostice. Concentrează-te pe facilitarea auto-înțelegerii și a creșterii personale.`;

        switch (promptType) {
            case "ritual_reconstructie":
                specificInstructions = `
Utilizatorul a completat un exercițiu profund numit "Ritual de Reconstrucție Interioară", care are 7 secțiuni principale (I. Invitație la Autenticitate, II. Containere Emoționale, III. Decodificare Narativă, IV. Integrare Explicativă, V. Compasiune și Blândețe, VI. Reconfigurare Identitară, VII. Actul Sacru de Alegere) și poate include o secțiune VIII (Scrisoare-Ritual).
Feedback-ul tău AR TREBUI SĂ URMEZE ACEASTĂ STRUCTURĂ. Pentru FIECARE secțiune relevantă (unde utilizatorul a scris ceva semnificativ):
1.  **Numește secțiunea** (ex: "**I. Invitație la Autenticitate:**").
2.  **Recunoaște și Validează** efortul specific pentru acea secțiune și oferă o scurtă validare empatică a conținutului.
3.  **Reflectă principalele teme și insight-uri** care reies din răspunsurile utilizatorului la acea secțiune. Fii specific și poți cita scurt (1-5 cuvinte) din textul utilizatorului pentru ancorare.
4.  **Pune o întrebare de aprofundare specifică** (sau 2 maxim, doar dacă este pertinent) pentru acea secțiune, care să invite la o reflecție și mai adâncă asupra celor descoperite acolo.
După ce ai parcurs secțiunile, adaugă o secțiune de **Concluzii și Încurajare:**
*   **Identifică Conexiuni Generale:** Evidențiază pe scurt legături sau tipare observate între diferitele secțiuni (ex: cum autenticitatea din I se leagă de nevoile din IV sau de alegerile din VII).
*   **Încurajează** procesul de transformare schițat în secțiunea VII (Actul Sacru de Alegere) și apreciază vulnerabilitatea.
Evită generalitățile. Fii țintit pe conținutul specific fiecărei secțiuni a ritualului. Răspunsul total trebuie să fie detaliat, dar structurat și ușor de parcurs.`;
                modelFocus = "analiză structurată a ritualului de reconstrucție, pas cu pas, cu focus pe integrare, reflecție aprofundată per secțiune și transformare";
                break;
            case "dialog_voce_critica":
                specificInstructions = `
Utilizatorul a explorat un dialog cu "Vocea Critică". Feedback-ul tău ar trebui să fie structurat astfel:
1.  **Validare Empatică:** Recunoaște dificultatea și durerea asociate cu auzirea mesajelor critice.
2.  **Analiza Mesajului Critic:** Identifică mesajul critic principal. Ce temă sau frică de bază pare să exprime? (Ex: frica de eșec, de respingere, de a nu fi suficient de bun).
3.  **Rolul Protector (Disfuncțional):** Explorează posibilul rol protector al vocii critice. Ce nevoie fundamentală (ex: siguranță, apartenență, control) ar putea încerca această voce să satisfacă într-un mod neîndemânatic?
4.  **Perspectiva Adultului Sănătos:** Reflectează asupra răspunsului Adultului Sănătos. Este compasional? Asertiv? Cum întărește o perspectivă mai echilibrată și auto-susținătoare?
5.  **Întrebări de Aprofundare (1-2):** Acestea ar putea viza originile vocii critice (ex: "Această voce pare să ecouze pe cineva din trecutul tău, sau este un mesaj pe care l-ai internalizat de-a lungul timpului?") sau strategii de a cultiva mai mult vocea Adultului Sănătos (ex: "Ce mic gest de blândețe sau acțiune aliniată cu Adultul Sănătos ai putea practica mâine, chiar și pentru câteva minute?").
6.  **Notă despre Scheme (discret):** Dacă mesajul critic este foarte puternic și pare legat de o schemă (ex: "Nu ești bun de nimic" -> Defectivitate), poți menționa la final, cu delicatețe: "*Uneori, astfel de voci critice pot fi ecouri ale unor tipare de gândire și simțire mai vechi, pe care în terapie le numim 'scheme'. Explorarea lor poate aduce și mai multă claritate.*" Nu insista, nu diagnostica.`;
                modelFocus = "analiză aprofundată a dinamicii vocii critice versus Adultul Sănătos, identificarea nevoilor subiacente și oferirea de piste pentru reflecție ulterioară";
                break;
            case "explorare_emotie":
                specificInstructions = `
Utilizatorul a explorat o emoție specifică. Feedback-ul tău ar trebui să aibă următoarea structură:
1.  **Validarea Emoției:** Începe prin a valida emoția numită și intensitatea ei. Recunoaște curajul de a o explora.
2.  **Conexiunea Corp-Emoție:** Comentează descrierea senzațiilor corporale. Cum ajută această conștientizare la înțelegerea mai profundă și la "simțirea" emoției, nu doar la "gândirea" ei?
3.  **Relația Gânduri-Emoție:** Analizează cum gândurile automate menționate par să influențeze (să genereze, intensifice sau mențină) emoția. Există tipare de gândire evidente?
4.  **Context și Declanșator:** Reflectează asupra contextului și a declanșatorului. Ce anume din situația descrisă pare să fi activat această emoție?
5.  **Nevoia Fundamentală:** Analizează nevoia semnalată. Cât de pertinentă pare? Cum se leagă aceasta de emoție și de situație? Este o nevoie recurentă?
6.  **Auto-Compasiune și Acțiune:** Apreciază gestul de auto-compasiune descris. Cum ar putea fi acesta un pas concret spre reglare emoțională sau spre împlinirea nevoii identificate?
7.  **Întrebări de Reflecție Finală (1-2):** Pune întrebări deschise, orientate spre viitor sau spre o înțelegere mai profundă. Ex: "*Ce ai învățat despre tine sau despre această emoție prin acest exercițiu?*", "*Ce mic pas ai putea face în următoarele zile pentru a onora nevoia pe care ai identificat-o, atunci când simți din nou această emoție?*"`;
                modelFocus = "înțelegerea detaliată a emoției în context (corp, gânduri, trigger, nevoie) și promovarea auto-compasiunii și a acțiunilor conștiente";
                break;
            case "recunostinta_resurse":
                specificInstructions = `
Utilizatorul a completat un exercițiu de recunoștință și identificare a resurselor interioare. Feedback-ul tău ar trebui să:
1.  **Aprecierea Practicii:** Începe prin a aprecia efortul de a se conecta cu recunoștința și resursele interioare.
2.  **Analiza Recunoștinței:** Observă temele recurente în motivele de recunoștință, dacă există. Ce spun acestea despre valorile, prioritățile sau domeniile de viață importante pentru utilizator?
3.  **Explorarea Resursei Interioare:** Reflectează asupra resursei interioare menționate. Cum poate fi aceasta o ancoră în momente dificile? Cum poate fi cultivată și mai mult în viața de zi cu zi? Poți oferi o micro-sugestie practică (ex: o vizualizare scurtă, o afirmație).
4.  **Impactul Auto-Îngrijirii:** Comentează gestul de auto-îngrijire. Cât de important este acest act, chiar și mic, în contextul general al stării de bine și al echilibrului emoțional?
5.  **Încurajarea Continuității:** Încurajează integrarea acestor practici (recunoștință, conectare la resurse, auto-îngrijire) în rutina zilnică, subliniind beneficiile pe termen lung.
6.  **Întrebări de Final (1-2):** Pune întrebări care să ancoreze experiența. Ex: "*Cum te-a făcut să te simți acest exercițiu? Ce mică schimbare de perspectivă (dacă există) îți aduce?*", "*Cum ai putea să îți reamintești de această resursă interioară atunci când te confrunți cu o provocare?*"`;
                modelFocus = "consolidarea practicii recunoștinței, ancorarea în resurse interioare și auto-îngrijire, și încurajarea integrării lor în viața cotidiană";
                break;
            case "analiza_situatie":
                specificInstructions = `
Utilizatorul a analizat o situație specifică folosind un ghid structurat. Feedback-ul tău ar trebui să:
1.  **Recunoașterea Efortului:** Validează efortul de structurare și analiză a situației.
2.  **Sumarizarea Elementelor Cheie:** Reflectă pe scurt elementele principale identificate de utilizator: situația, faptele, interpretarea inițială (gândurile automate) și emoțiile.
3.  **Analiza Perspectivei Alternative (Reframing):** Comentează perspectiva alternativă. Cât de diferită este aceasta de interpretarea inițială? Ce impact ar putea avea adoptarea conștientă a acestei noi perspective asupra emoțiilor și comportamentelor viitoare?
4.  **Evidențierea Învățămintelor (Lecțiilor):** Subliniază lecțiile învățate sau cele potențiale identificate. Ce se poate extrage constructiv și valoros din această situație, chiar dacă a fost dificilă?
5.  **Întrebări de Aprofundare și Acțiune (1-2):** Pune întrebări care să stimuleze integrarea. Ex: "*Ce te-ar ajuta să accesezi mai ușor această 'altă perspectivă' în situații similare viitoare?*", "*Ce mic pas concret, bazat pe lecția învățată, ai putea face în următoarea săptămână dacă o situație similară ar apărea?*"`;
                modelFocus = "analiza constructivă a situației, cu accent pe reframing, identificarea lecțiilor și transpunerea lor în pași acționabili";
                break;
            default: // prompt_personalizat sau neidentificat
                specificInstructions = `
Utilizatorul a scris o intrare liberă în jurnal, fără un ghid specific. Feedback-ul tău ar trebui să fie empatic, reflexiv și să deschidă noi perspective:
1.  **Validare Generală și Empatie:** Începe cu o validare caldă pentru ceea ce a fost exprimat. Recunoaște deschiderea și reflectă emoția sau tonul general care reiese din text.
2.  **Identificarea Temelor Centrale (1-2):** Identifică cu grijă 1-2 teme, emoții sau preocupări principale care par să iasă în evidență din textul utilizatorului. Poți folosi citate foarte scurte (1-3 cuvinte) pentru a ilustra, dar nu excesiv.
3.  **Întrebări Deschise și Evocatoare (2-3):** Pune 2-3 întrebări deschise, care să invite utilizatorul la o explorare mai adâncă a aspectelor menționate, fără a fi intruziv. Întrebările ar trebui să stimuleze auto-descoperirea. Exemple: "*Citind despre [temă specifică], mă întrebam ce altceva ai observat despre tine în acea experiență?*", "*Dacă ai putea da un mesaj părții din tine care a trăit [emoție/situație], care ar fi acela și de ce crezi că ar avea nevoie să-l audă?*", "*Ce nevoie mai profundă crezi că încearcă să se facă auzită prin aceste rânduri/sentimente?*".
4.  **Oglindire și Reflecție (nu interpretare):** Reflectă înapoi ceea ce ai "auzit" în text, fără a adăuga interpretări personale sau a presupune prea mult. Folosește formulări de genul "Pare că...", "Am observat că menționezi...", "Sună ca și cum...".
5.  **Încurajare Finală:** Oferă o scurtă încurajare pentru continuarea procesului valoros de scriere și auto-reflecție.`;
                modelFocus = "reflecție empatică asupra textului liber, identificarea temelor centrale și facilitarea explorării prin întrebări deschise și susținătoare";
                break;
        }

        const finalPrompt = `${basePrompt}

**Focusul specific pentru această intrare de jurnal (bazat pe ghidul "${promptType}") este: ${modelFocus}.**

**Instrucțiuni specifice pentru feedback bazat pe tipul de ghid ("${promptType}"):**
${specificInstructions}
---
**Conținutul Jurnalului Utilizatorului este:**
Titlu: ${entryTitle || "Fără titlu"}
Ghid utilizat (detectat/selectat): ${promptType}

Text Complet:
\`\`\`
${journalText}
\`\`\`
---
Te rog să generezi un feedback AI care să respecte toate aceste cerințe. Fii cât mai specific și personalizat pe textul oferit. Mulțumesc!`;

        return finalPrompt;
    }

    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: Funcționalitatea AI pentru jurnal nu este disponibilă.";
        
        const promptType = entryData.promptTypeUtilizat || detectPromptUsed(entryData.continut);
        const promptJurnalAdaptiv = buildAdaptiveAIPrompt(entryData.titlu, entryData.continut, promptType);

        console.log(`Jurnal - Regenerare/Generare Feedback pentru tipul: ${promptType}.`);
        const feedbackText = await callGeminiAPI(promptJurnalAdaptiv, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId, promptType);
    }
    
    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId, promptType = "necunoscut") { // Am adaugat promptType
        const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            promptTypeAtGeneration: promptType, // Salvam si tipul de prompt folosit la generare
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva în jurnal."); return; }

        const tipPromptFolosit = getSelectedPromptType();

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid,
            promptTypeUtilizat: tipPromptFolosit // SALVEAZĂ TIPUL PROMPTULUI
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salvează..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se generează AI...";
            // entryData.id = docRef.id; // Adaugă ID-ul pentru consistență dacă genereaza... are nevoie de el direct
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id); // Trimite entryData complet
            
            const docSnapshot = await getDoc(docRef); // Re-fetch pentru a avea și feedback-ul AI
            if (docSnapshot.exists()) {
                 afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            } else { // Fallback dacă docSnapshot nu e gata imediat, puțin probabil dar defensiv
                 console.warn("Documentul nu a fost găsit imediat după adăugare/update. Afișare cu date parțiale.");
                 entryData.id = docRef.id; // Asigură-te că ID-ul e setat
                 entryData.feedbackAI_latest = parsedFeedback;
                 entryData.feedbackAI_history = [parsedFeedback];
                 afiseazaCardJurnal(entryData);
            }
            
            journalTextarea.value = ""; 
            if (journalTitleInput) journalTitleInput.value = "";
            toggleActivePrompt(false); // Ascunde ghidul activ
            selectedPrompt = null; // Resetează promptul selectat

            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvată. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvată și feedback AI generat!';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau generare feedback.';
            confirmationMsg.className = 'confirmation-message error';
        } finally {
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 9000);
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se generează..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');


        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { 
                alert("Intrarea nu există."); 
                if(confirmationMsg) {
                    confirmationMsg.textContent = 'Eroare: Intrarea nu a fost găsită.';
                    confirmationMsg.className = 'confirmation-message error';
                    confirmationMsg.style.display = 'block';
                }
                return; 
            }
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId); // trimite entryDoc.data() care are promptTypeUtilizat
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); 
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                // Actualizează întregul card pentru a reflecta noul feedback, similar cu cum e făcut în salveaza...
                // Cel mai simplu e să re-afișăm cardul. Dar asta poate închide cardul dacă era deschis.
                // O soluție mai bună e să actualizăm doar containerul de feedback.
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) {
                    afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
                }
            }
            const message = parsedFeedback.error ? `Feedback AI: ${parsedFeedback.rawText}` : "Feedback AI regenerat și adăugat la istoric!";
            if(confirmationMsg) {
                confirmationMsg.textContent = message;
                confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
                confirmationMsg.style.display = 'block';
                setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                alert(message);
            }

        } catch (e) { 
            console.error("Eroare regenerare:", e); 
            if(confirmationMsg) {
                confirmationMsg.textContent = 'Eroare la regenerare feedback.';
                confirmationMsg.className = 'confirmation-message error';
                confirmationMsg.style.display = 'block';
                setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                 alert("Eroare la regenerare feedback.");
            }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        if (!confirm("Ștergi ultimul feedback AI pentru această intrare? Această acțiune nu poate fi anulată.")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se șterge..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                const msg = "Nu există feedback de șters.";
                if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message warning'; confirmationMsg.style.display = 'block'; setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);}
                else { alert(msg); }
                return;
            }
            const history = entrySnap.data().feedbackAI_history;
            history.pop(); // Scoate ultimul

            await updateDoc(entryDocRef, {
                feedbackAI_history: history,
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            
            const msg = "Ultimul feedback AI șters.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message success'; confirmationMsg.style.display = 'block'; setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }

        } catch (e) { 
            console.error("Eroare ștergere ultim feedback:", e); 
             const msg = "Eroare la ștergere feedback.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, feedbackHistory) {
        containerEl.innerHTML = ''; 

        if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
            const noHistoryMsg = document.createElement("p");
            noHistoryMsg.textContent = "Niciun feedback AI generat pentru această intrare.";
            noHistoryMsg.className = "no-feedback-message";
            containerEl.appendChild(noHistoryMsg);
            return;
        }

        feedbackHistory.slice().reverse().forEach((entry, index) => {
            const itemContainer = document.createElement("div");
            itemContainer.className = "feedback-entry-card"; 

            const timestampAndModel = document.createElement("p");
            timestampAndModel.className = "feedback-timestamp";
            const modelInfo = entry.model || 'N/A';
            const promptTypeInfo = entry.promptTypeAtGeneration ? ` (Ghid: ${entry.promptTypeAtGeneration.replace(/_/g, ' ')})` : '';
            timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - ${modelInfo}${promptTypeInfo})`;
            itemContainer.appendChild(timestampAndModel);

            const contentWrapper = document.createElement("div"); 
            contentWrapper.className = "content-ai"; 

            if (entry.error) {
                const errorP = document.createElement("p");
                errorP.className = "ai-text-error";
                errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
                contentWrapper.appendChild(errorP);
            } else {
                let textToProcess = entry.rawText || 'Conținut indisponibil.';
                let finalHtmlElements = []; 
                const lines = textToProcess.split('\n');
                let currentParagraphContent = [];
                let inList = false; // Track if we are inside a list
                let currentListElement = null;


                for (const line of lines) {
                    // 1. Verifică Titlurile Principale (ex: **Titlu**)
                    // Asigură-te că nu e parte dintr-un text bold în interiorul unei linii.
                    const matchTitle = line.match(/^\s*(\*\*|###\s*|\#\#\s*|\#\s*)([^*#]+)\1?\s*$/);


                    if (matchTitle && matchTitle[2].trim().length > 0) {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                         if (inList && currentListElement) {
                            finalHtmlElements.push(currentListElement);
                            inList = false; currentListElement = null;
                        }
                        const titleDiv = document.createElement(matchTitle[1].startsWith('#') ? `h${matchTitle[1].length}` : 'div'); // H_ sau DIV
                        titleDiv.className = 'ai-main-section-title';
                        // Scoat boldul din titlu dacă e cu ** și păstrează-l dacă e din #
                        titleDiv.textContent = matchTitle[2].trim();
                        finalHtmlElements.push(titleDiv);
                        continue; 
                    }

                    // 2. Verifică Elementele de Listă (ex: * Item, - Item, 1. Item)
                    const matchListItem = line.match(/^\s*([\*\-\+]|\d+\.)\s+(.*)/);
                    if (matchListItem) {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                             let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        if (!inList) {
                            inList = true;
                            currentListElement = document.createElement(matchListItem[1].match(/\d+\./) ? 'ol' : 'ul');
                            currentListElement.className = 'ai-list';
                        }
                        const listItem = document.createElement('li');
                        listItem.className = 'ai-list-item';
                        // Parsează markdown simplu în interiorul itemului de listă
                        let itemHtml = matchListItem[2];
                        itemHtml = itemHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                        itemHtml = itemHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                        listItem.innerHTML = itemHtml;
                        currentListElement.appendChild(listItem);
                        continue; 
                    }
                    
                    // Dacă nu e titlu sau listă, și eram într-o listă, terminăm lista.
                    if (inList && currentListElement) {
                        finalHtmlElements.push(currentListElement);
                        inList = false; currentListElement = null;
                    }

                    // 3. Text normal sau linie goală
                    if (line.trim() === "") {
                        if (currentParagraphContent.length > 0) {
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                             let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        // Adaugă un <br> doar dacă nu e ultimul element sau dacă nu e urmat de alt conținut
                        if (lines.indexOf(line) < lines.length -1 && lines[lines.indexOf(line)+1].trim() !== "") {
                           finalHtmlElements.push(document.createElement('br'));
                        }
                    } else {
                        currentParagraphContent.push(line);
                    }
                }

                if (currentParagraphContent.length > 0) {
                    const p = document.createElement('p');
                    p.className = 'ai-text-paragraph';
                    let paragraphHtml = currentParagraphContent.join('<br>');
                    paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                    paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                    p.innerHTML = paragraphHtml;
                    finalHtmlElements.push(p);
                }
                 if (inList && currentListElement) { // Adaugă lista dacă era ultima
                    finalHtmlElements.push(currentListElement);
                }

                finalHtmlElements.forEach(el => contentWrapper.appendChild(el));
            }
            itemContainer.appendChild(contentWrapper);
            containerEl.appendChild(itemContainer);
        });
    }

    function afiseazaCardJurnal(entryData) {
        const container = document.getElementById("journalEntriesContainer");
        let card = container.querySelector(`.journal-card[data-id="${entryData.id}"]`);
        
        const entryDate = entryData.dataIntrare || (entryData.timestampCreare?.toDate ? new Date(entryData.timestampCreare.toDate()).toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }) : 'Dată necunoscută');
        const entryTitle = entryData.titlu || `Intrare din ${entryDate}`;
        const promptTypeUsedDisplay = entryData.promptTypeUtilizat ? ` (Ghid: ${entryData.promptTypeUtilizat.replace(/_/g, ' ')})` : '';

        if (!card) { // Creare card nou
            card = document.createElement("div");
            card.className = "response-card journal-card"; 
            card.setAttribute("data-id", entryData.id);
            // Nota: Am simplificat card-content inițial; detaliile jurnalului sunt într-un <details>
            card.innerHTML = `
                <div class="card-header">
                    <span>${entryTitle}${promptTypeUsedDisplay}</span>
                    <span class="card-date">${entryDate}</span>
                </div>
                <div class="card-content">
                    <details class="journal-entry-details">
                        <summary>Vezi/Ascunde textul jurnalului</summary>
                        <p class="journal-entry-content-text">${entryData.continut.replace(/\n/g, '<br>')}</p>
                    </details>
                    <h4>Feedback AI PsihoGPT</h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                         <button class="regenerate-feedback-button" title="Regenerează Feedback AI">Regenerează</button>
                         <button class="delete-last-feedback-button" title="Șterge Ultimul Feedback AI">Șterge Ultimul</button>
                         <button class="delete-journal-entry-button" title="Șterge Intrarea și Tot Feedback-ul">Șterge Intrarea</button>
                    </div>
                </div>`;
            
            const header = card.querySelector('.card-header');
            header.addEventListener('click', (e) => {
                 // Toggle 'open' class only if the click is not on the date span or other specific elements
                 if (!e.target.classList.contains('card-date')) {
                    card.classList.toggle('open');
                 }
            });
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); regenereazaFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); stergeUltimulFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeIntrareJurnal(entryData.id, card); });
            
            const noEntriesMsg = container.querySelector('.no-entries-message');
            if (noEntriesMsg) noEntriesMsg.remove();

            if (container.firstChild) { 
                container.insertBefore(card, container.firstChild);
            } else { 
                container.appendChild(card);
            }
        } else { // Update card existent (ex: după regenerare, dacă am alege să actualizăm tot cardul)
             card.querySelector('.card-header span:first-child').textContent = `${entryTitle}${promptTypeUsedDisplay}`;
             card.querySelector('.journal-entry-content-text').innerHTML = entryData.continut.replace(/\n/g, '<br>');
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, entryData.feedbackAI_history || entryData.feedbackAI_latest ? (entryData.feedbackAI_history || [entryData.feedbackAI_latest].filter(Boolean)) : []);
    }

    async function stergeIntrareJurnal(id, cardElement) {
        if (!confirm("Ștergi această intrare din jurnal și tot feedback-ul asociat? Acțiunea este ireversibilă.")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card')) {
                const noEntriesMsg = document.createElement("p");
                noEntriesMsg.className = "no-entries-message";
                noEntriesMsg.textContent = "Nicio intrare în jurnal. Începe prin a scrie una!";
                container.appendChild(noEntriesMsg);
            }
        } catch (error) { console.error("Eroare ștergere intrare:", error); alert("Eroare la ștergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        
        let loadingMsg = container.querySelector(".loading-message");
        if (!container.querySelector('.journal-card') && !loadingMsg) {
            loadingMsg = document.createElement("p");
            loadingMsg.className = "loading-message";
            loadingMsg.textContent = "Se încarcă intrările...";
            container.appendChild(loadingMsg);
        }

        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            if (loadingMsg) loadingMsg.remove(); // Înlătură "Se încarcă..."

            const currentCardIds = new Set();
            container.querySelectorAll('.journal-card').forEach(card => currentCardIds.add(card.dataset.id));
            
            const docsData = [];
            querySnapshot.forEach((docSnap) => {
                docsData.push({ id: docSnap.id, ...docSnap.data() });
            });

            // Șterge cardurile care nu mai sunt în Firestore (dacă există o astfel de logică de ștergere externă)
            container.querySelectorAll('.journal-card').forEach(card => {
                if (!docsData.find(d => d.id === card.dataset.id)) {
                    card.remove();
                }
            });

            if (docsData.length === 0) {
                if(!container.querySelector('.journal-card') && !container.querySelector('.no-entries-message')) { // Adaugă mesajul doar dacă nu există deja carduri
                    const noEntriesMsg = document.createElement("p");
                    noEntriesMsg.className = "no-entries-message";
                    noEntriesMsg.textContent = "Nicio intrare. Începe prin a scrie una!";
                    container.appendChild(noEntriesMsg);
                }
            } else {
                 const noEntriesMessage = container.querySelector('.no-entries-message');
                 if (noEntriesMessage) noEntriesMessage.remove();
                 docsData.forEach(docData => afiseazaCardJurnal(docData));
            }

        } catch (error) {
            console.error("Eroare încărcare jurnal:", error);
             if (loadingMsg) loadingMsg.remove();
            if(!container.querySelector('.journal-card') && !container.querySelector('.error-loading-message')) {
                const errorMsg = document.createElement("p");
                errorMsg.className = "error-loading-message";
                errorMsg.textContent = "Eroare la încărcarea jurnalului. Vă rugăm reîncărcați pagina.";
                container.appendChild(errorMsg);
            }
        }
    }
    </script>
    <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f0f2f5; 
        color: #333a40; line-height: 1.6; font-size: 16px;
    }
    .journal-form-container {
        max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
        box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.7em; margin-bottom: 10px; }
    h3 { font-size: 1.4em; margin-top: 35px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
        transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
    }
    textarea#journalContent { min-height: 250px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;
    }
    
    /* Prompturi de Reflecție Activi */
    .prompt-box {
        background: #f8f9fc;
        border: 1px solid #e6eaf0;
        border-left: 4px solid #5c85d6;
        padding: 12px 15px;
        margin-bottom: 15px;
        font-size: 0.9em;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }
    .prompt-box strong { color: #2c3e50; display: block; margin-bottom: 8px; }
    .prompt-content-display {
        white-space: pre-wrap; 
        max-height: 180px; 
        overflow-y: auto;
        background-color: #ffffff;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #e9edf2;
        font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
        font-size:0.95em;
        line-height: 1.55;
        color: #333;
    }
    .prompt-content-display::-webkit-scrollbar { width: 5px; }
    .prompt-content-display::-webkit-scrollbar-thumb { background: #cbd2d9; border-radius:3px; }

    .hide-prompt-button { 
        background: none; border: none; color: #88929e;
        font-size: 1.6em; font-weight: bold; cursor: pointer;
        padding: 0 5px; line-height: 0.8; float:right;
    }
    .hide-prompt-button:hover { color: #333; }

    /* Butoane Prompt Reflecție - listă */
    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 15px; background-color: #f8f9fc; border-radius: 8px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 12px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    button.prompt-button {
        background-color: #e9f0ff; color: #4a69bd; border: 1px solid #d1dfff;
        padding: 7px 14px; font-size: 0.85em; font-weight: 500; border-radius: 18px;
        cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button.prompt-button:hover { background-color: #d8e4ff; color: #3a539b; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.07); }

    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 20px; padding: 13px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 3px 7px rgba(92, 133, 214, 0.22);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1.5px); box-shadow: 0 4px 9px rgba(92, 133, 214, 0.28); }
    button#saveJournalEntryButton:disabled { background: #b0c4de !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    .confirmation-message { display: none; text-align: center; padding: 13px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdecea; color: #b32d21; border-color: #f8c6c1; }
    .confirmation-message.warning { background-color: #fff8e1; color: #795508; border-color: #ffecb3; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    /* Carduri Istoric Jurnal */
    .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
    .response-card .card-header {
        font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
        padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
    .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap;}

    .response-card .card-header::after {content: '▼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; /* Allow auto for scroll if needed, but pre-wrap on text content handles overflow better */ transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
    .response-card.open .card-content { max-height: 7000px; /* generous max height */ padding: 20px 20px; }
    
    .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
    .journal-entry-details summary { 
        cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
        background-color: #f8f9fa; border-radius: 6px 6px 0 0; 
        list-style-position: inside; /* For better alignment of the triangle */
    }
    .journal-entry-details summary:hover { background-color: #f1f3f6; }
    .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
    .journal-entry-content-text { 
        padding: 12px; font-size: 1em; line-height: 1.7; color: #3e4c59; white-space: pre-wrap; 
        max-height: 400px; overflow-y: auto;
    }
    .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
    .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }


    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 15px; font-size: 1.05em;
        border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
    }
    .response-card h4:first-of-type { margin-top: 0; } /* Feedback AI title might be first */

    .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }
    .no-entries-message, .loading-message, .error-loading-message { text-align: center; margin-top:25px; font-style: italic; color: #556575; font-size: 1.05em; padding:15px;}
    .error-loading-message { color: #c0392b; font-weight: 500;}


    .ai-feedback-history-container { margin-top: 10px; }
    .feedback-entry-card { 
        background:#fdfdff; padding: 15px; 
        border: 1px solid #e7ecf2;
        border-left: 4px solid #5c85d6; 
        border-radius:8px; margin-bottom:15px; 
        font-size:0.95em; line-height:1.6;
        box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    }
    .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
    
    .card-actions { 
        text-align: right; margin-top: 20px; padding-top: 15px; 
        border-top: 1px solid #eef2f7; 
        display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
    }
    .card-actions button {
        padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
        transition: all 0.2s; border: 1px solid transparent;
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
    button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
    button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
    button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
    button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
    
    /* Stiluri specifice pentru conținutul AI din feedback-entry-card .content-ai */
    .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
    .content-ai .ai-main-section-title, 
    .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 {
        font-weight: 600; color: #5c85d6; /* Culoarea accent */
        margin-top: 1.2em; margin-bottom: 0.6em; font-size: 1.1em;
        padding-bottom: 4px;
        /* border-bottom: 1px dotted #d1d9e2; */
    }
    .content-ai .ai-main-section-title:first-child,
    .content-ai h1:first-child, .content-ai h2:first-child, .content-ai h3:first-child, .content-ai h4:first-child {
        margin-top: 0.2em;
    }
    .content-ai p.ai-text-paragraph { margin-bottom: 0.8em; }
    .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; }
    .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; }
    
    .content-ai ul.ai-list, .content-ai ol.ai-list {
        margin-left: 5px; padding-left: 22px; margin-bottom: 0.8em;
    }
    .content-ai .ai-list-item { margin-bottom: 0.4em; }
    .content-ai .ai-list-item::marker { color: #5c85d6; }

    .content-ai .ai-text-error {
        color: #c0392b; font-weight: 500; background-color: #fff5f5; 
        padding: 8px; border-radius: 4px; border-left: 3px solid #c0392b;
        white-space: pre-wrap;
    }
    
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto; max-width: 100%;}
        h2 {font-size: 1.5em;} h3 {font-size: 1.25em;}
        textarea#journalContent {min-height: 200px;}
        .card-actions {justify-content: center;}
        .card-actions button { flex-basis: calc(33.33% - 7px); }
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.3em;} h3 {font-size: 1.15em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 8px;}
        button.prompt-button {padding: 6px 12px; font-size: 0.8em;}
        button#saveJournalEntryButton {padding: 11px 18px; font-size: 1em;}
        .card-header {font-size: 1em; padding: 12px 15px;}
        .card-actions button { flex-basis: 100%; }
    }
    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -12px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            Spațiul tău dedicat pentru reflecție ghidată, auto-descoperire și integrare emoțională.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (Opțional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: Reflecții despre ziua de azi, Explorarea anxietății...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflecție (alege un ghid pentru a-l insera și afișa):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <div id="activePromptBox" class="prompt-box" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <strong id="activePromptTitle">Ghid activ:</strong>
                    <button type="button" onclick="document.getElementById('activePromptBox').style.display='none'; selectedPrompt = null;" class="hide-prompt-button" title="Ascunde ghidul">×</button>
                </div>
                <div id="activePromptContent" class="prompt-content-display"></div>
                <p style="font-size:0.85em; text-align:right; margin-top:8px; color: #64748B;"><em>Acest ghid este pentru inspirație. Completează în jurnalul de mai jos.</em></p>
            </div>

            <label for="journalContent" style="margin-top: 15px;">Intrarea ta în jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="15" placeholder="Scrie liber aici... sau alege un ghid de mai sus și completează-l."></textarea>
            
            <button type="button" id="saveJournalEntryButton">Salvează și Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul Intrărilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Cardurile cu intrări vor fi încărcate aici -->
    </div>
    
</body>
</html>