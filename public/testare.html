<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // ÃŽnlocuieÈ™te cu cheia ta realÄƒ
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÃŽNLOCUIEÈ˜TE AICI !!! (AsigurÄƒ-te cÄƒ NU este placeholder-ul!)
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17";
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configuratÄƒ:", "'" + GEMINI_API_KEY + "'");

     if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") { // Am eliminat verificarea .startsWith()
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini iniÈ›ializat. Model Feedback Jurnal:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare criticÄƒ la iniÈ›ializarea SDK Gemini:", e);
            let alertMessage = "Eroare la iniÈ›ializarea serviciului AI pentru jurnal. VerificaÈ›i cheia API Gemini È™i configuraÈ›ia.";
            if (e.message && e.message.toLowerCase().includes("api key not valid")) {
                alertMessage = "Cheia API Gemini nu este validÄƒ sau nu are permisiuni pentru modelul de jurnal. VerificaÈ›i Google Cloud Console.";
            } else if (e.message && e.message.toLowerCase().includes("quota")) {
                alertMessage = "Limita de utilizare pentru API-ul Gemini a fost atinsÄƒ (posibil pentru modelul de jurnal).";
            }
            alert(alertMessage + " FuncÈ›ionalitatea AI va fi limitatÄƒ.");
            geminiModelJournalFeedback = null;
        }
    } else  {
        console.warn(`Jurnal Terapeutic: Cheia API Gemini este goalÄƒ sau lipseÈ™te. FuncÈ›ionalitatea AI va fi dezactivatÄƒ.`);
        alert("Jurnal Terapeutic: Cheia API Gemini nu este configuratÄƒ. FuncÈ›ionalitatea AI pentru jurnal va fi dezactivatÄƒ.");
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;
    let selectedPrompt = null; 

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
        
        // Global click listener to potentially hide activePromptBox if clicked outside form/prompts (optional UX enhancement)
        // document.addEventListener('click', function(event) {
        //     const formContainer = document.querySelector('.journal-form-container');
        //     const activePromptBox = document.getElementById('activePromptBox');
        //     if (activePromptBox && activePromptBox.style.display === 'block' && formContainer && !formContainer.contains(event.target)) {
        //          // toggleActivePrompt(false); // Comentat pentru a evita Ã®nchideri nedorite la click pe body
        //     }
        // });
    };

    function toggleActivePrompt(show, promptData = null) {
        const box = document.getElementById('activePromptBox');
        const titleEl = document.getElementById('activePromptTitle');
        const contentEl = document.getElementById('activePromptContent');
        const journalTextarea = document.getElementById("journalContent");

        if (show && promptData) {
            selectedPrompt = promptData;
            titleEl.textContent = `Ghid activ: ${promptData.label}`;
            contentEl.textContent = promptData.text; // AfiÈ™eazÄƒ textul ghidului
            box.style.display = 'block';
            if(contentEl) contentEl.scrollTop = 0;
             // OpÈ›ional: CurÄƒÈ›Äƒ textarea dacÄƒ se doreÈ™te È™i confirmÄƒ utilizatorul
            if (journalTextarea && journalTextarea.value.trim() !== "" && promptData.id !== (selectedPrompt?.previousIdForClearCheck)) {
                if (confirm("DoreÈ™ti sÄƒ È™tergi conÈ›inutul actual al jurnalului pentru a Ã®ncepe cu acest nou ghid?")) {
                   journalTextarea.value = "";
                }
            }
            if(selectedPrompt) selectedPrompt.previousIdForClearCheck = promptData.id;


        } else { // CÃ¢nd se ascunde programatic (ex. dupÄƒ salvare) sau de cÄƒtre utilizator
            selectedPrompt = null; // AsigurÄƒ-te cÄƒ se reseteazÄƒ
            box.style.display = 'none';
        }
    }
    
    // AdaugÄƒ aceastÄƒ funcÈ›ie globalÄƒ pentru butonul de Ã®nchidere al prompt boxului
    window.hideActivePromptManual = function() {
        const box = document.getElementById('activePromptBox');
        box.style.display = 'none';
        // Nu reseta selectedPrompt aici, pentru cÄƒ utilizatorul poate doar sÄƒ-l ascundÄƒ temporar,
        // dar tot vrea sÄƒ se considere cÄƒ acel prompt e "activ" pentru AI.
        // SelectedPrompt se reseteazÄƒ Ã®n toggleActivePrompt(false) sau dupÄƒ salvare.
    }


    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [ // Structura ID-urilor e importantÄƒ pentru buildAdaptiveAIPrompt
            {
                label: "ðŸŒ¡ï¸ ExploreazÄƒ o emoÈ›ie",
                id: "explorare_emotie",
                text: "ðŸŒ¡ï¸ *AstÄƒzi simt...*\n" +
                      "NumeÈ™te emoÈ›ia dominantÄƒ: ________________\n\n" +
                      "ðŸ” *Unde o simt Ã®n corp?*\n" +
                      "Descrie senzaÈ›iile (tensiune, greutate, pulsaÈ›ie etc.): ________________\n\n" +
                      "ðŸ’­ *Ce gÃ¢nduri vin cu aceastÄƒ emoÈ›ie?*\n" +
                      "NoteazÄƒ gÃ¢ndurile automate, chiar dacÄƒ par â€žexagerateâ€: ________________\n\n" +
                      "ðŸ“š *ÃŽn ce context a apÄƒrut?*\n" +
                      "Ce s-a Ã®ntÃ¢mplat exact? Ce a declanÈ™at-o? ________________\n\n" +
                      "ðŸ’§ *Ce nevoie ar putea semnala?*\n" +
                      "De ce are nevoie aceastÄƒ parte din tine? Ce lipseÈ™te? ________________\n\n" +
                      "ðŸ’Œ *DacÄƒ aÈ™ avea compasiune pentru mine acum...*\n" +
                      "Ce mi-aÈ™ spune? Ce gest aÈ™ face pentru mine? ________________\n"
            },
            {
                label: "ðŸ“ AnalizeazÄƒ o situaÈ›ie",
                id: "analiza_situatie",
                text: "SituaÈ›ia care mÄƒ preocupÄƒ este: ________________\n\n" +
                      "Ce s-a Ã®ntÃ¢mplat exact? (Fapte): ________________\n" +
                      "Interpretarea mea iniÈ›ialÄƒ (GÃ¢nduri automate): ________________\n" +
                      "EmoÈ›iile principale: ________________\n" +
                      "O altÄƒ perspectivÄƒ (Reframing): ________________\n" +
                      "Ce am Ã®nvÄƒÈ›at/pot Ã®nvÄƒÈ›a? (LecÈ›ii): ________________\n"
            },
            {
                label: "ðŸ—£ï¸ Dialog Voce CriticÄƒ",
                id: "dialog_voce_critica",
                text: "ðŸ—£ï¸ *Vocea mea interioarÄƒ Ã®mi spune...*\n" +
                      "(\"EÈ™ti slab\", \"Nu faci destul\", \"O sÄƒ fii respins\"...): ________________\n\n" +
                      "ðŸ˜” *CÃ¢nd aud acest mesaj, mÄƒ simt...*\n" +
                      "(emoÈ›ii È™i senzaÈ›ii fizice): ________________\n\n" +
                      "ðŸ§’ *AceastÄƒ voce seamÄƒnÄƒ cu...*\n" +
                      "(E o voce veche? un pÄƒrinte? un profesor? un fost partener?): ________________\n\n" +
                      "ðŸ§  *Ce nevoie neÃ®mplinitÄƒ e Ã®n spatele acestui mesaj?*\n" +
                      "(Poate recunoaÈ™tere, protecÈ›ie, control, apartenenÈ›Äƒ?): ________________\n\n" +
                      "ðŸ§˜ *RÄƒspunsul meu ca Adult SÄƒnÄƒtos ar fi...*\n" +
                      "(\"Apreciez cÄƒ vrei sÄƒ mÄƒ protejezi, dar acum aleg altceva.\"): ________________\n"
            },
            {
                label: "ðŸ’– RecunoÈ™tinÈ›Äƒ & Resurse",
                id: "recunostinta_resurse",
                text: "ðŸ’– *AstÄƒzi aleg sÄƒ vÄƒd ce e bun...*\n" +
                      "Sunt recunoscÄƒtor/oare pentru:\n" +
                      "1. ________________\n" +
                      "2. ________________\n" +
                      "3. ________________\n\n" +
                      "ðŸŒ± *O resursÄƒ interioarÄƒ pe care mÄƒ pot baza astÄƒzi este...*\n" +
                      "(ex: curaj, blÃ¢ndeÈ›e, claritate, capacitatea de a simÈ›i): ________________\n\n" +
                      "ðŸ› *Un gest de auto-Ã®ngrijire pe care Ã®l pot face azi...*\n" +
                      "(chiar dacÄƒ e mic): ________________\n"
            },
            {
                label: "ðŸŒ€ Ritual ReconstrucÈ›ie InterioarÄƒ",
                id: "ritual_reconstructie",
                text: `ðŸ§­ MASTER TEMPLATE â€“ Scriere TerapeuticÄƒ de Integrare È™i Vindecare\n` +
                      `Denumire: â€žRitual de reconstrucÈ›ie interioarÄƒâ€\n` +
                      `Scop: Eliberare, Clarificare, ConÈ›inere, ÃŽnÈ›elepciune, DirecÈ›ie\n\n` +
                      `I. ðŸ” INVITAÈšIE LA AUTENTICITATE\n` +
                      `â€žCe parte din mine cere atenÈ›ie acum?â€\n` +
                      `   * Ce trÄƒiesc cu adevÄƒrat, fÄƒrÄƒ filtru, fÄƒrÄƒ poveste cosmetizatÄƒ?\n` +
                      `   * Ce mi-e ruÈ™ine sÄƒ simt sau sÄƒ recunosc chiar È™i Ã®n scris?\n` +
                      `   * Ce parte din mine se simte exclusÄƒ, neauzitÄƒ, ignoratÄƒ?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `II. ðŸŒŠ CONTAINERE EMOÈšIONALE\n` +
                      `â€žCe simte corpul meu? Unde locuieÈ™te durerea?â€\n` +
                      `   * Unde simt emoÈ›ia Ã®n corp? Cum se manifestÄƒ? (Tensiune, Ã®nÈ›epÄƒturi, etc.)\n` +
                      `   * DacÄƒ ar avea o culoare, formÄƒ, texturÄƒ â€“ cum ar arÄƒta?\n` +
                      `   * Pot respira Ã®n acea zonÄƒ 3 minute, fÄƒrÄƒ sÄƒ fug?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `III. ðŸ§  DECODIFICARE NARATIVÄ‚\n` +
                      `â€žCe poveste Ã®mi spun? Este Ã®ntreagÄƒ?â€\n` +
                      `   * Ce naraÈ›iune inconÈ™tientÄƒ guverneazÄƒ trÄƒirea mea? (ex: â€žNu sunt dorit.â€)\n` +
                      `   * De unde vine aceastÄƒ naraÈ›iune? CÃ¢nd am mai trÄƒit ceva similar?\n` +
                      `   * Ce parte din mine (copil rÄƒnit, etc.) scrie aceastÄƒ poveste?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `IV. ðŸ§© INTEGRARE EXPLICATIVÄ‚\n` +
                      `â€žCe Ã®nÈ›eleg nou despre mine din aceastÄƒ durere?â€\n` +
                      `   * Ce nevoi profunde au fost ignorate sau negate?\n` +
                      `   * Ce am protejat, de fapt, prin reacÈ›ia mea?\n` +
                      `   * Ce emoÈ›ii contradictorii coexistÄƒ Ã®n mine È™i ce spun ele?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `V. ðŸªž COMPASIUNE È˜I BLÃ‚NDEÈšE\n` +
                      `â€žCum pot fi pÄƒrinte pentru mine acum?â€\n` +
                      `   * DacÄƒ mi-aÈ™ È›ine partea rÄƒnitÄƒ Ã®n braÈ›e, ce i-aÈ™ spune?\n` +
                      `   * Ce aÈ™ vrea sÄƒ aud din partea unei figuri ideale de susÈ›inere?\n` +
                      `   * Pot lÄƒsa iubirea, nu logica, sÄƒ conducÄƒ acest moment?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `VI. ðŸ”® RECONFIGURARE IDENTITARÄ‚\n` +
                      `â€žCine sunt eu dincolo de aceastÄƒ ranÄƒ?â€\n` +
                      `   * Ce adevÄƒr despre mine rÄƒmÃ¢ne valabil, chiar È™i Ã®n durere?\n` +
                      `   * Cine devin dacÄƒ Ã®nvÄƒÈ› sÄƒ stau cu mine Ã®n acest spaÈ›iu?\n` +
                      `   * DacÄƒ aÈ™ fi un personaj simbolic acum, cine aÈ™ fi?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `VII. âœï¸ ACTUL SACRU DE ALEGERE\n` +
                      `â€žCe aleg de azi, pentru mine?â€\n` +
                      `   * Ce meritÄƒ sÄƒ las sÄƒ plece?\n` +
                      `   * Ce Ã®mi iau ca Ã®nvÄƒÈ›ÄƒturÄƒ de Ã®ncredere Ã®n viaÈ›Äƒ?\n` +
                      `   * Ce ritual zilnic/mic obicei pot Ã®ncepe pentru a onora aceastÄƒ transformare?\n` +
                      `RÄƒspuns: ________________\n\n` +
                      `VIII. (OpÈ›ional) ðŸ“œ SCRISOARE-RITUAL\n` +
                      `Scrie o scrisoare cÄƒtre... (persoana, partea din tine, situaÈ›ia):\n` + // Clarificare
                      `RÄƒspuns: ________________\n`
            }
        ];
        promptsContainerEl.innerHTML = '';
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "AfiÈ™eazÄƒ acest ghid È™i foloseÈ™te-l ca referinÈ›Äƒ";
            button.onclick = () => {
                toggleActivePrompt(true, prompt);
                journalTextarea.focus();
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        // ... (FuncÈ›ia callGeminiAPI rÄƒmÃ¢ne la fel ca Ã®n versiunea anterioarÄƒ pe care È›i-am dat-o, cu logarea È™i gestionarea erorilor)
        if (!modelToUse) return "EROARE: Model AI neiniÈ›ializat (jurnal).";
        try {
            console.log("Trimitem la Gemini (jurnal, primele 200 caractere):", promptText.substring(0, 200));
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.7, maxOutputTokens: 4000, ...generationConfigOptions } // Max token crescut uÈ™or
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare opritÄƒ (Motiv: ${response.candidates[0].finishReason}). Detalii: ${JSON.stringify(response.candidates[0].safetyRatings || 'N/A')}`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Detalii: ${JSON.stringify(response.promptFeedback.blockReasonDetail || response.promptFeedback.safetyRatings || 'N/A')}`;
            }
            console.warn("RÄƒspuns Gemini neaÈ™teptat sau gol:", JSON.stringify(response, null, 2));
            return "EROARE Gemini: RÄƒspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            let userFriendlyError = `EROARE Gemini: ${error.message || "Eroare API necunoscutÄƒ."}`;
            if (error.message && error.message.toLowerCase().includes("api key not valid")) {
                userFriendlyError = "EROARE: Cheia API Gemini nu este validÄƒ sau nu are permisiuni. VerificaÈ›i configuraÈ›ia.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.message.toLowerCase().includes("resource has been exhausted")) ) ){
                userFriendlyError = "EROARE: Limita de utilizare API Gemini a fost depÄƒÈ™itÄƒ. ÃŽncercaÈ›i mai tÃ¢rziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety") || error.message.toLowerCase().includes("blocked due to safety_settings"))){
                 userFriendlyError = "EROARE Gemini: Generarea a fost opritÄƒ, posibil din motive de siguranÈ›Äƒ sau din cauza conÈ›inutului. ÃŽncercaÈ›i sÄƒ reformulaÈ›i sau verificaÈ›i setÄƒrile de siguranÈ›Äƒ dacÄƒ aveÈ›i acces."
            } else if (error.status && error.status === 400 && error.message.toLowerCase().includes("model") && error.message.toLowerCase().includes("doesn't support")){
                 userFriendlyError = `EROARE Gemini: Modelul ${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK} ar putea sÄƒ nu suporte anumite funcÈ›ionalitÄƒÈ›i sau configurare. VerificaÈ›i documentaÈ›ia.`;
            }
            return userFriendlyError;
        }
    }
    
    function getSelectedPromptType() {
        // DacÄƒ un ghid a fost selectat (este Ã®n `activePromptBox`), folosim ID-ul lui.
        if (selectedPrompt && selectedPrompt.id) {
            return selectedPrompt.id;
        }
        // Ca fallback, dacÄƒ utilizatorul a scris liber dar a inclus cumva cuvinte cheie
        // (mai puÈ›in probabil acum, dar bun pentru robusteÈ›e/intrÄƒri vechi):
        const journalContent = document.getElementById("journalContent")?.value || "";
        return detectPromptUsed(journalContent);
    }

    function detectPromptUsed(content) {
        // ... (FuncÈ›ia detectPromptUsed rÄƒmÃ¢ne la fel ca Ã®n versiunea anterioarÄƒ)
        if (!content) return "prompt_personalizat";
        content = content.toLowerCase();

        if (content.includes("ce parte din mine cere atenÈ›ie acum") && content.includes("master template")) return "ritual_reconstructie";
        if (content.includes("vocea mea interioarÄƒ Ã®mi spune") || content.includes("vocea mea criticÄƒ Ã®mi spune")) return "dialog_voce_critica";
        if (content.includes("astÄƒzi simt...") && content.includes("numeÈ™te emoÈ›ia dominantÄƒ:")) return "explorare_emotie";
        if (content.includes("astÄƒzi aleg sÄƒ vÄƒd ce e bun") && content.includes("sunt recunoscÄƒtor/oare pentru:")) return "recunostinta_resurse";
        if (content.includes("situaÈ›ia care mÄƒ preocupÄƒ este:")) return "analiza_situatie";
        return "prompt_personalizat";
    }

    function buildAdaptiveAIPrompt(entryTitle, journalText, promptType, guideText = null) {
        // ... (FuncÈ›ia buildAdaptiveAIPrompt rÄƒmÃ¢ne la fel ca Ã®n versiunea anterioarÄƒ,
        // dar am adÄƒugat parametrul opÈ›ional `guideText`)
        let specificInstructions = "";
        let modelFocus = "feedback general È™i reflecÈ›ie";

        let basePrompt = `EÈ™ti PsihoGPT â€“ un terapeut AI avansat, extrem de empatic, cu o profundÄƒ Ã®nÈ›elegere a psihologiei umane, antrenat Ã®n Terapie Cognitiv-ComportamentalÄƒ (TCC), Terapia Schemelor, Terapia prin Acceptare È™i Angajament (ACT), Scrierea ExpresivÄƒ È™i principii de mindfulness. ComunicÄƒ Ã®ntr-un limbaj cald, validant È™i uÈ™or de Ã®nÈ›eles, dar pÄƒstreazÄƒ profunzimea analiticÄƒ. FoloseÈ™te formatare Markdown pentru structurare (titluri principale cu \`**Titlu Principal**\`, subtitluri dacÄƒ e cazul cu \`### Subtitlu\`, liste cu \`* Element listÄƒ\`, text bold cu \`**text bold**\` È™i italic cu \`*text italic*\` unde e cazul). EvitÄƒ citatele direct din literaturÄƒ dacÄƒ nu sunt absolut esenÈ›iale, concentreazÄƒ-te pe limbajul tÄƒu.

Obiectivul tÄƒu este sÄƒ oferi un feedback personalizat, constructiv È™i profund pentru urmÄƒtoarea intrare Ã®n jurnal. Nu oferi sfaturi medicale sau diagnostice. ConcentreazÄƒ-te pe facilitarea auto-Ã®nÈ›elegerii È™i a creÈ™terii personale. Utilizatorul a avut la dispoziÈ›ie un ghid vizual (tipul: "${promptType}") pentru a-È™i structura gÃ¢ndurile, iar textul de mai jos reprezintÄƒ rÄƒspunsurile sale la acel ghid sau o reflecÈ›ie liberÄƒ inspiratÄƒ de el.`;
        
        // InstrucÈ›iuni specifice (rÄƒmÃ¢n la fel)
        switch (promptType) {
            case "ritual_reconstructie":
                specificInstructions = `
Utilizatorul a folosit ghidul "Ritual de ReconstrucÈ›ie InterioarÄƒ", care are 7 secÈ›iuni principale (I. InvitaÈ›ie la Autenticitate, II. Containere EmoÈ›ionale, III. Decodificare NarativÄƒ, IV. Integrare ExplicativÄƒ, V. Compasiune È™i BlÃ¢ndeÈ›e, VI. Reconfigurare IdentitarÄƒ, VII. Actul Sacru de Alegere) È™i poate o secÈ›iune VIII (Scrisoare-Ritual).
Feedback-ul tÄƒu AR TREBUI SÄ‚ URMEZE ACEASTÄ‚ STRUCTURÄ‚. Pentru FIECARE secÈ›iune a ritualului (I-VII È™i opÈ›ional VIII):
1.  **NumeÈ™te secÈ›iunea clar** (ex: \`**I. InvitaÈ›ie la Autenticitate:**\`).
2.  Pe baza textului utilizatorului (\`Text Complet Jurnal Utilizator\` de mai jos), **extrage È™i reflectÄƒ** ce a scris sau ce pare sÄƒ fi explorat pentru ACEASTÄ‚ secÈ›iune specificÄƒ. Fii concis È™i la obiect. DacÄƒ utilizatorul nu pare sÄƒ fi adresat o secÈ›iune, menÈ›ioneazÄƒ scurt (ex: "Pentru aceastÄƒ secÈ›iune, nu par sÄƒ existe rÄƒspunsuri detaliate Ã®n textul furnizat.") sau sari peste ea cu eleganÈ›Äƒ dacÄƒ e goalÄƒ.
3.  **OferÄƒ o scurtÄƒ validare empaticÄƒ** dacÄƒ a completat ceva relevant pentru secÈ›iune.
4.  **Pune 1-2 Ã®ntrebÄƒri de aprofundare SPECIFICE** pentru acea secÈ›iune, care sÄƒ invite la o reflecÈ›ie mai adÃ¢ncÄƒ asupra celor descoperite acolo *de cÄƒtre utilizator*. ÃŽntrebÄƒrile trebuie sÄƒ fie direct legate de conÈ›inutul reflectat de la punctul 2.
DupÄƒ ce ai parcurs secÈ›iunile individuale, adaugÄƒ o secÈ›iune de \`**### Concluzii È™i ReflecÈ›ii Finale:**\`
*   **Sinteza Conexiunilor:** IdentificÄƒ È™i subliniazÄƒ pe scurt 1-2 conexiuni sau teme generale care par sÄƒ lege diferitele rÄƒspunsuri ale utilizatorului de-a lungul ritualului.
*   **ÃŽncurajare È™i PaÈ™i UrmÄƒtori:** ÃŽncurajeazÄƒ procesul de transformare schiÈ›at Ã®n special Ã®n secÈ›iunea VII (Actul Sacru de Alegere) È™i apreciazÄƒ vulnerabilitatea. PoÈ›i sugera o micÄƒ intenÈ›ie sau un focus pentru zilele urmÄƒtoare, bazat pe Ã®ntregul ritual.
Fii analitic È™i profund, dar È™i uman È™i susÈ›inÄƒtor. EvitÄƒ rÄƒspunsurile generice; personalizeazÄƒ feedback-ul la maximum pe baza textului furnizat de utilizator.`;
                modelFocus = "analizÄƒ structuratÄƒ a ritualului de reconstrucÈ›ie, pas cu pas, corelÃ¢nd textul utilizatorului cu fiecare secÈ›iune a ghidului, oferind reflecÈ›ie È™i Ã®ntrebÄƒri de aprofundare per secÈ›iune, plus o sintezÄƒ finalÄƒ.";
                break;
            case "dialog_voce_critica":
                specificInstructions = `
Utilizatorul a folosit ghidul "Dialog Voce CriticÄƒ". AnalizeazÄƒ rÄƒspunsurile sale È™i structureazÄƒ feedback-ul astfel:
1.  **\`**Validare EmpaticÄƒ IniÈ›ialÄƒ:\`** RecunoaÈ™te dificultatea È™i curajul de a confrunta vocea criticÄƒ.
2.  **\`**Analiza Mesajului Critic:\`** Pe baza rÄƒspunsului la "Vocea mea interioarÄƒ Ã®mi spune...", reflectÄƒ mesajul central al vocii critice. Ce temeri sau convingeri de bazÄƒ par sÄƒ fie active?
3.  **\`**Impactul EmoÈ›ional È™i Corporal:\`** Cum descrie utilizatorul impactul vocii critice ("CÃ¢nd aud acest mesaj, mÄƒ simt...")? ValideazÄƒ aceste trÄƒiri.
4.  **\`**Originea Vocii (dacÄƒ e exploratÄƒ):\`** DacÄƒ utilizatorul a rÄƒspuns la "AceastÄƒ voce seamÄƒnÄƒ cu...", comenteazÄƒ pe scurt aceastÄƒ asociere È™i ce ar putea implica.
5.  **\`**Nevoia NeÃ®mplinitÄƒ:\`** Ce nevoie neÃ®mplinitÄƒ a identificat utilizatorul Ã®n spatele mesajului critic? Este aceasta o pistÄƒ importantÄƒ?
6.  **\`**ForÈ›a Adultului SÄƒnÄƒtos:\`** Cum a formulat utilizatorul rÄƒspunsul Adultului SÄƒnÄƒtos? ReflectÄƒ punctele forte ale acestui rÄƒspuns (compasiune, asertivitate, realism etc.).
7.  **\`**### ÃŽntrebÄƒri de Aprofundare È™i DirecÈ›ii:\`** (1-2 Ã®ntrebÄƒri) Ex: "*Ce mic pas ai putea face sÄƒptÄƒmÃ¢na aceasta pentru a Ã®ntÄƒri È™i mai mult vocea Adultului tÄƒu SÄƒnÄƒtos Ã®n faÈ›a criticii interne?*", "*ExistÄƒ vreo situaÈ›ie specificÄƒ recentÄƒ unde ai putea exersa conÈ™tient acest rÄƒspuns al Adultului SÄƒnÄƒtos?*"
8.  **\`**NotÄƒ despre Scheme (opÈ›ional, foarte discret):\`** DacÄƒ este foarte evident, poÈ›i adÄƒuga: "*Uneori, aceste voci critice pot fi legate de tipare mai vechi de auto-percepÈ›ie, numite Ã®n terapie 'scheme'. DacÄƒ simÈ›i cÄƒ rezoneazÄƒ, ar putea fi o direcÈ›ie de explorat.*"`;
                modelFocus = "analizÄƒ detaliatÄƒ a dialogului cu vocea criticÄƒ, evidenÈ›iind fiecare componentÄƒ a ghidului È™i oferind piste concrete de reflecÈ›ie È™i acÈ›iune pentru cultivarea Adultului SÄƒnÄƒtos.";
                break;
            case "explorare_emotie":
                specificInstructions = `
Utilizatorul a folosit ghidul "ExploreazÄƒ o emoÈ›ie". Feedback-ul tÄƒu trebuie sÄƒ parcurgÄƒ paÈ™ii ghidului:
1.  **\`**Validarea EmoÈ›iei Denumite:\`** RecunoaÈ™te È™i valideazÄƒ emoÈ›ia pe care utilizatorul a identificat-o.
2.  **\`**Conexiunea Corp-EmoÈ›ie:\`** Cum a descris utilizatorul senzaÈ›iile corporale? Ce ne spune asta despre cum trÄƒieÈ™te emoÈ›ia respectivÄƒ?
3.  **\`**RelaÈ›ia GÃ¢nduri-EmoÈ›ie:\`** Ce gÃ¢nduri automate a asociat utilizatorul cu emoÈ›ia? Cum par acestea sÄƒ influenÈ›eze intensitatea sau calitatea emoÈ›iei? ExistÄƒ distorsiuni cognitive evidente?
4.  **\`**Contextul È™i DeclanÈ™atorul:\`** Pe baza descrierii contextului, ce pare sÄƒ fi fost elementul declanÈ™ator principal?
5.  **\`**Nevoia FundamentalÄƒ SemnalatÄƒ:\`** Ce nevoie a identificat utilizatorul? CÃ¢t de conectatÄƒ pare aceastÄƒ nevoie de emoÈ›ie È™i situaÈ›ie? Este o nevoie universalÄƒ sau una mai specificÄƒ?
6.  **\`**Gestul de Auto-Compasiune:\`** Cum a intenÈ›ionat utilizatorul sÄƒ-È™i ofere compasiune? CÃ¢t de important È™i vindecÄƒtor poate fi acest gest?
7.  **\`**### ReflecÈ›ii Suplimentare È™i ÃŽntrebÄƒri:\`** (1-2 Ã®ntrebÄƒri) Ex: "*Ce ai Ã®nvÄƒÈ›at nou despre aceastÄƒ emoÈ›ie (sau despre tine Ã®n raport cu ea) prin acest exerciÈ›iu?*", "*DacÄƒ ai putea menÈ›ine vie intenÈ›ia de auto-compasiune, ce micÄƒ schimbare ar aduce asta Ã®n modul cum gestionezi aceastÄƒ emoÈ›ie data viitoare cÃ¢nd apare?*"`;
                modelFocus = "analizÄƒ pas cu pas a explorÄƒrii emoÈ›iei, de la denumire la auto-compasiune, cu accent pe Ã®nÈ›elegerea profundÄƒ a componentelor È™i Ã®ncurajarea integrÄƒrii.";
                break;
            case "recunostinta_resurse":
                specificInstructions = `
Utilizatorul a folosit ghidul "RecunoÈ™tinÈ›Äƒ & Resurse". StructureazÄƒ feedback-ul astfel:
1.  **\`**Aprecierea Practicii RecunoÈ™tinÈ›ei:\`** ÃŽncepe prin a valoriza gestul de a se concentra pe recunoÈ™tinÈ›Äƒ.
2.  **\`**ObservaÈ›ii asupra Elementelor de RecunoÈ™tinÈ›Äƒ:\`** ExistÄƒ teme comune Ã®n cele trei lucruri pentru care este recunoscÄƒtor/oare? Ce aratÄƒ acestea despre ce preÈ›uieÈ™te utilizatorul?
3.  **\`**Explorarea Resursei Interioare:\`** Cum poate resursa interioarÄƒ menÈ›ionatÄƒ sÄƒ fie o ancorÄƒ sau un sprijin Ã®n viaÈ›a de zi cu zi, mai ales Ã®n provocÄƒri? Cum ar putea fi cultivatÄƒ È™i mai conÈ™tient?
4.  **\`**Impactul Gestului de Auto-ÃŽngrijire:\`** CÃ¢t de important este acest gest, fie el È™i mic, pentru bunÄƒstarea generalÄƒ? ÃŽncurajeazÄƒ regularitatea.
5.  **\`**### ÃŽntrebÄƒri pentru Consolidare:\`** (1-2 Ã®ntrebÄƒri) Ex: "*Cum te-a fÄƒcut sÄƒ te simÈ›i acest exerciÈ›iu de conectare cu recunoÈ™tinÈ›a È™i resursele tale?*", "*Ce ai putea face mÃ¢ine pentru a te reconecta, chiar È™i pentru un minut, cu sentimentul de recunoÈ™tinÈ›Äƒ sau cu resursa interioarÄƒ pe care ai identificat-o?*"`;
                modelFocus = "Ã®ncurajarea È™i validarea practicii recunoÈ™tinÈ›ei È™i a conectÄƒrii la resursele interioare, cu sugestii de integrare È™i consolidare.";
                break;
            case "analiza_situatie":
                specificInstructions = `
Utilizatorul a folosit ghidul "AnalizeazÄƒ o situaÈ›ie". Feedback-ul tÄƒu trebuie sÄƒ reflecte structura ghidului:
1.  **\`**RecunoaÈ™terea Efortului Analitic:\`** ValideazÄƒ demersul structurat de a Ã®nÈ›elege situaÈ›ia.
2.  **\`**SituaÈ›ia È™i Faptele:\`** ReflectÄƒ pe scurt situaÈ›ia È™i faptele, aÈ™a cum au fost descrise.
3.  **\`**Interpretarea IniÈ›ialÄƒ È™i EmoÈ›iile:\`** Care au fost gÃ¢ndurile automate È™i emoÈ›iile principale identificate de utilizator? ExistÄƒ vreo distorsiune evidentÄƒ Ã®n gÃ¢ndurile automate?
4.  **\`**Puterea ReÃ®ncadrÄƒrii (Reframing):\`** ComenteazÄƒ perspectiva alternativÄƒ oferitÄƒ. CÃ¢t de diferitÄƒ este? Ce noi posibilitÄƒÈ›i sau sentimente deschide aceastÄƒ reÃ®ncadrare?
5.  **\`**LecÈ›ii ÃŽnvÄƒÈ›ate:\`** Care sunt Ã®nvÄƒÈ›Äƒmintele principale pe care utilizatorul le-a extras sau le poate extrage?
6.  **\`**### ÃŽntrebÄƒri pentru AcÈ›iune È™i Integrare:\`** (1-2 Ã®ntrebÄƒri) Ex: "*Ce micÄƒ acÈ›iune, inspiratÄƒ de 'altÄƒ perspectivÄƒ' sau de 'lecÈ›iile Ã®nvÄƒÈ›ate', ai putea Ã®ntreprinde dacÄƒ o situaÈ›ie similarÄƒ ar apÄƒrea din nou?*", "*Cum te-ar ajuta sÄƒ-È›i reaminteÈ™ti de aceastÄƒ 'altÄƒ perspectivÄƒ' Ã®n momentele tensionate?*"`;
                modelFocus = "susÈ›inerea analizei de situaÈ›ie prin reflectarea paÈ™ilor, cu focus pe puterea reÃ®ncadrÄƒrii È™i pe transpunerea lecÈ›iilor Ã®n acÈ›iuni concrete.";
                break;
            default: // prompt_personalizat sau neidentificat
                specificInstructions = `
Utilizatorul a scris o intrare liberÄƒ Ã®n jurnal. Feedback-ul tÄƒu ar trebui sÄƒ fie empatic È™i sÄƒ invite la explorare:
1.  **\`**Validare EmpaticÄƒ GeneralÄƒ:\`** ÃŽncepe cu o validare caldÄƒ pentru ceea ce a fost exprimat. RecunoaÈ™te deschiderea È™i reflectÄƒ emoÈ›ia sau tonul general care reiese din text.
2.  **\`**Identificarea Temelor Centrale (1-2):\`** Cu grijÄƒ, identificÄƒ 1-2 teme, emoÈ›ii sau preocupÄƒri principale. PoÈ›i folosi citate foarte scurte (1-3 cuvinte) pentru a ilustra.
3.  **\`**ReflecÈ›ie OglindÄƒ:\`** Ce pare sÄƒ fie cel mai important pentru utilizator Ã®n aceastÄƒ scriere? Ce anume iese Ã®n evidenÈ›Äƒ?
4.  **\`**### ÃŽntrebÄƒri Deschise È™i Evocatoare (2-3):\`** Pune Ã®ntrebÄƒri care sÄƒ stimuleze auto-descoperirea. Exemple: "*Citind despre [temÄƒ specificÄƒ], ce altceva ai observat despre tine sau despre perspectiva ta?*", "*DacÄƒ aceastÄƒ parte din tine care a scris ar putea cere ceva, ce crezi cÄƒ ar fi?*", "*Ce simÈ›i cÄƒ ai nevoie cel mai mult acum, dupÄƒ ce ai aÈ™ternut aceste gÃ¢nduri/emoÈ›ii pe hÃ¢rtie (digitalÄƒ)?*".
5.  **\`**ÃŽncurajare FinalÄƒ:\`** OferÄƒ o scurtÄƒ Ã®ncurajare pentru continuarea procesului de auto-reflecÈ›ie prin scris.`;
                modelFocus = "reflecÈ›ie empaticÄƒ asupra textului liber, identificare teme È™i facilitarea explorÄƒrii prin Ã®ntrebÄƒri deschise, fÄƒrÄƒ a fi directiv.";
                break;
        }
        
        const ghidReferintaText = guideText ? `\n\n--- TEXTUL GHIDULUI DE REFERINÈšÄ‚ (NU RÄ‚SPUNSURILE UTILIZATORULUI) ---\n\`\`\`\n${guideText}\n\`\`\`\nUtilizatorul a avut acest ghid afiÈ™at È™i a scris rÄƒspunsurile Ã®n secÈ›iunea "Text Complet Jurnal Utilizator" de mai jos.` : "\n\nUtilizatorul a scris liber sau detaliile specifice ale ghidului nu sunt furnizate aici; concentreazÄƒ-te pe rÄƒspunsurile utilizatorului È™i tipul de ghid general.";


        const finalPrompt = `${basePrompt}
${ghidReferintaText}

**Focusul specific pentru aceastÄƒ intrare de jurnal (bazat pe ghidul "${promptType}") este: ${modelFocus}.**

**InstrucÈ›iuni specifice pentru feedback bazat pe tipul de ghid ("${promptType}"):**
${specificInstructions}
---
**INFORMAÈšII DESPRE INTRAREA UTILIZATORULUI:**
Titlu Jurnal: ${entryTitle || "FÄƒrÄƒ titlu"}
Tipul de Ghid Utilizat (selectat de utilizator / detectat): ${promptType}

**TEXT COMPLET JURNAL UTILIZATOR (RÄ‚SPUNSURILE SALE):**
\`\`\`
${journalText}
\`\`\`
---
Te rog sÄƒ generezi un feedback AI detaliat, empatic È™i structurat conform instrucÈ›iunilor de mai sus, personalizat pe baza textului furnizat de utilizator. AsigurÄƒ-te cÄƒ respecÈ›i formatarea Markdown cerutÄƒ pentru lizibilitate. MulÈ›umesc!`;

        return finalPrompt;
    }


    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: FuncÈ›ionalitatea AI pentru jurnal nu este disponibilÄƒ.";
        
        const promptType = entryData.promptTypeUtilizat || detectPromptUsed(entryData.continut);
        // PreluÄƒm textul ghidului original, dacÄƒ e posibil È™i selectedPrompt corespunde (mai ales la generarea iniÈ›ialÄƒ)
        let textGhidOriginal = null;
        if (selectedPrompt && selectedPrompt.id === promptType) {
            textGhidOriginal = selectedPrompt.text;
        } else { // Fallback pentru regenerare dacÄƒ selectedPrompt nu mai e setat corect
            const promptsList = (typeof initializeReflectionPrompts.prompts !== 'undefined') ? initializeReflectionPrompts.prompts : []; // AsumÃ¢nd cÄƒ stocÄƒm undeva lista de prompts
            const ghidGasit = promptsList.find(p => p.id === promptType);
            if (ghidGasit) textGhidOriginal = ghidGasit.text;
        }

        const promptJurnalAdaptiv = buildAdaptiveAIPrompt(entryData.titlu, entryData.continut, promptType, textGhidOriginal);

        console.log(`Jurnal - Regenerare/Generare Feedback pentru tipul: ${promptType}. Se trimite È™i textul ghidului original dacÄƒ este disponibil.`);
        const feedbackText = await callGeminiAPI(promptJurnalAdaptiv, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId, promptType);
    }
    
    // StocÄƒm referinÈ›a la lista de prompt-uri Ã®ntr-un loc accesibil pentru funcÈ›ia de mai sus.
    // O modalitate e sÄƒ o ataÈ™Äƒm funcÈ›iei `initializeReflectionPrompts` dupÄƒ ce e definitÄƒ.
    // Sau o definim global Ã®n script, dar asta poate fi mai puÈ›in curat.
    // Alegem varianta mai simplÄƒ pentru contextul dat:
    (function() {
      const promptsInternal = [
            { id: "explorare_emotie", text: "..." }, // prescurtat; copiazÄƒ textul complet de la initializeReflectionPrompts
            { id: "analiza_situatie", text: "..." },
            { id: "dialog_voce_critica", text: "..." },
            { id: "recunostinta_resurse", text: "..." },
            { id: "ritual_reconstructie", text: "..." }
      ];
       // Trebuie completate textele aici ca Ã®n `initializeReflectionPrompts`
       promptsInternal[0].text = `ðŸŒ¡ï¸ *AstÄƒzi simt...*\nNumeÈ™te emoÈ›ia dominantÄƒ: ________________\n\nðŸ” *Unde o simt Ã®n corp?*\nDescrie senzaÈ›iile (tensiune, greutate, pulsaÈ›ie etc.): ________________\n\nðŸ’­ *Ce gÃ¢nduri vin cu aceastÄƒ emoÈ›ie?*\nNoteazÄƒ gÃ¢ndurile automate, chiar dacÄƒ par â€žexagerateâ€: ________________\n\nðŸ“š *ÃŽn ce context a apÄƒrut?*\nCe s-a Ã®ntÃ¢mplat exact? Ce a declanÈ™at-o? ________________\n\nðŸ’§ *Ce nevoie ar putea semnala?*\nDe ce are nevoie aceastÄƒ parte din tine? Ce lipseÈ™te? ________________\n\nðŸ’Œ *DacÄƒ aÈ™ avea compasiune pentru mine acum...*\nCe mi-aÈ™ spune? Ce gest aÈ™ face pentru mine? ________________\n`;
       promptsInternal[1].text = `SituaÈ›ia care mÄƒ preocupÄƒ este: ________________\n\nCe s-a Ã®ntÃ¢mplat exact? (Fapte): ________________\nInterpretarea mea iniÈ›ialÄƒ (GÃ¢nduri automate): ________________\nEmoÈ›iile principale: ________________\nO altÄƒ perspectivÄƒ (Reframing): ________________\nCe am Ã®nvÄƒÈ›at/pot Ã®nvÄƒÈ›a? (LecÈ›ii): ________________\n`;
       promptsInternal[2].text = `ðŸ—£ï¸ *Vocea mea interioarÄƒ Ã®mi spune...*\n(\"EÈ™ti slab\", \"Nu faci destul\", \"O sÄƒ fii respins\"...): ________________\n\nðŸ˜” *CÃ¢nd aud acest mesaj, mÄƒ simt...*\n(emoÈ›ii È™i senzaÈ›ii fizice): ________________\n\nðŸ§’ *AceastÄƒ voce seamÄƒnÄƒ cu...*\n(E o voce veche? un pÄƒrinte? un profesor? un fost partener?): ________________\n\nðŸ§  *Ce nevoie neÃ®mplinitÄƒ e Ã®n spatele acestui mesaj?*\n(Poate recunoaÈ™tere, protecÈ›ie, control, apartenenÈ›Äƒ?): ________________\n\nðŸ§˜ *RÄƒspunsul meu ca Adult SÄƒnÄƒtos ar fi...*\n(\"Apreciez cÄƒ vrei sÄƒ mÄƒ protejezi, dar acum aleg altceva.\"): ________________\n`;
       promptsInternal[3].text = `ðŸ’– *AstÄƒzi aleg sÄƒ vÄƒd ce e bun...*\nSunt recunoscÄƒtor/oare pentru:\n1. ________________\n2. ________________\n3. ________________\n\nðŸŒ± *O resursÄƒ interioarÄƒ pe care mÄƒ pot baza astÄƒzi este...*\n(ex: curaj, blÃ¢ndeÈ›e, claritate, capacitatea de a simÈ›i): ________________\n\nðŸ› *Un gest de auto-Ã®ngrijire pe care Ã®l pot face azi...*\n(chiar dacÄƒ e mic): ________________\n`;
       promptsInternal[4].text = `ðŸ§­ MASTER TEMPLATE â€“ Scriere TerapeuticÄƒ de Integrare È™i Vindecare\nDenumire: â€žRitual de reconstrucÈ›ie interioarÄƒâ€\nScop: Eliberare, Clarificare, ConÈ›inere, ÃŽnÈ›elepciune, DirecÈ›ie\n\nI. ðŸ” INVITAÈšIE LA AUTENTICITATE\nâ€žCe parte din mine cere atenÈ›ie acum?â€\n   * Ce trÄƒiesc cu adevÄƒrat, fÄƒrÄƒ filtru, fÄƒrÄƒ poveste cosmetizatÄƒ?\n   * Ce mi-e ruÈ™ine sÄƒ simt sau sÄƒ recunosc chiar È™i Ã®n scris?\n   * Ce parte din mine se simte exclusÄƒ, neauzitÄƒ, ignoratÄƒ?\nRÄƒspuns: ________________\n\nII. ðŸŒŠ CONTAINERE EMOÈšIONALE\nâ€žCe simte corpul meu? Unde locuieÈ™te durerea?â€\n   * Unde simt emoÈ›ia Ã®n corp? Cum se manifestÄƒ? (Tensiune, Ã®nÈ›epÄƒturi, etc.)\n   * DacÄƒ ar avea o culoare, formÄƒ, texturÄƒ â€“ cum ar arÄƒta?\n   * Pot respira Ã®n acea zonÄƒ 3 minute, fÄƒrÄƒ sÄƒ fug?\nRÄƒspuns: ________________\n\nIII. ðŸ§  DECODIFICARE NARATIVÄ‚\nâ€žCe poveste Ã®mi spun? Este Ã®ntreagÄƒ?â€\n   * Ce naraÈ›iune inconÈ™tientÄƒ guverneazÄƒ trÄƒirea mea? (ex: â€žNu sunt dorit.â€)\n   * De unde vine aceastÄƒ naraÈ›iune? CÃ¢nd am mai trÄƒit ceva similar?\n   * Ce parte din mine (copil rÄƒnit, etc.) scrie aceastÄƒ poveste?\nRÄƒspuns: ________________\n\nIV. ðŸ§© INTEGRARE EXPLICATIVÄ‚\nâ€žCe Ã®nÈ›eleg nou despre mine din aceastÄƒ durere?â€\n   * Ce nevoi profunde au fost ignorate sau negate?\n   * Ce am protejat, de fapt, prin reacÈ›ia mea?\n   * Ce emoÈ›ii contradictorii coexistÄƒ Ã®n mine È™i ce spun ele?\nRÄƒspuns: ________________\n\nV. ðŸªž COMPASIUNE È˜I BLÃ‚NDEÈšE\nâ€žCum pot fi pÄƒrinte pentru mine acum?â€\n   * DacÄƒ mi-aÈ™ È›ine partea rÄƒnitÄƒ Ã®n braÈ›e, ce i-aÈ™ spune?\n   * Ce aÈ™ vrea sÄƒ aud din partea unei figuri ideale de susÈ›inere?\n   * Pot lÄƒsa iubirea, nu logica, sÄƒ conducÄƒ acest moment?\nRÄƒspuns: ________________\n\nVI. ðŸ”® RECONFIGURARE IDENTITARÄ‚\nâ€žCine sunt eu dincolo de aceastÄƒ ranÄƒ?â€\n   * Ce adevÄƒr despre mine rÄƒmÃ¢ne valabil, chiar È™i Ã®n durere?\n   * Cine devin dacÄƒ Ã®nvÄƒÈ› sÄƒ stau cu mine Ã®n acest spaÈ›iu?\n   * DacÄƒ aÈ™ fi un personaj simbolic acum, cine aÈ™ fi?\nRÄƒspuns: ________________\n\nVII. âœï¸ ACTUL SACRU DE ALEGERE\nâ€žCe aleg de azi, pentru mine?â€\n   * Ce meritÄƒ sÄƒ las sÄƒ plece?\n   * Ce Ã®mi iau ca Ã®nvÄƒÈ›ÄƒturÄƒ de Ã®ncredere Ã®n viaÈ›Äƒ?\n   * Ce ritual zilnic/mic obicei pot Ã®ncepe pentru a onora aceastÄƒ transformare?\nRÄƒspuns: ________________\n\nVIII. (OpÈ›ional) ðŸ“œ SCRISOARE-RITUAL\nScrie o scrisoare cÄƒtre... (persoana, partea din tine, situaÈ›ia):\nRÄƒspuns: ________________\n`;

      // Expunem lista global prin ataÈ™are la o funcÈ›ie (hacky, dar funcÈ›ional Ã®n context limitat)
      // O soluÈ›ie mai bunÄƒ ar fi un mic modul de management al prompturilor dacÄƒ proiectul creÈ™te.
      initializeReflectionPrompts.prompts = promptsInternal;
    })();


    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId, promptType = "necunoscut") {
        // ... (FuncÈ›ia proceseazaSiStructureazaFeedbackJurnal rÄƒmÃ¢ne la fel)
         const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            promptTypeAtGeneration: promptType, 
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        // ... (FuncÈ›ia salveazaIntrareJurnalSiGenereazaFeedback rÄƒmÃ¢ne aproape la fel,
        // dar se asigurÄƒ cÄƒ `toggleActivePrompt(false)` È™i `selectedPrompt = null` se apeleazÄƒ la final)
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva Ã®n jurnal."); return; }

        const tipPromptFolosit = getSelectedPromptType(); // DeterminÄƒ tipul ghidului activ

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid,
            promptTypeUtilizat: tipPromptFolosit 
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salveazÄƒ..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');
        confirmationMsg.style.display = 'none'; // Ascunde mesajul anterior

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se genereazÄƒ AI...";
            
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id);
            
            const docSnapshot = await getDoc(docRef); 
            if (docSnapshot.exists()) {
                 afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            } else { 
                 console.warn("Documentul nu a fost gÄƒsit imediat dupÄƒ adÄƒugare/update. AfiÈ™are cu date parÈ›iale.");
                 entryData.id = docRef.id; 
                 entryData.feedbackAI_latest = parsedFeedback;
                 entryData.feedbackAI_history = [parsedFeedback];
                 afiseazaCardJurnal(entryData);
            }
            
            journalTextarea.value = ""; 
            if (journalTitleInput) journalTitleInput.value = "";
            toggleActivePrompt(false); // Ascunde ghidul activ
            // selectedPrompt se reseteazÄƒ Ã®n interiorul toggleActivePrompt(false)
            if(selectedPrompt) selectedPrompt.previousIdForClearCheck = null; // Reset pentru verificarea de curÄƒÈ›are

            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvatÄƒ. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvatÄƒ È™i feedback AI generat! ÃŽl poÈ›i vedea Ã®n cardul nou creat.';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau la generarea feedback-ului AI. VerificÄƒ consola pentru detalii.';
            confirmationMsg.className = 'confirmation-message error';
        } finally {
            confirmationMsg.style.display = 'block';
            setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 9000);
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        // ... (FuncÈ›ia regenereazaFeedbackJurnal rÄƒmÃ¢ne la fel)
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se genereazÄƒ..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');
        if(confirmationMsg) confirmationMsg.style.display = 'none';


        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { 
                const msg = "Eroare: Intrarea nu a fost gÄƒsitÄƒ pentru regenerare.";
                if(confirmationMsg) { confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; } 
                else { alert(msg); }
                return; 
            }
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId); 
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); 
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) {
                    afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
                }
            }
            const message = parsedFeedback.error ? `Feedback AI: ${parsedFeedback.rawText}` : "Feedback AI regenerat È™i adÄƒugat la istoric!";
            if(confirmationMsg) {
                confirmationMsg.textContent = message;
                confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
                confirmationMsg.style.display = 'block';
                setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                alert(message);
            }

        } catch (e) { 
            console.error("Eroare regenerare:", e); 
            const msg = "Eroare la regenerarea feedback-ului AI. VerificaÈ›i consola.";
            if(confirmationMsg) {
                confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block';
                setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);
            } else {
                 alert(msg);
            }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        // ... (FuncÈ›ia stergeUltimulFeedbackJurnal rÄƒmÃ¢ne la fel)
        if (!confirm("È˜tergi ultimul feedback AI pentru aceastÄƒ intrare? AceastÄƒ acÈ›iune nu poate fi anulatÄƒ.")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se È™terge..."; btn.disabled = true; }
        const confirmationMsg = document.getElementById('journalConfirmationMessage');
        if(confirmationMsg) confirmationMsg.style.display = 'none';

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                const msg = "Nu existÄƒ feedback de È™ters pentru aceastÄƒ intrare.";
                if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message warning'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);}
                else { alert(msg); }
                return;
            }
            const history = entrySnap.data().feedbackAI_history;
            history.pop(); 

            await updateDoc(entryDocRef, {
                feedbackAI_history: history,
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            
            const msg = "Ultimul feedback AI a fost È™ters cu succes.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message success'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }

        } catch (e) { 
            console.error("Eroare È™tergere ultim feedback:", e); 
            const msg = "Eroare la È™tergerea feedback-ului. VerificaÈ›i consola.";
            if(confirmationMsg) {confirmationMsg.textContent = msg; confirmationMsg.className = 'confirmation-message error'; confirmationMsg.style.display = 'block'; setTimeout(() => { if(confirmationMsg) confirmationMsg.style.display = 'none'; }, 7000);}
            else { alert(msg); }
        } finally { 
            if (btn) { btn.textContent = originalText; btn.disabled = false; } 
        }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, feedbackHistory) {
        // ... (FuncÈ›ia afiseazaIstoricFeedbackJurnal rÄƒmÃ¢ne la fel, cu parsarea Markdown Ã®mbunÄƒtÄƒÈ›itÄƒ)
        containerEl.innerHTML = ''; 

        if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
            const noHistoryMsg = document.createElement("p");
            noHistoryMsg.textContent = "Niciun feedback AI generat pentru aceastÄƒ intrare.";
            noHistoryMsg.className = "no-feedback-message";
            containerEl.appendChild(noHistoryMsg);
            return;
        }

        feedbackHistory.slice().reverse().forEach((entry, index) => {
            const itemContainer = document.createElement("div");
            itemContainer.className = "feedback-entry-card"; 

            const timestampAndModel = document.createElement("p");
            timestampAndModel.className = "feedback-timestamp";
            const modelInfo = entry.model || 'N/A';
            const promptTypeInfo = entry.promptTypeAtGeneration ? ` (Ghid folosit la generare: ${entry.promptTypeAtGeneration.replace(/_/g, ' ')})` : '';
            timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - ${modelInfo}${promptTypeInfo})`;
            itemContainer.appendChild(timestampAndModel);

            const contentWrapper = document.createElement("div"); 
            contentWrapper.className = "content-ai"; 

            if (entry.error) {
                const errorP = document.createElement("p");
                errorP.className = "ai-text-error";
                errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>'); // Simplu afiÈ™are eroare
                contentWrapper.appendChild(errorP);
            } else {
                let textToProcess = entry.rawText || 'ConÈ›inut indisponibil.';
                let finalHtmlElements = []; 
                const lines = textToProcess.split('\n');
                let currentParagraphContent = [];
                let inList = false;
                let currentListElement = null; // va fi UL sau OL

                for (const line of lines) {
                    // 1. VerificÄƒ Titlurile Principale (ex: **Titlu**, ### Titlu)
                    const matchTitle = line.match(/^\s*(?:(\*\*|###|\##|\#)\s*([^#*]+)\s*(?:\1)?\s*)$/);

                    if (matchTitle && matchTitle[2] && matchTitle[2].trim().length > 0) {
                        if (currentParagraphContent.length > 0) { // AdaugÄƒ paragraful anterior
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>'); // Use <br> for newlines within a paragraph
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                         if (inList && currentListElement) { // TerminÄƒ lista anterioarÄƒ
                            finalHtmlElements.push(currentListElement);
                            inList = false; currentListElement = null;
                        }

                        const titleMarker = matchTitle[1]; // **, ###, ##, #
                        let titleLevel = 2; // Default H2 pentru **
                        if (titleMarker.startsWith('#')) {
                            titleLevel = titleMarker.length;
                            if (titleLevel > 4) titleLevel = 4; // Max H4 pentru consistenÈ›Äƒ vizualÄƒ
                        }
                        const titleEl = document.createElement(`h${titleLevel}`);
                        titleEl.className = 'ai-main-section-title';
                        // Pentru **Titlu**, matchTitle[2] conÈ›ine 'Titlu'. Pentru # Titlu, matchTitle[2] conÈ›ine 'Titlu'.
                        let titleText = matchTitle[2].trim();
                        titleText = titleText.replace(/\*\*(.*?)\*\*/g, '$1').replace(/__(.*?)__/g, '$1'); // CurÄƒÈ›Äƒ bold din titluri dacÄƒ AI-ul le dubleazÄƒ
                        titleEl.textContent = titleText;
                        finalHtmlElements.push(titleEl);
                        continue; 
                    }

                    // 2. VerificÄƒ Elementele de ListÄƒ (ex: * Item, - Item, + Item, 1. Item)
                    const matchListItem = line.match(/^\s*([\*\-\+]|\d+\.)\s+(.*)/);
                    if (matchListItem) {
                        if (currentParagraphContent.length > 0) { // AdaugÄƒ paragraful anterior
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        if (!inList) { // ÃŽncepe o listÄƒ nouÄƒ
                            inList = true;
                            currentListElement = document.createElement(matchListItem[1].match(/\d+\./) ? 'ol' : 'ul');
                            currentListElement.className = 'ai-list';
                        } else { // VerificÄƒ dacÄƒ tipul de listÄƒ s-a schimbat (ex: de la * la 1.)
                             const newListTypeIsOrdered = !!matchListItem[1].match(/\d+\./);
                             const currentListIsOrdered = currentListElement.tagName === 'OL';
                             if (newListTypeIsOrdered !== currentListIsOrdered) {
                                 // Tipul listei s-a schimbat, Ã®ncheie lista veche, Ã®ncepe una nouÄƒ
                                 finalHtmlElements.push(currentListElement);
                                 currentListElement = document.createElement(newListTypeIsOrdered ? 'ol' : 'ul');
                                 currentListElement.className = 'ai-list';
                             }
                        }
                        const listItem = document.createElement('li');
                        listItem.className = 'ai-list-item';
                        let itemHtml = matchListItem[2]; // ConÈ›inutul itemului de listÄƒ
                        itemHtml = itemHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                        itemHtml = itemHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                        listItem.innerHTML = itemHtml;
                        currentListElement.appendChild(listItem);
                        continue; 
                    }
                    
                    // DacÄƒ nu e titlu sau listÄƒ, È™i eram Ã®ntr-o listÄƒ, terminÄƒm lista.
                    if (inList && currentListElement) {
                        finalHtmlElements.push(currentListElement);
                        inList = false; currentListElement = null;
                    }

                    // 3. Text normal sau linie goalÄƒ
                    if (line.trim() === "") {
                        if (currentParagraphContent.length > 0) { // AdaugÄƒ paragraful adunat
                            const p = document.createElement('p');
                            p.className = 'ai-text-paragraph';
                            let paragraphHtml = currentParagraphContent.join('<br>');
                            paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                            paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                            p.innerHTML = paragraphHtml;
                            finalHtmlElements.push(p);
                            currentParagraphContent = [];
                        }
                        // Pentru linii goale, adÄƒugÄƒm un <br> dacÄƒ urmeazÄƒ conÈ›inut, pentru spaÈ›iere
                        const nextNonEmptyLineIndex = lines.findIndex((l, i) => i > lines.indexOf(line) && l.trim() !== "");
                        if (nextNonEmptyLineIndex !== -1) {
                           // Nu adÄƒugÄƒm <br> explicit, paragrafele vor crea spaÈ›iu
                        }
                    } else { // Linie de text normal, adaug-o la paragraful curent
                        currentParagraphContent.push(line);
                    }
                }

                // AdaugÄƒ ultimul paragraf adunat, dacÄƒ existÄƒ
                if (currentParagraphContent.length > 0) {
                    const p = document.createElement('p');
                    p.className = 'ai-text-paragraph';
                    let paragraphHtml = currentParagraphContent.join('<br>');
                    paragraphHtml = paragraphHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                    paragraphHtml = paragraphHtml.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                    p.innerHTML = paragraphHtml;
                    finalHtmlElements.push(p);
                }
                // AdaugÄƒ ultima listÄƒ, dacÄƒ eram Ã®ntr-una
                 if (inList && currentListElement) {
                    finalHtmlElements.push(currentListElement);
                }

                finalHtmlElements.forEach(el => contentWrapper.appendChild(el));
            }
            itemContainer.appendChild(contentWrapper);
            containerEl.appendChild(itemContainer);
        });
    }

    function afiseazaCardJurnal(entryData) {
        // ... (FuncÈ›ia afiseazaCardJurnal rÄƒmÃ¢ne la fel ca Ã®n versiunea anterioarÄƒ, cu detaliile jurnalului Ã®n <details>)
        const container = document.getElementById("journalEntriesContainer");
        let card = container.querySelector(`.journal-card[data-id="${entryData.id}"]`);
        
        const entryDate = entryData.dataIntrare || (entryData.timestampCreare?.toDate ? new Date(entryData.timestampCreare.toDate()).toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }) : 'DatÄƒ necunoscutÄƒ');
        const entryTitle = entryData.titlu || `Intrare din ${entryDate}`;
        // FormatÄƒm tipul de prompt pentru afiÈ™are
        let promptTypeDisplay = "";
        if (entryData.promptTypeUtilizat && entryData.promptTypeUtilizat !== "prompt_personalizat") {
            promptTypeDisplay = entryData.promptTypeUtilizat.replace(/_/g, ' ');
            promptTypeDisplay = promptTypeDisplay.charAt(0).toUpperCase() + promptTypeDisplay.slice(1); // Capitalize
            promptTypeDisplay = ` (Ghid: ${promptTypeDisplay})`;
        } else if (entryData.promptTypeUtilizat === "prompt_personalizat"){
            promptTypeDisplay = " (Scriere liberÄƒ)";
        }


        if (!card) { 
            card = document.createElement("div");
            card.className = "response-card journal-card"; 
            card.setAttribute("data-id", entryData.id);
            card.innerHTML = `
                <div class="card-header">
                    <span>${entryTitle}${promptTypeDisplay}</span>
                    <span class="card-date">${entryDate}</span>
                </div>
                <div class="card-content">
                    <details class="journal-entry-details">
                        <summary>Vezi/Ascunde textul intrÄƒrii de jurnal</summary>
                        <p class="journal-entry-content-text">${entryData.continut.replace(/\n/g, '<br>')}</p>
                    </details>
                    <h4>Feedback AI <span style="font-weight:300; font-style:italic; font-size:0.85em;">(PsihoGPT)</span></h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                         <button class="regenerate-feedback-button" title="RegenereazÄƒ Feedback AI pentru aceastÄƒ intrare">RegenereazÄƒ</button>
                         <button class="delete-last-feedback-button" title="È˜terge Ultimul Feedback AI generat">È˜terge Ultimul</button>
                         <button class="delete-journal-entry-button" title="È˜terge AceastÄƒ Intrare din Jurnal È™i Tot Feedback-ul">È˜terge Intrarea</button>
                    </div>
                </div>`;
            
            const header = card.querySelector('.card-header');
            header.addEventListener('click', (e) => {
                 if (!e.target.closest('button') && !e.target.closest('details')) { // Nu deschide/Ã®nchide dacÄƒ se apasÄƒ pe butoane sau pe zona <details>
                    card.classList.toggle('open');
                 }
            });
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); regenereazaFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); stergeUltimulFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeIntrareJurnal(entryData.id, card); });
            
            const noEntriesMsg = container.querySelector('.no-entries-message');
            if (noEntriesMsg) noEntriesMsg.remove();

            if (container.firstChild && container.firstChild.nodeName !== 'P') { // AdaugÄƒ Ã®naintea primului card, dacÄƒ existÄƒ È™i nu e mesajul "nici o intrare"
                container.insertBefore(card, container.firstChild);
            } else { // Altfel, dacÄƒ e gol sau are un mesaj placeholder, curÄƒÈ›Äƒ È™i adaugÄƒ
                if (container.firstChild && container.firstChild.nodeName === 'P') container.innerHTML = '';
                container.appendChild(card);
            }
        } else { 
             card.querySelector('.card-header span:first-child').textContent = `${entryTitle}${promptTypeDisplay}`;
             card.querySelector('.journal-entry-content-text').innerHTML = entryData.continut.replace(/\n/g, '<br>');
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, entryData.feedbackAI_history || (entryData.feedbackAI_latest ? [entryData.feedbackAI_latest] : []));
    }

    async function stergeIntrareJurnal(id, cardElement) {
        // ... (FuncÈ›ia stergeIntrareJurnal rÄƒmÃ¢ne la fel)
        if (!confirm("È˜tergi aceastÄƒ intrare din jurnal È™i tot feedback-ul asociat? AcÈ›iunea este ireversibilÄƒ.")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card') && !container.querySelector('.no-entries-message')) { // VerificÄƒ dacÄƒ mai sunt carduri
                const noEntriesMsg = document.createElement("p");
                noEntriesMsg.className = "no-entries-message"; // FoloseÈ™te clasa consistentÄƒ
                noEntriesMsg.textContent = "Nicio intrare Ã®n jurnal. ÃŽncepe prin a scrie una!";
                container.appendChild(noEntriesMsg);
            }
        } catch (error) { console.error("Eroare È™tergere intrare:", error); alert("Eroare la È™tergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        // ... (FuncÈ›ia incarcaIntrariJurnal rÄƒmÃ¢ne la fel)
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        
        let loadingMsg = container.querySelector(".loading-message");
        if (!container.querySelector('.journal-card') && !container.querySelector('.no-entries-message') && !loadingMsg) {
            loadingMsg = document.createElement("p");
            loadingMsg.className = "loading-message"; // FoloseÈ™te clasa consistentÄƒ
            loadingMsg.textContent = "Se Ã®ncarcÄƒ intrÄƒrile din jurnal...";
            container.appendChild(loadingMsg);
        }

        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            if (loadingMsg) loadingMsg.remove(); 

            // Optimizare: ÃŽnlÄƒturÄƒ doar cardurile care nu mai existÄƒ
            const currentCardsMap = new Map();
            container.querySelectorAll('.journal-card').forEach(card => currentCardsMap.set(card.dataset.id, card));

            const newDocsData = [];
            querySnapshot.forEach((docSnap) => {
                newDocsData.push({ id: docSnap.id, ...docSnap.data() });
                if (currentCardsMap.has(docSnap.id)) {
                    currentCardsMap.delete(docSnap.id); // Acest card este Ã®ncÄƒ valid, nu-l È™terge
                }
            });

            // È˜terge cardurile rÄƒmase Ã®n map (cele care nu mai sunt Ã®n Firestore)
            currentCardsMap.forEach(oldCard => oldCard.remove());
            
            if (newDocsData.length === 0 && !container.querySelector('.journal-card')) {
                if (!container.querySelector('.no-entries-message')) { // AdaugÄƒ mesajul doar dacÄƒ e gol
                    const noEntriesMsg = document.createElement("p");
                    noEntriesMsg.className = "no-entries-message";
                    noEntriesMsg.textContent = "Nicio intrare Ã®n jurnal. ÃŽncepe prin a scrie una!";
                    container.appendChild(noEntriesMsg);
                }
            } else {
                 const noEntriesMessageIfAny = container.querySelector('.no-entries-message');
                 if (noEntriesMessageIfAny) noEntriesMessageIfAny.remove();
                 
                 // AdaugÄƒ sau actualizeazÄƒ cardurile
                 newDocsData.forEach(docData => afiseazaCardJurnal(docData));
            }

        } catch (error) {
            console.error("Eroare Ã®ncÄƒrcare jurnal:", error);
             if (loadingMsg) loadingMsg.remove();
            if(!container.querySelector('.journal-card') && !container.querySelector('.error-loading-message')) { // VerificÄƒ sÄƒ nu fie deja un mesaj de eroare
                const errorMsgElement = document.createElement("p");
                errorMsgElement.className = "error-loading-message"; // FoloseÈ™te clasa consistentÄƒ
                errorMsgElement.textContent = "Eroare la Ã®ncÄƒrcarea jurnalului. VÄƒ rugÄƒm reÃ®ncÄƒrcaÈ›i pagina sau verificaÈ›i consola.";
                // È˜terge orice mesaj de "nicio intrare" Ã®nainte de a adÄƒuga eroarea
                const noEntriesMsg = container.querySelector('.no-entries-message');
                if(noEntriesMsg) noEntriesMsg.remove();
                container.appendChild(errorMsgElement);
            }
        }
    }

    </script>
    <style>
    /* Stilurile rÄƒmÃ¢n identice cu cele din rÄƒspunsul anterior, sunt deja adaptate */
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f0f2f5; 
        color: #333a40; line-height: 1.6; font-size: 16px;
    }
    .journal-form-container {
        max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
        box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.7em; margin-bottom: 10px; }
    h3 { font-size: 1.4em; margin-top: 35px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
        transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
    }
    textarea#journalContent { min-height: 250px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;
    }
    
    .prompt-box {
        background: #f8f9fc;
        border: 1px solid #e6eaf0;
        border-left: 4px solid #5c85d6;
        padding: 12px 15px;
        margin-bottom: 15px;
        font-size: 0.9em;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }
    .prompt-box strong { color: #2c3e50; display: block; margin-bottom: 8px; }
    .prompt-content-display {
        white-space: pre-wrap; 
        max-height: 180px; 
        overflow-y: auto;
        background-color: #ffffff;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #e9edf2;
        font-family: 'Menlo', 'Monaco', 'Consolas', monospace;
        font-size:0.95em;
        line-height: 1.55;
        color: #333;
    }
    .prompt-content-display::-webkit-scrollbar { width: 5px; }
    .prompt-content-display::-webkit-scrollbar-thumb { background: #cbd2d9; border-radius:3px; }

    .hide-prompt-button { 
        background: none; border: none; color: #88929e;
        font-size: 1.6em; font-weight: bold; cursor: pointer;
        padding: 0 5px; line-height: 0.8; 
        /* float:right; // Eliminat float pentru o mai bunÄƒ aliniere cu flex pe containerul pÄƒrintelui */
    }
    .hide-prompt-button:hover { color: #333; }

    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 15px; background-color: #f8f9fc; border-radius: 8px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 12px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 10px; }
    button.prompt-button {
        background-color: #e9f0ff; color: #4a69bd; border: 1px solid #d1dfff;
        padding: 7px 14px; font-size: 0.85em; font-weight: 500; border-radius: 18px;
        cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button.prompt-button:hover { background-color: #d8e4ff; color: #3a539b; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.07); }

    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 20px; padding: 13px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 3px 7px rgba(92, 133, 214, 0.22);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1.5px); box-shadow: 0 4px 9px rgba(92, 133, 214, 0.28); }
    button#saveJournalEntryButton:disabled { background: #b0c4de !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    .confirmation-message { display: none; text-align: center; padding: 13px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdecea; color: #b32d21; border-color: #f8c6c1; }
    .confirmation-message.warning { background-color: #fff8e1; color: #795508; border-color: #ffecb3; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
    .response-card .card-header {
        font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
        padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
    .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap; font-weight: 400;}

    .response-card .card-header::after {content: 'â–¼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
    .response-card.open .card-content { max-height: 7000px; padding: 20px 20px; }
    
    .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
    .journal-entry-details summary { 
        cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
        background-color: #f8f9fa; border-radius: 6px 6px 0 0; 
        list-style-position: inside; 
    }
    .journal-entry-details summary:hover { background-color: #f1f3f6; }
    .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
    .journal-entry-content-text { 
        padding: 12px; font-size: 1em; line-height: 1.7; color: #3e4c59; white-space: pre-wrap; 
        max-height: 400px; overflow-y: auto;
    }
    .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
    .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }

    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 15px; font-size: 1.05em;
        border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
    }
    .response-card h4:first-of-type { margin-top: 0; } 

    .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }
    .no-entries-message, .loading-message, .error-loading-message { text-align: center; margin-top:25px; font-style: italic; color: #556575; font-size: 1.05em; padding:15px;}
    .error-loading-message { color: #c0392b; font-weight: 500;}

    .ai-feedback-history-container { margin-top: 10px; }
    .feedback-entry-card { 
        background:#fdfdff; padding: 15px; 
        border: 1px solid #e7ecf2;
        border-left: 4px solid #5c85d6; 
        border-radius:8px; margin-bottom:15px; 
        font-size:0.95em; line-height:1.6;
        box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    }
    .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
    
    .card-actions { 
        text-align: right; margin-top: 20px; padding-top: 15px; 
        border-top: 1px solid #eef2f7; 
        display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
    }
    .card-actions button {
        padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
        transition: all 0.2s; border: 1px solid transparent; cursor: pointer;
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
    button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
    button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
    button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
    button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
    
    /* Stiluri specifice pentru conÈ›inutul AI din feedback-entry-card .content-ai */
    .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
    .content-ai .ai-main-section-title, 
    .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 { /* Am adÄƒugat È™i h1-h4 pentru flexibilitatea AI */
        font-weight: 600; color: #3b74d7; /* Un albastru puÈ›in mai vibrant */
        margin-top: 1.2em; margin-bottom: 0.6em; font-size: 1.05em; /* Un pic mai mic decÃ¢t H4 general al cardului */
        padding-bottom: 4px;
        /* border-bottom: 1px dotted #d1d9e2; */ /* Sublinierea poate aglomera uneori */
    }
    .content-ai .ai-main-section-title:first-child, /* Reduce spaÈ›iul pentru primul titlu */
    .content-ai h1:first-child, .content-ai h2:first-child, 
    .content-ai h3:first-child, .content-ai h4:first-child {
        margin-top: 0.3em;
    }
    .content-ai p.ai-text-paragraph { margin-bottom: 0.9em; }
    .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; } /* Mai Ã®nchis pt contrast */
    .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; } /* Un gri mediu pentru italic */
    
    .content-ai ul.ai-list, .content-ai ol.ai-list {
        margin-left: 5px; padding-left: 22px; margin-bottom: 0.9em; list-style-position: outside;
    }
    .content-ai .ai-list-item { margin-bottom: 0.5em; }
    .content-ai .ai-list-item::marker { color: #4a69bd; font-weight: bold; } /* Marcatori mai vizibili */

    .content-ai .ai-text-error {
        color: #c0392b; font-weight: 500; background-color: #fff5f5; 
        padding: 10px 12px; border-radius: 4px; border: 1px solid #fecaca; border-left: 4px solid #ef4444;
        white-space: pre-wrap; font-size: 0.9em;
    }
    
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto; max-width: 100%;}
        h2 {font-size: 1.5em;} h3 {font-size: 1.25em;}
        textarea#journalContent {min-height: 200px;}
        .card-actions {justify-content: space-around;} /* Distribuie mai bine pe mobil */
        .card-actions button { flex-basis: auto; padding: 7px 12px;} /* Butoanele sÄƒ-È™i ia lÄƒÈ›imea necesarÄƒ */
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.3em;} h3 {font-size: 1.15em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 8px;}
        button.prompt-button {padding: 6px 12px; font-size: 0.8em;}
        button#saveJournalEntryButton {padding: 11px 18px; font-size: 1em;}
        .response-card .card-header {font-size: 1em; padding: 12px 15px; flex-direction: column; align-items: flex-start; gap: 5px;}
        .response-card .card-header::after { align-self: flex-end; margin-top: -1.5em; }
        .card-actions button { flex-basis: calc(50% - 5px); } /* DouÄƒ pe rÃ¢nd */
    }
    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -12px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            SpaÈ›iul tÄƒu dedicat pentru reflecÈ›ie ghidatÄƒ, auto-descoperire È™i integrare emoÈ›ionalÄƒ.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (OpÈ›ional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: ReflecÈ›ii despre ziua de azi, Explorarea anxietÄƒÈ›ii...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflecÈ›ie (alege un ghid pentru a-l afiÈ™a ca referinÈ›Äƒ):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <div id="activePromptBox" class="prompt-box" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <strong id="activePromptTitle">Ghid activ:</strong>
                    <!-- Butonul de Ã®nchidere va apela o funcÈ›ie globalÄƒ -->
                    <button type="button" onclick="window.hideActivePromptManual()" class="hide-prompt-button" title="Ascunde ghidul">Ã—</button>
                </div>
                <div id="activePromptContent" class="prompt-content-display"></div>
                <p style="font-size:0.85em; text-align:right; margin-top:8px; color: #64748B;"><em>Acest ghid este pentru inspiraÈ›ie. Scrie reflecÈ›iile tale Ã®n cÃ¢mpul de jurnal de mai jos.</em></p>
            </div>

            <label for="journalContent" style="margin-top: 15px;">Intrarea ta Ã®n jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="15" placeholder="Scrie liber aici sau completeazÄƒ rÄƒspunzÃ¢nd la Ã®ntrebÄƒrile din ghidul afiÈ™at mai sus."></textarea>
            
            <button type="button" id="saveJournalEntryButton">SalveazÄƒ È™i Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul IntrÄƒrilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Cardurile cu intrÄƒri vor fi Ã®ncÄƒrcate aici -->
        <!-- Mesajele de "loading", "no entries", "error" vor fi adÄƒugate de JS -->
    </div>
    
</body>
</html>