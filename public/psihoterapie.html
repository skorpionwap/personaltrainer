<!DOCTYPE html>
<html>
<head>
    <title>FiÈ™Äƒ Monitorizare - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, deleteField, doc, getDoc, updateDoc, arrayUnion, query, where, setDoc, orderBy, limit } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    // Configurarea Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // ÃŽnlocuieÈ™te cu cheia ta realÄƒ dacÄƒ e diferitÄƒ
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    // IniÈ›ializare Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // --- Configurare Gemini API ---
    // !!! ÃŽNLOCUIEÈ˜TE CU CHEIA TA API GEMINI VALIDÄ‚ È˜I ACTIVÄ‚ !!!
    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- CHEIA TA API GEMINI
    const GEMINI_MODEL_NAME_FEEDBACK = "gemini-2.5-flash-preview-04-17";
    const GEMINI_MODEL_NAME_CHAT = "gemini-2.5-flash-preview-04-17";
    let genAI, geminiModelFeedback, geminiModelChat;

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_FEEDBACK });
            geminiModelChat = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_CHAT });
            console.log("SDK Gemini iniÈ›ializat. Model Feedback:", GEMINI_MODEL_NAME_FEEDBACK, "Model Chat:", GEMINI_MODEL_NAME_CHAT);
        } catch (e) {
            console.error("Eroare criticÄƒ la iniÈ›ializarea SDK Gemini:", e);
            alert("Eroare la iniÈ›ializarea serviciului AI. VerificaÈ›i cheia API Gemini È™i configuraÈ›ia din Google Cloud. FuncÈ›ionalitatea AI va fi limitatÄƒ.");
            geminiModelFeedback = null; geminiModelChat = null;
        }
    } else  {
        console.warn(`Cheia API Gemini pare a fi un placeholder ('${GEMINI_API_KEY}'). Te rog Ã®nlocuieÈ™te-o cu cheia ta API validÄƒ pentru a activa funcÈ›ionalitatea AI.`);
        // alert("FuncÈ›ionalitatea AI este dezactivatÄƒ. Te rog configureazÄƒ o cheie API Gemini validÄƒ Ã®n codul sursÄƒ (variabila GEMINI_API_KEY).");
        geminiModelFeedback = null; geminiModelChat = null;
        // Cheie goalÄƒ sau doar spaÈ›ii
        console.warn("Cheia API Gemini nu este configuratÄƒ. FuncÈ›ionalitatea AI va fi dezactivatÄƒ.");
        // alert("Cheia API Gemini nu este configuratÄƒ. FuncÈ›ionalitatea AI va fi dezactivatÄƒ.");
        geminiModelFeedback = null; geminiModelChat = null;
    }


    let currentStep = 1;
    let totalSteps = 0;
    let dataAlreadyLoaded = false;

    // --- Variabile Globale pentru Chat ---
    let chatSession = null;
    const CHAT_HISTORY_DOC_ID_PREFIX = "chatHistory_";
    let isChatInitialized = false;


    window.onload = function () {
        totalSteps = document.querySelectorAll('.form-step').length;
        updateProgressBar();
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (!collabId) {
            onAuthStateChanged(auth, async (user) => {
                const toggleChatBtn = document.getElementById("toggleChatButton");
                const chatContainer = document.getElementById("chatContainer");

                if (user) {
                    console.log("Utilizator autentificat:", user.uid);
                    if (!dataAlreadyLoaded) {
                        populateTableData(user.uid);
                        loadTableData(user.uid);
                        dataAlreadyLoaded = true;
                    }
                    if(toggleChatBtn) toggleChatBtn.style.display = 'flex';
                } else {
                    console.log("Utilizator neautentificat, redirecÈ›ionare...");
                    if(toggleChatBtn) toggleChatBtn.style.display = 'none';
                    if(chatContainer) chatContainer.style.display = 'none';
                    isChatInitialized = false;
                    chatSession = null;
                    window.location.href = "login.html";
                }
            });
        } else {
            const toggleChatBtn = document.getElementById("toggleChatButton");
            if(toggleChatBtn) toggleChatBtn.style.display = 'none';
            const chatContainer = document.getElementById("chatContainer");
            if(chatContainer) chatContainer.style.display = 'none';
        }

        document.getElementById("nextButton")?.addEventListener("click", nextStep);
        document.getElementById("prevButton")?.addEventListener("click", previousStep);
        document.getElementById("addButton")?.addEventListener("click", salveazaRaspunsSiGenereazaFeedback);
        document.getElementById("generateLinkButton")?.addEventListener("click", generateCollaborationLink);
        
        document.getElementById("toggleChatButton")?.addEventListener("click", handleToggleChat);
        document.getElementById("sendChatMessageButton")?.addEventListener("click", handleSendChatMessage);
        document.getElementById("chatInput")?.addEventListener("keypress", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); 
                handleSendChatMessage();
            }
        });
    };

    function nextStep() {
        if (currentStep < totalSteps) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep++;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function previousStep() {
        if (currentStep > 1) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep--;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function updateProgressBar() {
        const progress = document.getElementById('progress');
        if(progress && totalSteps > 0) {
            const progressPercentage = (currentStep / totalSteps) * 100;
            progress.style.width = progressPercentage + '%';
        }
    }
    
    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) {
            console.error("Modelul Gemini specificat este invalid sau neiniÈ›ializat.", modelToUse === geminiModelChat ? "(Model Chat)" : "(Model Feedback)");
            return "EROARE: Model AI neiniÈ›ializat. VerificÄƒ cheia API.";
        }
        try {
            const requestPayload = {
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.55, ...generationConfigOptions }
            };
            const result = await modelToUse.generateContent(requestPayload); 
            const response = result.response;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Gemini a oprit generarea prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    return `EROARE Gemini: Generare opritÄƒ (Motiv: ${response.candidates[0].finishReason}). Filtre de siguranÈ›Äƒ posibile active.`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                console.error("Prompt blocat de Gemini:", response.promptFeedback.blockReasonDetail || response.promptFeedback.blockReason);
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). RevizuieÈ™te conÈ›inutul trimis.`;
            }
             else {
                console.error("RÄƒspuns Gemini neaÈ™teptat sau gol:", JSON.stringify(response, null, 2));
                return "EROARE Gemini: RÄƒspuns invalid sau gol de la API.";
            }
        } catch (error) {
            console.error("Eroare detaliatÄƒ la callGeminiAPI:", error, error.stack);
            let errorMessage = `EROARE Gemini: ${error.message || "Eroare API necunoscutÄƒ"}`;
            if (error.toString().toLowerCase().includes("api key not valid") || 
                (error.message && error.message.toLowerCase().includes("permission denied")) ||
                (error.message && error.message.toLowerCase().includes("api_key_invalid")) ||
                (error.status && error.status === 403)) {
                 errorMessage = "EROARE: Cheia API Gemini nu este validÄƒ sau nu are permisiuni. VerificÄƒ restricÈ›iile din Google Cloud Console (HTTP Referrers, API Restrictions pentru Generative Language API) È™i cheia din cod. AsigurÄƒ-te cÄƒ domeniul " + window.location.hostname + " este permis.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429) || (error.toString().toLowerCase().includes("resource has been exhausted")) )) {
                errorMessage = "EROARE: Limita de utilizare (posibil gratuitÄƒ) a API-ului Gemini (RPM/TPM sau alta) a fost depÄƒÈ™itÄƒ. ÃŽncearcÄƒ mai tÃ¢rziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety_settings"))) {
                errorMessage = "EROARE Gemini: Generarea a fost opritÄƒ (posibil din motive de siguranÈ›Äƒ, conÈ›inut inadecvat, sau alte restricÈ›ii ale modelului). ÃŽncearcÄƒ un prompt diferit sau ajusteazÄƒ setÄƒrile de siguranÈ›Äƒ dacÄƒ ai acces.";
            }  else if (error.toString().toLowerCase().includes("404") && error.toString().toLowerCase().includes("model not found")) {
                 errorMessage = `EROARE Gemini: Modelul specificat nu a fost gÄƒsit sau nu este suportat. VerificÄƒ numele modelului Ã®n cod.`;
            }
            return errorMessage;
         }
    }

    async function genereazaFeedbackCuGeminiDinFrontend(promptText) { 
        if (!geminiModelFeedback) {
            console.error("Modelul Gemini pentru feedback (geminiModelFeedback) nu este iniÈ›ializat. VerificÄƒ cheia API.");
            return "EROARE: Configurare Gemini incorectÄƒ pentru feedback. VerificÄƒ dacÄƒ ai introdus corect cheia API Ã®n cod.";
        }
        try {
            console.log("Trimitere prompt cÄƒtre Gemini (feedback fiÈ™Äƒ, primele 100 caractere):", promptText.substring(0, 100) + "...");
            return await callGeminiAPI(promptText, geminiModelFeedback); 
        } catch (error) { 
            console.error("Eroare specificÄƒ Ã®n genereazaFeedbackCuGeminiDinFrontend:", error);
            return `EROARE internÄƒ la pregÄƒtirea cererii cÄƒtre Gemini (feedback): ${error.message}`;
        }
    }

    async function genereazaSiProceseazaFeedbackAI(rowData, docId) {
      const prompt = `
AnalizeazÄƒ Ã®n profunzime aceastÄƒ fiÈ™Äƒ completÄƒ de auto-reflecÈ›ie. Utilizatorul a parcurs un exerciÈ›iu detaliat pentru a-È™i Ã®nÈ›elege o situaÈ›ie specificÄƒ. OferÄƒ feedback psihologic structurat, empatic È™i acÈ›ionabil. RespectÄƒ cu stricteÈ›e formatul È™i ordinea secÈ›iunilor de mai jos, folosind exact prefixele indicate.

**Datele Complete din FiÈ™a de ReflecÈ›ie a Utilizatorului:**

**SecÈ›iunea 1: Explorarea SituaÈ›iei È™i a Nevoilor**
*   Care este situaÈ›ia?: ${rowData.situatie || 'N/A'}
*   Ce Ã®mi trece prin minte (gÃ¢nduri automate)?: ${rowData.ganduri || 'N/A'}
*   Cum mÄƒ face acel gÃ¢nd sÄƒ mÄƒ simt (emoÈ›ii)?: ${rowData.emotii || 'N/A'}
*   Ce mod este activ?: ${rowData.mod_activ || 'N/A'}
*   Ce comportament simÈ›i cÄƒ adopÈ›i?: ${rowData.comportament || 'N/A'}
*   Care sunt nevoile tale mai profunde?: ${rowData.nevoi_profunde || 'N/A'}
*   MÄƒ ajutÄƒ comportamentul meu sÄƒ Ã®ndeplinesc aceste nevoi?: ${rowData.ajutor_comportament || 'N/A'}
*   Cum ar gÃ¢ndi È™i cum s-ar comporta Adultul SÄƒnÄƒtos (perspectiva utilizatorului)?: ${rowData.adult_sanatos || 'N/A'}

**SecÈ›iunea 2: Analiza GÃ¢ndurilor È™i a PercepÈ›iilor**
*   Ce mÄƒ face sÄƒ cred cÄƒ gÃ¢ndul automat este adevÄƒrat?: ${rowData.dovezi_adevar || 'N/A'}
*   Ce mÄƒ face sÄƒ cred cÄƒ nu este adevÄƒrat?: ${rowData.dovezi_fals || 'N/A'}
*   ExistÄƒ o explicaÈ›ie alternativÄƒ?: ${rowData.explicatie_alternativa || 'N/A'}
*   Care este cel mai rÄƒu lucru care s-ar putea Ã®ntÃ¢mpla?: ${rowData.scenariu_negativ || 'N/A'}
*   Care este cel mai bun lucru care s-ar putea Ã®ntÃ¢mpla?: ${rowData.scenariu_optimist || 'N/A'}
*   Care este cel mai realist rezultat?: ${rowData.rezultat_realist || 'N/A'}
*   Ce s-ar Ã®ntÃ¢mpla dacÄƒ mi-aÈ™ schimba modul de gÃ¢ndire?: ${rowData.schimbare_gandire || 'N/A'}
*   Ce i-aÈ™ spune unui prieten dacÄƒ ar fi Ã®n aceeaÈ™i situaÈ›ie?: ${rowData.sfat_prieten || 'N/A'}

**SecÈ›iunea 3: ÃŽntrebÄƒri pentru Claritate È™i ReflecÈ›ie SuplimentarÄƒ**
*   VÄƒd doar partea rea a lucrurilor?: ${rowData.partea_rea || 'N/A'}
*   ÃŽmi asum responsabilitatea pentru lucruri care nu au stat Ã®n puterea mea?: ${rowData.responsabilitate || 'N/A'}
*   MÄƒ condamn Ã®n baza unui singur eveniment?: ${rowData.condamnare || 'N/A'}
*   Privesc situaÈ›ia Ã®n termeni extremi (alb/negru)?: ${rowData.termeni_extremi || 'N/A'}
*   Exagerez situaÈ›ia?: ${rowData.exagerare || 'N/A'}
*   ExistÄƒ È™i alÈ›i factori responsabili?: ${rowData.factori_responsabili || 'N/A'}
*   Am sÄƒrit direct la concluzii?: ${rowData.concluzii || 'N/A'}
*   ÃŽmi pun Ã®ntrebÄƒri fÄƒrÄƒ rÄƒspuns?: ${rowData.intrebari_fara_raspuns || 'N/A'}
*   MÄƒ concentrez doar asupra slÄƒbiciunilor mele?: ${rowData.slabiciuni || 'N/A'}
*   MÄƒ zbat prea mult gÃ¢ndind la cum ar trebui sÄƒ fie lucrurile?: ${rowData.cum_ar_trebui || 'N/A'}
*   MÄƒ aÈ™tept sÄƒ fiu perfect?: ${rowData.perfectiune || 'N/A'}

**CERINÈšE PENTRU FEEDBACK-UL AI (foloseÈ™te prefixele EXACT aÈ™a cum sunt scrise):**

Feedback General:
EmpatieIniÈ›ialÄƒ: (1-2 propoziÈ›ii empatice scurte, recunoscÃ¢nd efortul utilizatorului.)

AnalizÄƒ DetaliatÄƒ:
PuncteForteObservate: (IdentificÄƒ 1-2 aspecte pozitive sau de auto-conÈ™tientizare.)
TiparePrincipale: (Descrie succint 1-3 tipare de gÃ¢ndire/emoÈ›ionale/comportamentale centrale.)

LegÄƒtura GÃ¢nd-EmoÈ›ie-Comportament-Nevoie:
ConexiuniCheie: (SintetizeazÄƒ legÄƒtura S-G-E-C-N bazatÄƒ pe '${rowData.ganduri}', '${rowData.emotii}', '${rowData.comportament}', '${rowData.nevoi_profunde}'.)

Analiza GÃ¢ndurilor Automate È™i Distorsiuni:
DistorsiuniIdentificate: (IdentificÄƒ 2-4 distorsiuni principale. Pentru fiecare: Numele, ExplicaÈ›ia, Exemplu din rÄƒspunsuri, ÃŽntrebare de contestare. ListeazÄƒ fiecare ca sub-punct precedat de '* '.)

Scheme È™i Moduri Cognitive:
SchemeActivate: (IdentificÄƒ 1-3 scheme. Pentru fiecare: Numele, Cum se manifestÄƒ. ListeazÄƒ fiecare ca sub-punct precedat de '* '.)
ModuriImplicate: (SugereazÄƒ ce moduri Schema Therapy ar putea fi implicate.)

Rolul Adultului SÄƒnÄƒtos:
PerspectivaAdultSÄƒnÄƒtos: (ComenteazÄƒ rÄƒspunsul utilizatorului '${rowData.adult_sanatos}'. OferÄƒ descriere detaliatÄƒ: interpretare situaÈ›ie, gÃ¢nduri alternative, gestionare emoÈ›ii, comportamente adaptative, contracarare scheme.)

Sugestii È™i ReflecÈ›ii Finale:
ÃŽntrebareFinalÄƒReflecÈ›ie: (O Ã®ntrebare generalÄƒ puternicÄƒ pentru Ã®nvÄƒÈ›are È™i aplicare viitoare.)
SugestieMicPas: (O sugestie concretÄƒ pentru un mic pas urmÄƒtor.)
ÃŽncurajareFinalÄƒ: (1-2 propoziÈ›ii de Ã®ncurajare.)

RÄƒspunde doar cu textul cerut conform structurii, fÄƒrÄƒ introduceri, concluzii sau formatÄƒri suplimentare Ã®n afara celor specificate).`;

      let feedbackText = null;
      let modelFolosit = "N/A";

      if (geminiModelFeedback) {
        console.log("Solicitare feedback de la Gemini pentru fiÈ™Äƒ...");
        modelFolosit = `Gemini (${GEMINI_MODEL_NAME_FEEDBACK})`;
        feedbackText = await genereazaFeedbackCuGeminiDinFrontend(prompt);
      } else {
        console.warn("Gemini (geminiModelFeedback) nu este configurat. Nu se poate genera feedback AI pentru fiÈ™Äƒ.");
        return {
            paragraf: "Serviciul de feedback AI (Gemini) nu este configurat corect pentru fiÈ™e. VerificÄƒ cheia API È™i numele modelului.",
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "", 
            model: "Configurare Gemini EronatÄƒ", timestamp: new Date().toISOString(), error: true
        };
      }

      if (!feedbackText || (typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:"))) {
        console.warn(`Eroare de la ${modelFolosit} la generarea feedback-ului fiÈ™ei:`, feedbackText);
        return { 
            paragraf: feedbackText || `Nu s-a putut obÈ›ine feedback de la ${modelFolosit}.`,
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "",
            model: modelFolosit + " (Eroare API)", timestamp: new Date().toISOString(), error: true
        };
      }

      console.log("RÄƒspuns brut de la Gemini (feedback fiÈ™Äƒ):\n---\n" + feedbackText + "\n---");

      const feedbackStructure = {
            empatie_initiala: /^EmpatieIniÈ›ialÄƒ:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            puncte_forte: /^PuncteForteObservate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            tipare_principale: /^TiparePrincipale:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            conexiuni_cheie: /^ConexiuniCheie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            distorsiuni_identificate: /^DistorsiuniIdentificate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            scheme_activate: /^SchemeActivate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            moduri_implicate: /^ModuriImplicate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            perspectiva_adult_sanatos: /^PerspectivaAdultSÄƒnÄƒtos:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            intrebare_finala_reflectie: /^ÃŽntrebareFinalÄƒReflecÈ›ie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            sugestie_mic_pas: /^SugestieMicPas:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            incurajare_finala: /^ÃŽncurajareFinalÄƒ:\s*([\s\S]*?$)/im,
        };
        
        const parsedFeedback = { model: modelFolosit, timestamp: new Date().toISOString(), error: false, error_parsing: false };
        let allParsingOk = true;

        for (const key in feedbackStructure) {
            const match = feedbackText.match(feedbackStructure[key]);
            if (match && match[1] && match[1].trim() !== "") {
                 parsedFeedback[key] = match[1].trim();
            } else {
                console.warn(`Feedback fiÈ™Äƒ: Nu s-a putut extrage sau este gol conÈ›inutul pentru: '${key}'`);
                parsedFeedback[key] = `(SecÈ›iune neextrasÄƒ sau goalÄƒ din rÄƒspunsul AI: ${key})`;
                allParsingOk = false;
            }
        }
        
        if (!allParsingOk) {
            console.warn("Feedback fiÈ™Äƒ: Cel puÈ›in o secÈ›iune nu a putut fi parsatÄƒ corect din rÄƒspunsul AI. VerificÄƒ formatul rÄƒspunsului AI È™i regex-urile.");
            parsedFeedback.error_parsing = true;
        }

        if (docId) {
            const docRef = doc(db, "raspunsuri", docId);
            try {
                const updatePayload = { feedback_history: arrayUnion(parsedFeedback) };
                Object.keys(parsedFeedback).forEach(key => {
                    updatePayload[`feedback_${key}`] = parsedFeedback[key];
                });
                await updateDoc(docRef, updatePayload);
                console.log(`Feedback AI (nou, ${modelFolosit}) salvat pentru fiÈ™a ${docId}`);
            } catch (updateError) {
                console.error(`Eroare update Firestore feedback nou pentru fiÈ™a ${docId}:`, updateError);
            }
        }
        return parsedFeedback;
    }

    // --- CHAT FUNCTIONALITY ---

    function displayChatMessage(message, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) {
            console.error("Elementul chatMessages nu a fost gÄƒsit.");
            return; 
        }
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");
        
        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        // CORECTIE: AdaugÄƒ clasele separat
        const classesToAdd = messageClass.split(' ');
        messageElement.classList.add(...classesToAdd);

        messageElement.style.whiteSpace = "pre-wrap"; 
        messageElement.textContent = message; 

        messagesDiv.appendChild(messageElement);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    async function loadChatHistory(userId) {
        if (!userId) return [];
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists() && docSnap.data().messages && Array.isArray(docSnap.data().messages)) {
                const messages = docSnap.data().messages;
                messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                return messages;
            }
            return []; 
        } catch (error) {
            console.error("Eroare la Ã®ncÄƒrcarea istoricului de chat din Firestore:", error);
            return [];
        }
    }
    
    async function saveChatMessage(userId, messageObject) {
        if (!userId || !messageObject || typeof messageObject.content !== 'string' || messageObject.content.trim() === "") {
            console.warn("TentativÄƒ de salvare a unui mesaj invalid sau gol:", messageObject);
            return;
        }
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists()) {
                 await updateDoc(historyDocRef, {
                    messages: arrayUnion(messageObject) 
                });
            } else {
                await setDoc(historyDocRef, {
                    messages: [messageObject]
                });
            }
            console.log("Mesaj de chat salvat pentru utilizatorul:", userId);
        } catch (error) {
            console.error("Eroare la salvarea mesajului de chat Ã®n Firestore:", error);
        }
    }
    
    async function initializeAndStartChatSession(userId) {
        const chatStatus = document.getElementById("chatStatus");
        const sendButton = document.getElementById("sendChatMessageButton");
        const messagesDiv = document.getElementById("chatMessages");

        if (sendButton) sendButton.disabled = true;
        if (chatStatus) chatStatus.textContent = "IniÈ›ializare chat AI...";
        if (messagesDiv) messagesDiv.innerHTML = ''; 

        if (!geminiModelChat) { // Verificarea e crucialÄƒ aici
            if (chatStatus) chatStatus.textContent = "EROARE: Modelul AI Chat nu este disponibil.";
            console.error("initializeAndStartChatSession: geminiModelChat nu este iniÈ›ializat. VerificÄƒ cheia API GEMINI.");
            displayChatMessage("Serviciul de chat AI nu este disponibil momentan. Te rog verificÄƒ configuraÈ›ia sau contacteazÄƒ administratorul (Cheie API Gemini neconfiguratÄƒ/invalidÄƒ).", "AI-error");
            return null; // Nu se poate continua
        }
        
        isChatInitialized = false; 

        let initialContextSummary = "REZUMAT DIN FIÈ˜ELE ANTERIOARE (ULTIMELE 3):\n";
        try {
            if (userId) {
                const q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId), orderBy("date", "desc"), limit(3)); 
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    querySnapshot.forEach(doc => {
                        const data = doc.data();
                        const entryDate = data.date || (data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleDateString("ro-RO") : 'N/A');
                        initialContextSummary += ` - FiÈ™Äƒ (${entryDate}): SituaÈ›ia - ${(data.situatie || "").substring(0, 70)}...; GÃ¢nduri - ${(data.ganduri || "").substring(0, 70)}...; EmoÈ›ii - ${data.emotii || 'N/A'}.\n`;
                    });
                } else { initialContextSummary += "Nicio fiÈ™Äƒ de monitorizare recentÄƒ gÄƒsitÄƒ.\n"; }
            }
        } catch(e) { 
            console.error("Eroare la Ã®ncÄƒrcarea contextului din fiÈ™e pentru chat:", e); 
            initialContextSummary += "Eroare la Ã®ncÄƒrcarea contextului din fiÈ™e.\n";
        }

        const systemInstructionText =
`# ROL PRINCIPAL È˜I PERSONA:
Tu eÈ™ti PsihoGPT (alias Dr. Janet/Damian â€“ decide o identitate sau menÈ›ioneazÄƒ ambele roluri complementare pe care le poÈ›i juca, concentrÃ¢ndu-te pe claritatea teoreticÄƒ È™i ghidajul practic). EÈ™ti un asistent AI avansat pentru auto-reflecÈ›ie È™i explorare psihologicÄƒ ghidatÄƒ, specializat Ã®n Terapie Cognitiv-ComportamentalÄƒ (TCC), Terapia Schemelor, Terapia prin Acceptare È™i Angajament (ACT), È™i principii ale Terapiei Dialectic-Comportamentale (DBT) È™i ale terapiei afirmative gay. Te adresezi utilizatorului cu "tu". Scopul tÄƒu principal este sÄƒ sprijini utilizatorul Ã®n dezvoltarea stimei de sine È™i a auto-compasiunii, vindecarea copilului interior È™i gestionarea relaÈ›iilor Ã®ntr-un mod echilibrat, pentru o viaÈ›Äƒ Ã®mplinitÄƒ È™i independentÄƒ emoÈ›ional.

# MISIUNE È˜I ABORDARE TERAPEUTICÄ‚:
Misiunea ta este sÄƒ ajuÈ›i utilizatorul sÄƒ exploreze gÃ¢nduri, emoÈ›ii, comportamente È™i nevoi profunde. Vei ghida utilizatorul sÄƒ:
1.  Identifice È™i sÄƒ Ã®nÈ›eleagÄƒ **Schemele Maladaptative Timpurii** (explicÄƒ pe scurt conceptul la nevoie). Fii atent la manifestÄƒri ale schemelor de Abandon/Instabilitate, Defectivitate/RuÈ™ine, Deprivare EmoÈ›ionalÄƒ, EÈ™ec (pe baza YSQ-R, SMI indicate Ã®n documentaÈ›ia ta internÄƒ, ex. Deprivare EmoÈ›ionalÄƒ (4.80), EÈ™ec (4.33), Sacrificiu de sine (4.50)).
2.  Exploreze **Stilul de AtaÈ™ament** (ex. anxios-evitant) È™i impactul sÄƒu asupra relaÈ›iilor.
3.  Abordeze teme specifice precum **homofobia internalizatÄƒ** sau **stresul minoritar**, utilizÃ¢nd principii ale **terapiei afirmative gay**. ReferenÈ›iazÄƒ discret autori precum Alan Downs sau Joe Kort cÃ¢nd aduci Ã®n discuÈ›ie concepte cheie (ex. "Unii autori, precum Alan Downs Ã®n 'The Velvet Rage', exploreazÄƒ impactul creÈ™terii Ã®ntr-un mediu care nu valideazÄƒ pe deplin identitatea gay...").
4.  Examineze È™i sÄƒ Ã®mbunÄƒtÄƒÈ›eascÄƒ **stima de sine** È™i **autocompasiunea** (inspirÄƒ-te din Kristin Neff).
5.  Dezvolte **limite sÄƒnÄƒtoase** È™i asertivitate.
6.  Identifice È™i sÄƒ transforme posibile **tipare de mentalitate de victimÄƒ**, cultivÃ¢nd **agenÈ›ia personalÄƒ**.
7.  Lucreze cu **experienÈ›ele trecute** È™i **copilul interior** (inspirÄƒ-te din Robert Jackman, Gitta Jacob).
8.  SÄƒ formuleze **obiective SMART** pentru progresul personal È™i terapeutic.

# PRINCIPII DE INTERACÈšIUNE È˜I COMUNICARE:
1.  **Empatie È™i CÄƒldurÄƒ:** Fii cald, empatic, curios È™i non-judicativ. CreeazÄƒ un spaÈ›iu sigur.
2.  **ÃŽntrebÄƒri Deschise:** StimuleazÄƒ reflecÈ›ia prin Ã®ntrebÄƒri deschise (ex: "Ce anume te face sÄƒ crezi asta?", "Cum te-ai simÈ›it Ã®n acel moment?", "ExistÄƒ È™i o altÄƒ perspectivÄƒ?", "Ce nevoie crezi cÄƒ Ã®ncearcÄƒ sÄƒ Ã®È›i comunice aceastÄƒ emoÈ›ie?"). Pune Ã®ntrebÄƒri clarificatoare.
3.  **Validare EmoÈ›ionalÄƒ:** ValideazÄƒ emoÈ›iile utilizatorului (ex: "ÃŽnÈ›eleg cÄƒ te simÈ›i aÈ™a.", "Pare o situaÈ›ie dificilÄƒ È™i e normal sÄƒ reacÈ›ionezi astfel.").
4.  **PsihoeducaÈ›ie DozatÄƒ:** DacÄƒ introduci un concept psihologic (schemÄƒ, distorsiune, stil de ataÈ™ament), explicÄƒ-l concis (poate Ã®ntr-un chenar ASCII simplu sau italic) È™i Ã®ntreabÄƒ dacÄƒ rezoneazÄƒ cu utilizatorul. FoloseÈ™te metafore simple (ex. din ACT).
5.  **Non-Directivitate ResponsabilÄƒ:** NU oferi diagnostice medicale. NU oferi sfaturi directe care Ã®nlocuiesc terapia umanÄƒ. Scopul este auto-reflecÈ›ia ghidatÄƒ. Condu utilizatorul spre propriile sale soluÈ›ii È™i insight-uri.
6.  **Utilizarea Contextului:** FoloseÈ™te REZUMATUL FIÈ˜ELOR ANTERIOARE (furnizat la Ã®nceputul sesiunii) pentru a Ã®nÈ›elege mai bine utilizatorul. ReferÄƒ-te la el cu discreÈ›ie (ex: "Am observat cÄƒ Ã®n fiÈ™ele tale anterioare ai menÈ›ionat X. SimÈ›i cÄƒ existÄƒ o legÄƒturÄƒ cu ce discutÄƒm acum?"). IntegreazÄƒ È™i continuitatea din discuÈ›ia curentÄƒ.
7.  **Concizie È™i Claritate:** RÄƒspunsurile tale ar trebui sÄƒ fie concise (ideal 2-5 propoziÈ›ii, dar adaptate), cu paragrafe scurte È™i aerisite pentru lizibilitate. Un singur rÄƒspuns terapeutic per mesaj; aÈ™teaptÄƒ replica utilizatorului.
8.  **StructurÄƒ FlexibilÄƒ a È˜edinÈ›ei:** UrmÄƒreÈ™te o structurÄƒ Ã®n 3 etape pentru fluxul conversaÈ›iei:
    *   **Etapa 1 (Conectare IniÈ›ialÄƒ, aprox. 1-7 replici):** Check-in emoÈ›ional, stabilirea intenÈ›iilor È™edinÈ›ei.
    *   **Etapa 2 (Lucru Central, aprox. 8-20 replici):** Explorare profundÄƒ a temei, tehnici, insight-uri. Aici poÈ›i introduce scurte "Capsule teoretice", diagrame ASCII simple sau exerciÈ›ii de "Focusing Online" (ghidare textualÄƒ scurtÄƒ spre senzaÈ›ii/emoÈ›ii).
    *   **Etapa 3 (Concluzii, aprox. 21-24 replici):** Recapitulare, exerciÈ›ii practice/micro-obiceiuri, validare, Mantra TerapeuticÄƒ de Ã®ncheiere.
9.  **Stil Vizual:** FoloseÈ™te emoticoane expresive cu moderaÈ›ie (âœ¨, ðŸŒŸ, ðŸ’¡, ðŸ”, ðŸ›¡ï¸, ðŸŒ±, ðŸ³ï¸â€ðŸŒˆ, ðŸ™) pentru a spori cÄƒldura. UtilizeazÄƒ *text italic* pentru concepte teoretice, citate scurte sau idei cheie. PoÈ›i folosi chenare ASCII simple pentru a evidenÈ›ia informaÈ›ii.
10. **Check-in Meta-Terapeutic:** Periodic (mai ales la finalul etapelor sau cÃ¢nd simÈ›i nevoia), Ã®ntreabÄƒ despre proces: "Cum È›i se pare ritmul discuÈ›iei?", "Acest tip de exerciÈ›iu È›i se pare util?", "SimÈ›i cÄƒ am atins ce era important pentru tine astÄƒzi?".

# CUNOÈ˜TINÈšE SPECIFICE È˜I RESURSE (referenÈ›ial):
DocumentaÈ›ia ta internÄƒ (nu o reproduce, ci foloseÈ™te conceptele) include informaÈ›ii despre:
*   **Schemele principale din YSQ-R È™i SMI** (ex. Deprivare EmoÈ›ionalÄƒ, Abandon, Defectivitate, EÈ™ec, Sacrificiu de Sine, PÄƒrinte Punitiv). UtilizeazÄƒ aceste informaÈ›ii pentru a intui ce scheme ar putea fi active Ã®n relatÄƒrile utilizatorului.
*   **Stil de AtaÈ™ament ECR-R** (Anxios-evitant).
*   **Bibliografie RecomandatÄƒ:** Concepte de la autori precum Jeffrey Young, Marsha Linehan, Russ Harris, BrenÃ© Brown, Kristin Neff, Alan Downs, Joe Kort.
*   **Tehnici Suplimentare:** Compassion Focused Therapy (auto-compasiune), elemente de Somatic Experiencing (atenÈ›ie la corp), abordare narativÄƒ (re-scrierea poveÈ™tii).

# PRIORITATE:
Pe lÃ¢ngÄƒ instrucÈ›iunile de mai sus, ia Ã®n considerare È™i contextul actual al conversaÈ›iei (istoricul mesajelor din aceastÄƒ sesiune de chat). PrioritizeazÄƒ empatia, validarea È™i ghidarea reflexivÄƒ.

Context din ultimele fiÈ™e completate de utilizator (foloseÈ™te-l cu discreÈ›ie È™i inteligenÈ›Äƒ):
${initialContextSummary}---`;

        const aiGreeting = "Salut! Sunt PsihoGPT, asistentul tÄƒu AI pentru reflecÈ›ie. Cum te simÈ›i astÄƒzi È™i despre ce ai vrea sÄƒ vorbim sau sÄƒ reflectÄƒm Ã®mpreunÄƒ?";

        let historyForGeminiInitialization = [];
        historyForGeminiInitialization.push({ role: "user", parts: [{ text: systemInstructionText }] }); 
        historyForGeminiInitialization.push({ role: "model", parts: [{ text: aiGreeting }] });      

        let loadedHistoryFromDB = await loadChatHistory(userId);
        
        const historicalMessagesForAPI = loadedHistoryFromDB.map(msg => ({
            role: msg.role,
            parts: [{ text: msg.content || "" }]
        })).filter(msg => msg.parts[0].text.trim() !== ""); 

        historyForGeminiInitialization = historyForGeminiInitialization.concat(historicalMessagesForAPI);

        try {
            chatSession = geminiModelChat.startChat({ // Va eÈ™ua aici dacÄƒ geminiModelChat e null
                history: historyForGeminiInitialization,
                generationConfig: { 
                    temperature: 0.75,
                }
            });
            console.log("Sesiune chat Gemini iniÈ›ializatÄƒ cu succes. Istoric trimis la API:", historyForGeminiInitialization.length, "mesaje.");
            if (chatStatus) chatStatus.textContent = "Chat pregÄƒtit.";
            
            displayChatMessage(aiGreeting, "AI"); 

            loadedHistoryFromDB.forEach(msg => {
                 displayChatMessage(msg.content, msg.role === "model" ? "AI" : "user");
            });
            isChatInitialized = true;
            if (sendButton) sendButton.disabled = false;

        } catch(initError) {
            console.error("Eroare la iniÈ›ializarea sesiunii de chat Gemini (startChat):", initError, initError.stack);
            if (chatStatus) chatStatus.textContent = "Eroare AI Chat. ReÃ®ncercaÈ›i.";
            displayChatMessage("A apÄƒrut o problemÄƒ tehnicÄƒ la pornirea chat-ului. VÄƒ rugÄƒm sÄƒ Ã®nchideÈ›i È™i redeschideÈ›i fereastra de chat sau sÄƒ Ã®ncercaÈ›i mai tÃ¢rziu.", "AI-error");
            isChatInitialized = false;
            chatSession = null;
            if (sendButton) sendButton.disabled = true; // Butonul ar trebui sÄƒ rÄƒmÃ¢nÄƒ dezactivat
            return null;
        }
        return chatSession;
    }

    async function handleSendChatMessage() {
        const chatInput = document.getElementById("chatInput");
        const sendButton = document.getElementById("sendChatMessageButton");
        const chatStatus = document.getElementById("chatStatus");

        if (!chatInput || !sendButton || !chatStatus) return;

        const messageText = chatInput.value.trim();
        if (messageText === "") return;

        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesarÄƒ pentru a folosi chat-ul.");
            window.location.href = "login.html";
            return;
        }

        displayChatMessage(messageText, "user");
        const userMessageForDB = { role: "user", content: messageText, timestamp: new Date().toISOString() };
        await saveChatMessage(user.uid, userMessageForDB);
        
        chatInput.value = ""; 
        sendButton.disabled = true;
        chatStatus.textContent = "PsihoGPT analizeazÄƒ...";

        if (!chatSession || !isChatInitialized) {
            console.log("Sesiunea de chat nu este (re)iniÈ›ializatÄƒ, se Ã®ncearcÄƒ acum...");
            chatSession = await initializeAndStartChatSession(user.uid); 
            if(!chatSession) { // VerificÄƒ din nou dacÄƒ iniÈ›ializarea a eÈ™uat
                chatStatus.textContent = "Eroare chat. ReÃ®ncÄƒrcaÈ›i.";
                sendButton.disabled = true; // MenÈ›ine butonul dezactivat
                // displayChatMessage("Nu s-a putut (re)stabili conexiunea cu AI-ul. VerificaÈ›i consola È™i Ã®ncercaÈ›i sÄƒ redeschideÈ›i chatul.", "AI-error");
                return; 
            }
        }
        
        try {
            const result = await chatSession.sendMessage(messageText); 
            const response = result.response;
            const aiResponseText = response?.candidates?.[0]?.content?.parts?.[0]?.text || "Nu am putut genera un rÄƒspuns momentan. ÃŽncercaÈ›i din nou.";
             if (response?.candidates?.[0]?.finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                 console.warn("RÄƒspuns Gemini (chat) oprit prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                 displayChatMessage(`AI-ul a oprit generarea: ${response.candidates[0].finishReason}. Este posibil sÄƒ fie din cauza filtrelor de siguranÈ›Äƒ. ÃŽncercaÈ›i sÄƒ reformulaÈ›i.`, "AI-error");
            } else {
                 displayChatMessage(aiResponseText, "AI");
            }

            const aiMessageForDB = { role: "model", content: aiResponseText, timestamp: new Date().toISOString() };
            await saveChatMessage(user.uid, aiMessageForDB);
            chatStatus.textContent = "Chat pregÄƒtit.";

        } catch (error) {
            console.error("Eroare la trimiterea mesajului cÄƒtre Gemini sau procesarea rÄƒspunsului:", error, error.stack);
            chatStatus.textContent = "Eroare Ã®n comunicarea cu AI.";
            let displayError = "Ne pare rÄƒu, a apÄƒrut o eroare de comunicare cu asistentul AI. VÄƒ rugÄƒm Ã®ncercaÈ›i din nou.";
             if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429))) {
                 displayError = "Limita de utilizare a serviciului AI a fost atinsÄƒ. VÄƒ rugÄƒm Ã®ncercaÈ›i mai tÃ¢rziu.";
            } else if (error.message && (error.message.toLowerCase().includes("safety") || (error.message.toLowerCase().includes("blocked")) )) {
                 displayError = "Mesajul sau rÄƒspunsul AI a fost blocat, posibil din motive de siguranÈ›Äƒ. ÃŽncercaÈ›i sÄƒ reformulaÈ›i.";
            } else if (error.message && error.message.toLowerCase().includes("api key not valid")){
                displayError = "Cheia API pentru serviciul AI nu este validÄƒ. ContactaÈ›i administratorul."
            }
            displayChatMessage(displayError, "AI-error");
            isChatInitialized = false; // ConsiderÄƒ resetarea pentru a forÈ›a re-iniÈ›ializarea la urmÄƒtoarea interacÈ›iune
            chatSession = null;
        } finally {
            if(geminiModelChat && isChatInitialized) { // ActiveazÄƒ butonul doar dacÄƒ AI-ul e teoretic funcÈ›ional
                 sendButton.disabled = false;
            } else {
                 sendButton.disabled = true; // MenÈ›ine dezactivat dacÄƒ AI-ul nu e ok
                 chatStatus.textContent = "Chat AI indisponibil.";
            }
            chatInput.focus();
        }
    }

    async function handleToggleChat() {
        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesarÄƒ pentru a accesa chat-ul.");
            window.location.href = "login.html";
            return;
        }

        const chatContainer = document.getElementById("chatContainer");
        const toggleButton = document.getElementById("toggleChatButton");
        const sendButton = document.getElementById("sendChatMessageButton");
        if (!chatContainer || !toggleButton) return;

        if (chatContainer.style.display === "none" || chatContainer.style.display === "") {
            chatContainer.style.display = "flex"; // FoloseÈ™te flex pentru aliniere corectÄƒ
            toggleButton.innerHTML = "âž–";
            if (!isChatInitialized || !chatSession) { // IniÈ›ializeazÄƒ dacÄƒ e necesar
                const sessionOK = await initializeAndStartChatSession(user.uid);
                if (sessionOK && sendButton) {
                    sendButton.disabled = false;
                } else if(sendButton) {
                    sendButton.disabled = true; // PÄƒstreazÄƒ dezactivat dacÄƒ iniÈ›ializarea a eÈ™uat
                }
            } else if (sendButton) {
                 sendButton.disabled = !geminiModelChat; // Starea butonului depinde dacÄƒ modelul e valid
            }
            document.getElementById("chatInput")?.focus();
        } else {
            chatContainer.style.display = "none";
            toggleButton.innerHTML = "ðŸ’¬";
        }
    }

    // --- END CHAT FUNCTIONALITY ---


    async function salveazaRaspunsSiGenereazaFeedback() {
        const form = document.getElementById("exercitiuForm");
        if (!form.checkValidity()) {
            form.reportValidity();
            const currentStepElement = document.querySelector('.form-step-active');
            const firstInvalidField = currentStepElement?.querySelector(':invalid');
            if (firstInvalidField) {
                firstInvalidField.focus();
                 alert("VÄƒ rugÄƒm completaÈ›i toate cÃ¢mpurile obligatorii din pasul curent Ã®nainte de a continua.");
            } else {
                 alert("VÄƒ rugÄƒm completaÈ›i toate cÃ¢mpurile obligatorii.");
            }
            return;
        }

        const formData = new FormData(form);
        const rowData = { date: new Date().toLocaleDateString("ro-RO") }; 
        formData.forEach((value, key) => { rowData[key] = value; });

        const user = auth.currentUser;
        if (!user) {
            alert("Trebuie sÄƒ fiÈ›i autentificat pentru a salva datele.");
            window.location.href = "login.html";
            return;
        }
        rowData.ownerUid = user.uid;
        
        const addButton = document.getElementById("addButton");
        const originalAddButtonText = addButton.textContent;
        addButton.textContent = "Se salveazÄƒ È™i se genereazÄƒ...";
        addButton.disabled = true;

        try {
            const docRef = await addDoc(collection(db, "raspunsuri"), rowData);
            rowData.id = docRef.id; 
            console.log(`RÄƒspuns salvat cu ID: ${docRef.id}. Se genereazÄƒ feedback AI automat...`);

            const feedbackGenerat = await genereazaSiProceseazaFeedbackAI(rowData, docRef.id);
            
            const docSnapshot = await getDoc(docRef); 
            if (docSnapshot.exists()) {
                adaugaCard({ id: docSnapshot.id, ...docSnapshot.data() });
            } else {
                rowData.feedback_history = feedbackGenerat && !feedbackGenerat.error ? [feedbackGenerat] : [];
                if (feedbackGenerat && !feedbackGenerat.error) {
                    Object.keys(feedbackGenerat).forEach(key => {
                         rowData[`feedback_${key}`] = feedbackGenerat[key];
                    });
                }
                adaugaCard(rowData);
            }
            
            form.reset(); 
            currentStep = 1; 
            document.querySelectorAll('.form-step').forEach(step => step.classList.remove('form-step-active'));
            document.getElementById('step-1').classList.add('form-step-active');
            updateProgressBar();

            const confirmationMessage = document.getElementById('confirmationMessage');
            if (feedbackGenerat && !feedbackGenerat.error && !feedbackGenerat.error_parsing) {
                confirmationMessage.textContent = 'Formularul a fost trimis È™i feedback-ul AI generat! ÃŽl puteÈ›i vedea Ã®n cardul de mai jos.';
                confirmationMessage.className = 'confirmation-message success';
            } else if (feedbackGenerat && (feedbackGenerat.error || feedbackGenerat.error_parsing)) {
                 confirmationMessage.textContent = `Formularul a fost trimis. ${feedbackGenerat.paragraf || feedbackGenerat.empatie_initiala || 'A apÄƒrut o problemÄƒ la generarea feedback-ului AI.'}`;
                 confirmationMessage.className = (feedbackGenerat.paragraf && feedbackGenerat.paragraf.toLowerCase().includes("limit")) ? 'confirmation-message warning' : 'confirmation-message error';
            } else {
                 confirmationMessage.textContent = 'Formularul a fost trimis, dar feedback-ul AI nu a putut fi generat sau procesat.';
                 confirmationMessage.className = 'confirmation-message error';
            }
            confirmationMessage.style.display = 'block';
            setTimeout(() => {
                confirmationMessage.style.display = 'none';
            }, 9000);

        } catch (error) {
            console.error("Eroare la salvarea Ã®n Firestore sau generarea feedback-ului AI pentru fiÈ™Äƒ:", error);
            alert("A apÄƒrut o eroare la salvare. VÄƒ rugÄƒm Ã®ncercaÈ›i din nou.");
            const confirmationMessage = document.getElementById('confirmationMessage');
            confirmationMessage.textContent = 'Eroare la salvarea formularului. ÃŽncercaÈ›i din nou.';
            confirmationMessage.className = 'confirmation-message error';
            confirmationMessage.style.display = 'block';
             setTimeout(() => { confirmationMessage.style.display = 'none'; }, 7000);
        } finally {
            addButton.textContent = originalAddButtonText;
            addButton.disabled = false;
        }
    }


    function afiseazaIstoricFeedback(containerElement, feedbackHistory) {
    containerElement.innerHTML = ''; 

    if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
        const noHistoryMsg = document.createElement("p");
        noHistoryMsg.textContent = "Niciun feedback AI generat anterior pentru aceastÄƒ fiÈ™Äƒ.";
        noHistoryMsg.style.fontStyle = "italic";
        noHistoryMsg.style.fontSize = "0.9em";
        noHistoryMsg.style.textAlign = "center";
        noHistoryMsg.style.padding = "10px 0";
        containerElement.appendChild(noHistoryMsg);
        return;
    }

    const historyTitle = document.createElement("h4");
    historyTitle.style.color = "#4A90E2";
    historyTitle.style.marginTop = "20px";
    historyTitle.style.marginBottom = "10px";
    historyTitle.textContent = "ðŸ—‚ï¸ Istoric Feedback AI:";
    containerElement.appendChild(historyTitle);

    feedbackHistory.slice().reverse().forEach((entry, index) => { 
        if (!entry || typeof entry !== 'object') {
            console.warn("Intrare invalidÄƒ Ã®n istoricul de feedback, va fi ignoratÄƒ:", entry);
            return; 
        }
        
        const itemContainer = document.createElement("div");
        itemContainer.className = "feedback-entry-card"; 

        const timestampAndModel = document.createElement("p");
        timestampAndModel.className = "feedback-timestamp";
        timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> generat la: <strong>${new Date(entry.timestamp || Date.now()).toLocaleString("ro-RO")}</strong> (Model: ${entry.model || 'N/A'})`;
        itemContainer.appendChild(timestampAndModel);

        // VerificÄƒ dacÄƒ intrarea este o eroare completÄƒ
        const entryIsError = entry.error || (entry.paragraf && typeof entry.paragraf === 'string' && entry.paragraf.toUpperCase().startsWith("EROARE:")) || (entry.empatie_initiala && typeof entry.empatie_initiala === 'string' && entry.empatie_initiala.toUpperCase().startsWith("EROARE:"));

        if (entryIsError) {
            const errorP = document.createElement("p");
            errorP.style.color = "red";
            errorP.style.fontWeight = "bold";
            errorP.innerHTML = (entry.paragraf || entry.empatie_initiala || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
            itemContainer.appendChild(errorP);
            containerElement.appendChild(itemContainer);
            return; 
        }
        if (entry.error_parsing) {
             const parsingWarningP = document.createElement("p");
             parsingWarningP.style.color = "orange";
             parsingWarningP.style.fontStyle = "italic";
             parsingWarningP.textContent = "AtenÈ›ie: Unele secÈ›iuni din acest feedback AI nu au putut fi parsate corect.";
             itemContainer.appendChild(parsingWarningP);
        }

        const isNewFormat = typeof entry.empatie_initiala === 'string';
        const isLikelyOldFormat = typeof entry.paragraf === 'string' && typeof entry.empatie_initiala === 'undefined';

        if (isNewFormat) {
            const newFormatSections = [
                { title: "ðŸ’¬ Empatie IniÈ›ialÄƒ", key: "empatie_initiala", isList: false },
                { title: "ðŸŒŸ Puncte Forte Observate", key: "puncte_forte", isList: false },
                { title: "ðŸ”„ Tipare Principale", key: "tipare_principale", isList: false },
                { title: "ðŸ”— Conexiuni Cheie", key: "conexiuni_cheie", isList: false },
                { title: "ðŸ” Distorsiuni Identificate", key: "distorsiuni_identificate", isList: true },
                { title: "ðŸ§  Scheme Activate", key: "scheme_activate", isList: true },
                { title: "ðŸŽ­ Moduri Implicate", key: "moduri_implicate", isList: false },
                { title: "ðŸ’ª Perspectiva Adultului SÄƒnÄƒtos", key: "perspectiva_adult_sanatos", isList: false },
                { title: "â“ ÃŽntrebare FinalÄƒ de ReflecÈ›ie", key: "intrebare_finala_reflectie", isList: false },
                { title: "ðŸ‘Ÿ Sugestie Mic Pas UrmÄƒtor", key: "sugestie_mic_pas", isList: false },
                { title: "ðŸ’– ÃŽncurajare FinalÄƒ", key: "incurajare_finala", isList: false }
            ];

            newFormatSections.forEach(sectionConfig => {
                const sectionDiv = document.createElement("div");
                sectionDiv.className = "feedback-section";
                const sectionTitleElement = document.createElement("h5");
                sectionTitleElement.textContent = sectionConfig.title + ":";
                sectionDiv.appendChild(sectionTitleElement);

                let contentText = entry[sectionConfig.key]; 

                if (typeof contentText === 'string' && contentText.trim() !== "" && !contentText.startsWith("(SecÈ›iune neextrasÄƒ")) {
                    const titleWithoutEmoji = sectionConfig.title.replace(/(\p{Emoji_Presentation}|\p{Extended_Pictographic}|ðŸ’¬|ðŸŒŸ|ðŸ”„|ðŸ”—|ðŸ”|ðŸ§ |ðŸŽ­|ðŸ’ª|â“|ðŸ‘Ÿ|ðŸ’–)\s*/gu, '').trim();
                    const patternTitleText = new RegExp(`^${titleWithoutEmoji.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}:?\\s*`, "im");
                    contentText = contentText.replace(patternTitleText, "").trim();

                    if (sectionConfig.isList && (contentText.includes('* ') || contentText.includes('- '))) { 
                        const listElement = document.createElement("ul");
                        const items = contentText.split(/\s*\n?\s*[\*-]\s+/) 
                                          .map(item => item.trim())
                                          .filter(item => item.length > 0);
                        if (items.length === 0 && (contentText.startsWith("* ") || contentText.startsWith("- "))) {
                            items.push(contentText.substring(2).trim());
                        }

                        items.forEach(itemText => {
                            const listItem = document.createElement("li");
                            listItem.innerHTML = itemText.replace(/\n/g, '<br>');
                            listElement.appendChild(listItem);
                        });
                        sectionDiv.appendChild(listElement);
                    } else {
                        const paragraphElement = document.createElement("p");
                        paragraphElement.innerHTML = contentText.replace(/\n/g, '<br>');
                        sectionDiv.appendChild(paragraphElement);
                    }
                } else {
                    const unavailableText = document.createElement("p");
                    unavailableText.style.fontStyle = "italic";
                    unavailableText.textContent = (contentText && contentText.startsWith("(SecÈ›iune neextrasÄƒ")) ? contentText : "Indisponibil sau secÈ›iune goalÄƒ.";
                    sectionDiv.appendChild(unavailableText);
                }
                itemContainer.appendChild(sectionDiv);
            });

        } else if (isLikelyOldFormat) {
            const oldFormatSections = [
                { title: "âœï¸ Paragraf Empatic", key: "paragraf", isList: false },
                { title: "â“ ÃŽntrebare de ReflecÈ›ie", key: "intrebare", isList: false },
                { title: "ðŸ› ï¸ Recomandare TerapeuticÄƒ", key: "recomandare", isList: false },
                { title: "ðŸ” Distorsiuni Cognitive", key: "distorsiuni", isList: true },
                { title: "ðŸ§  Scheme Cognitive", key: "scheme", isList: true },
                { title: "ðŸ§â€â™‚ï¸ Evaluare Adult SÄƒnÄƒtos", key: "adult_sanatos_eval", isList: false }
            ];

            oldFormatSections.forEach(sectionConfig => {
                const sectionDiv = document.createElement("div");
                sectionDiv.className = "feedback-section";
                const sectionTitleElement = document.createElement("h5");
                sectionTitleElement.textContent = sectionConfig.title + ":";
                sectionDiv.appendChild(sectionTitleElement);
                let contentText = entry[sectionConfig.key];
                if (typeof contentText === 'string' && contentText.trim() !== "") {
                    if (sectionConfig.isList && (contentText.includes('* ') || contentText.includes('- '))) {
                        const listElement = document.createElement("ul");
                        const items = contentText.split(/\s*\n?\s*[\*-]\s+/)
                                          .map(item => item.trim())
                                          .filter(item => item.length > 0);
                        if (items.length === 0 && (contentText.startsWith("* ") || contentText.startsWith("- "))) {
                            items.push(contentText.substring(2).trim());
                        }
                        items.forEach(itemText => {
                            const listItem = document.createElement("li");
                            listItem.innerHTML = itemText.replace(/\n/g, '<br>');
                            listElement.appendChild(listItem);
                        });
                        sectionDiv.appendChild(listElement);
                    } else {
                        const paragraphElement = document.createElement("p");
                        paragraphElement.innerHTML = contentText.replace(/\n/g, '<br>');
                        sectionDiv.appendChild(paragraphElement);
                    }
                } else {
                    const unavailableText = document.createElement("p");
                    unavailableText.style.fontStyle = "italic";
                    unavailableText.textContent = "Indisponibil sau secÈ›iune goalÄƒ.";
                    sectionDiv.appendChild(unavailableText);
                }
                itemContainer.appendChild(sectionDiv);
            });
        } else {
            console.warn("Format de feedback necunoscut Ã®n istoric (nici nou, nici vechi):", entry);
            const unknownFormatDiv = document.createElement("div");
            unknownFormatDiv.className = "feedback-section";
            const titleEl = document.createElement("h5");
            titleEl.textContent = "â‰ï¸ ConÈ›inut Feedback (format necunoscut):";
            unknownFormatDiv.appendChild(titleEl);
            const contentP = document.createElement("p");
            try { 
              contentP.innerHTML = `<pre>${JSON.stringify(entry, null, 2).replace(/\n/g, '<br>')}</pre>`;
            } catch (e) { contentP.textContent = "Nu s-a putut afiÈ™a conÈ›inutul detaliat (eroare la serializare).";}
            unknownFormatDiv.appendChild(contentP);
            itemContainer.appendChild(unknownFormatDiv);
        }
        containerElement.appendChild(itemContainer);
    });
}

   function adaugaCard(rowData) {
      const cardViewContainer = document.getElementById("cardViewContainer");
      let card = cardViewContainer.querySelector(`.response-card[data-id="${rowData.id}"]`);

      const cardExists = !!card;

      if (!card) { 
            card = document.createElement("div");
            card.className = "response-card";
            card.setAttribute("data-id", rowData.id);
            card.innerHTML = `
                <div class="card-header"> Data: ${rowData.date || new Date(rowData.timestamp?.seconds * 1000 || Date.now()).toLocaleDateString("ro-RO")} - SituaÈ›ia: ${(rowData.situatie || '').substring(0,60)}...</div>
                <div class="card-content">
                <h4>Explorarea situaÈ›iei È™i a nevoilor</h4>
                <p><strong>Care este situaÈ›ia?</strong> ${rowData.situatie || ''}</p>
                <p><strong>Ce Ã®mi trece prin minte?</strong> ${rowData.ganduri || ''}</p>
                <p><strong>Cum mÄƒ face acel gÃ¢nd sÄƒ mÄƒ simt?</strong> ${rowData.emotii || ''}</p>
                <p><strong>Ce mod este activ?</strong> ${rowData.mod_activ || ''}</p>
                <p><strong>Ce comportament simÈ›i cÄƒ adopÈ›i?</strong> ${rowData.comportament || ''}</p>
                <p><strong>Care sunt nevoile tale mai profunde?</strong> ${rowData.nevoi_profunde || ''}</p>
                <p><strong>MÄƒ ajutÄƒ comportamentul meu sÄƒ Ã®ndeplinesc aceste nevoi?</strong> ${rowData.ajutor_comportament || ''}</p>
                <p><strong>Cum ar gÃ¢ndi È™i cum s-ar comporta Adultul SÄƒnÄƒtos?</strong> ${rowData.adult_sanatos || ''}</p>

                <h4>Analiza gÃ¢ndurilor È™i a percepÈ›iilor</h4>
                <p><strong>Ce mÄƒ face sÄƒ cred cÄƒ gÃ¢ndul automat este adevÄƒrat?</strong> ${rowData.dovezi_adevar || ''}</p>
                <p><strong>Ce mÄƒ face sÄƒ cred cÄƒ nu este adevÄƒrat?</strong> ${rowData.dovezi_fals || ''}</p>
                <p><strong>ExistÄƒ o explicaÈ›ie alternativÄƒ?</strong> ${rowData.explicatie_alternativa || ''}</p>
                <p><strong>Care este cel mai rÄƒu lucru care s-ar putea Ã®ntÃ¢mpla?</strong> ${rowData.scenariu_negativ || ''}</p>
                <p><strong>Care este cel mai bun lucru care s-ar putea Ã®ntÃ¢mpla?</strong> ${rowData.scenariu_optimist || ''}</p>
                <p><strong>Care este cel mai realist rezultat?</strong> ${rowData.rezultat_realist || ''}</p>
                <p><strong>Ce s-ar Ã®ntÃ¢mpla dacÄƒ mi-aÈ™ schimba modul de gÃ¢ndire?</strong> ${rowData.schimbare_gandire || ''}</p>
                <p><strong>Ce i-aÈ™ spune unui prieten dacÄƒ ar fi Ã®n aceeaÈ™i situaÈ›ie?</strong> ${rowData.sfat_prieten || ''}</p>

                <h4>ÃŽntrebÄƒri pentru claritate È™i reflecÈ›ie suplimentarÄƒ</h4>
                <p><strong>VÄƒd doar partea rea a lucrurilor?</strong> ${rowData.partea_rea || ''}</p>
                <p><strong>ÃŽmi asum responsabilitatea pentru lucruri care nu au stat Ã®n puterea mea?</strong> ${rowData.responsabilitate || ''}</p>
                <p><strong>MÄƒ condamn Ã®n baza unui singur eveniment?</strong> ${rowData.condamnare || ''}</p>
                <p><strong>Privesc situaÈ›ia Ã®n termeni extremi?</strong> ${rowData.termeni_extremi || ''}</p>
                <p><strong>Exagerez situaÈ›ia?</strong> ${rowData.exagerare || ''}</p>
                <p><strong>ExistÄƒ È™i alÈ›i factori responsabili?</strong> ${rowData.factori_responsabili || ''}</p>
                <p><strong>Am sÄƒrit direct la concluzii?</strong> ${rowData.concluzii || ''}</p>
                <p><strong>ÃŽmi pun Ã®ntrebÄƒri fÄƒrÄƒ rÄƒspuns?</strong> ${rowData.intrebari_fara_raspuns || ''}</p>
                <p><strong>MÄƒ concentrez doar asupra slÄƒbiciunilor mele?</strong> ${rowData.slabiciuni || ''}</p>
                <p><strong>MÄƒ zbat prea mult gÃ¢ndind la cum ar trebui sÄƒ fie lucrurile?</strong> ${rowData.cum_ar_trebui || ''}</p>
                <p><strong>MÄƒ aÈ™tept sÄƒ fiu perfect?</strong> ${rowData.perfectiune || ''}</p>
                
                <div class="card-actions">
                    <button class="generate-ai-feedback-button">RegenereazÄƒ Feedback AI</button>
                    <button class="delete-all-feedback-button">È˜terge Tot Istoricul AI</button>
                    <button class="delete-button">È˜terge FiÈ™a</button>
                </div>
                <div class="ai-feedback-history-container">
                </div>
                </div>
            `;

            card.querySelector('.card-header').addEventListener('click', () => {
                card.classList.toggle('open');
            });

            card.querySelector('.delete-button').addEventListener('click', (event) => {
                event.stopPropagation(); 
                stergeCard(rowData.id, card);
            });

            const generateManualButton = card.querySelector('.generate-ai-feedback-button');
            if (generateManualButton) {
                generateManualButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    const button = event.target;
                    const originalButtonText = button.textContent;
                    button.textContent = 'Se genereazÄƒ...';
                    button.disabled = true;
                    
                    try {
                        console.log(`Regenerare manualÄƒ feedback AI pentru fiÈ™a: ${rowData.id}`);
                        const docSnapshot = await getDoc(doc(db, "raspunsuri", rowData.id));
                        let currentCardData;
                        if (docSnapshot.exists()) {
                            currentCardData = { id: docSnapshot.id, ...docSnapshot.data() };
                        } else {
                            alert("FiÈ™a nu mai existÄƒ Ã®n baza de date.");
                            console.warn(`FiÈ™a ${rowData.id} nu a fost gÄƒsitÄƒ pentru regenerare feedback.`);
                             button.textContent = originalButtonText;
                             button.disabled = false;
                            return; 
                        }
                        const newFeedback = await genereazaSiProceseazaFeedbackAI(currentCardData, currentCardData.id);
                        
                        const updatedDoc = await getDoc(doc(db, "raspunsuri", currentCardData.id));
                        if (updatedDoc.exists()) {
                           afiseazaIstoricFeedback(card.querySelector('.ai-feedback-history-container'), updatedDoc.data().feedback_history);
                            if (newFeedback && !newFeedback.error && !newFeedback.error_parsing) {
                                alert("Noul feedback AI a fost generat È™i adÄƒugat la istoric!");
                            } else if (newFeedback) {
                                alert(`Feedback AI: ${newFeedback.paragraf || newFeedback.empatie_initiala || 'A apÄƒrut o problemÄƒ la generare.'}`);
                            }
                        }
                    } catch (error) {
                        console.error("Eroare la regenerarea manualÄƒ a feedback-ului AI:", error);
                        alert("A apÄƒrut o eroare la regenerarea feedback-ului AI.");
                    } finally {
                        button.textContent = originalButtonText;
                        button.disabled = false;
                    }
                });
            }
        
            const deleteAllFeedbackButton = card.querySelector('.delete-all-feedback-button');
            if (deleteAllFeedbackButton) {
                deleteAllFeedbackButton.addEventListener('click', async (event) => {
                    event.stopPropagation(); 
                    if (confirm(`SunteÈ›i sigur cÄƒ doriÈ›i sÄƒ È™tergeÈ›i TOT istoricul de feedback AI pentru aceastÄƒ fiÈ™Äƒ (${(rowData.situatie || rowData.id).substring(0,30)}...)? AceastÄƒ acÈ›iune este ireversibilÄƒ.`)) {
                        const button = event.target;
                        const originalText = button.textContent;
                        button.textContent = 'Se È™terge...';
                        button.disabled = true;
                        try {
                            const docRef = doc(db, "raspunsuri", rowData.id);
                            const fieldsToDelete = {
                                feedback_history: [], 
                                feedback_empatie_initiala: deleteField(), 
                                feedback_puncte_forte: deleteField(),
                                feedback_tipare_principale: deleteField(),
                                feedback_conexiuni_cheie: deleteField(),
                                feedback_distorsiuni_identificate: deleteField(),
                                feedback_scheme_activate: deleteField(),
                                feedback_moduri_implicate: deleteField(),
                                feedback_perspectiva_adult_sanatos: deleteField(),
                                feedback_intrebare_finala_reflectie: deleteField(),
                                feedback_sugestie_mic_pas: deleteField(),
                                feedback_incurajare_finala: deleteField(),
                                feedback_model: deleteField(),
                                feedback_timestamp: deleteField(),
                                feedback_error: deleteField(),
                                feedback_error_parsing: deleteField(),
                                feedback_paragraf: deleteField(),
                                feedback_intrebare: deleteField(),
                                feedback_recomandare: deleteField(),
                                feedback_distorsiuni: deleteField(), 
                                feedback_scheme: deleteField(),     
                                feedback_adult_sanatos_eval: deleteField() // corectat aici `feedback_adult_eval` la `feedback_adult_sanatos_eval` dacÄƒ acesta era cÃ¢mpul corect
                            };
                            await updateDoc(docRef, fieldsToDelete);
                            console.log(`Istoricul feedback AI È™i cÃ¢mpurile asociate È™terse pentru ${rowData.id}`);
                            
                            const historyContainer = card.querySelector('.ai-feedback-history-container');
                            if (historyContainer) {
                                afiseazaIstoricFeedback(historyContainer, []); 
                            }
                            alert("Istoricul feedback-ului AI a fost È™ters cu succes!");
                        } catch (error) {
                            console.error("Eroare la È™tergerea istoricului de feedback AI:", error);
                            alert("A apÄƒrut o eroare la È™tergerea istoricului.");
                        } finally {
                            button.textContent = originalText;
                            button.disabled = false;
                        }
                    }
                });
            }

            if (cardViewContainer.firstChild) {
                cardViewContainer.insertBefore(card, cardViewContainer.firstChild);
            } else {
                cardViewContainer.appendChild(card);
            }
      }

      const historyContainer = card.querySelector('.ai-feedback-history-container');
      if (historyContainer) {
           afiseazaIstoricFeedback(historyContainer, rowData.feedback_history || []);
      } else {
          console.warn("Containerul pentru istoricul feedback-ului AI nu a fost gÄƒsit Ã®n cardul:", rowData.id);
      }
    }

    async function loadTableData(userId, collabIdForLoad = null, ownerIdForCollabView = null) {
        if (!userId && !ownerIdForCollabView) {
            console.warn("loadTableData apelat fÄƒrÄƒ userId sau ownerIdForCollabView. Nu se Ã®ncarcÄƒ datele pentru carduri.");
            return;
        }

        if (collabIdForLoad && dataAlreadyLoaded && document.body.classList.contains('collab-view-loaded')) { 
            console.log("Cardurile pentru colaborator par a fi deja Ã®ncÄƒrcate È™i vizualizarea e setatÄƒ.");
            return;
        }
        
        console.log("ÃŽncÄƒrcare/ReÃ®ncÄƒrcare carduri din Firestore...");
        const cardViewContainer = document.getElementById("cardViewContainer");
        if (!cardViewContainer) return;
        cardViewContainer.innerHTML = '<p style="text-align:center; margin-top:20px;">Se Ã®ncarcÄƒ fiÈ™ele...</p>'; 

        try {
            let q;
            if (ownerIdForCollabView) { 
                console.log(`Filtrare carduri pentru colaborare (owner: ${ownerIdForCollabView})`);
                q = query(collection(db, "raspunsuri"), where("ownerUid", "==", ownerIdForCollabView));
            } else if (userId) { 
                console.log(`Filtrare carduri pentru utilizatorul logat: ${userId}`);
                q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId));
            } else { return; }

            const querySnapshot = await getDocs(q);
             cardViewContainer.innerHTML = ''; 

            if (querySnapshot.empty) {
                console.log("Nicio fiÈ™Äƒ gÄƒsitÄƒ pentru filtrele aplicate.");
                cardViewContainer.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio fiÈ™Äƒ de monitorizare gÄƒsitÄƒ ${ownerIdForCollabView ? 'pentru acest utilizator.' : 'pentru contul tÄƒu.' }</p>`;
                if(collabIdForLoad) {
                    dataAlreadyLoaded = true; 
                    document.body.classList.add('collab-view-loaded');
                }
                return;
            }
            
            const documents = [];
            querySnapshot.forEach((doc) => {
                documents.push({ id: doc.id, ...doc.data() });
            });

            documents.sort((a, b) => {
                let dateA, dateB;
                // ÃŽncearcÄƒ sÄƒ parsezi `a.date` (DD.MM.YYYY)
                if (a.date && typeof a.date === 'string' && a.date.includes('.')) {
                    const partsA = a.date.split('.');
                    if (partsA.length === 3) {
                         // CreeazÄƒ un obiect Date corect: an, lunÄƒ (0-indexat), zi
                        dateA = new Date(parseInt(partsA[2]), parseInt(partsA[1]) - 1, parseInt(partsA[0])).getTime();
                    } else dateA = 0;
                } else dateA = 0;

                // ÃŽncearcÄƒ sÄƒ parsezi `b.date` (DD.MM.YYYY)
                if (b.date && typeof b.date === 'string' && b.date.includes('.')) {
                     const partsB = b.date.split('.');
                     if (partsB.length === 3) {
                        dateB = new Date(parseInt(partsB[2]), parseInt(partsB[1]) - 1, parseInt(partsB[0])).getTime();
                     } else dateB = 0;
                } else dateB = 0;
                
                // Fallback la timestamp-ul din Firestore (dacÄƒ existÄƒ È™i 'date' e invalid)
                const timeA = (dateA && !isNaN(dateA)) ? dateA : (a.timestamp?.seconds ? a.timestamp.toMillis() : 0);
                const timeB = (dateB && !isNaN(dateB)) ? dateB : (b.timestamp?.seconds ? b.timestamp.toMillis() : 0);
                
                return timeB - timeA; 
            });
            
            documents.forEach(docData => {
                adaugaCard(docData);
            });

            if (collabIdForLoad) {
                dataAlreadyLoaded = true; 
                document.body.classList.add('collab-view-loaded');
            }

        } catch (error) {
            console.error("Eroare la Ã®ncÄƒrcarea cardurilor din Firestore:", error.message, error.stack);
            cardViewContainer.innerHTML = '<p style="text-align:center; margin-top:20px; color:red;">A apÄƒrut o eroare la Ã®ncÄƒrcarea datelor din fiÈ™e.</p>';
        }
    }

    async function populateTableData(userId) {
        const tableBody = document.getElementById("tableBody");
        if (!tableBody || !userId) return;
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('collabId')) return; 
        console.log("FuncÈ›ia populateTableData (tabel) nu este utilizatÄƒ activ, dar a fost apelatÄƒ.");
    }

    async function stergeCard(id, cardElement) { 
        if (confirm("SunteÈ›i sigur cÄƒ doriÈ›i sÄƒ È™tergeÈ›i aceastÄƒ fiÈ™Äƒ È™i tot feedback-ul AI asociat? AceastÄƒ acÈ›iune este ireversibilÄƒ.")) {
            try {
                await deleteDoc(doc(db, "raspunsuri", id));
                cardElement.remove();
                console.log(`FiÈ™a ${id} a fost È™tearsÄƒ.`);
                alert("FiÈ™a a fost È™tearsÄƒ cu succes!");
            } catch (error) {
                console.error("Eroare la È™tergerea fiÈ™ei din Firestore:", error);
                alert("Eroare la È™tergerea fiÈ™ei.");
            }
        }
    }

    async function generateCollaborationLink() {
        const user = auth.currentUser;
        if (!user) {
            alert("Trebuie sÄƒ fiÈ›i autentificat pentru a genera un link de colaborare.");
            return;
        }
        
        const existingCollabQuery = query(collection(db, "collaborations"), where("owner", "==", user.uid), limit(1)); 
        const querySnapshot = await getDocs(existingCollabQuery);

        let pinCode;
        if (!querySnapshot.empty) {
            const collabDoc = querySnapshot.docs[0];
            const collabLink = `${window.location.origin}${window.location.pathname}?collabId=${collabDoc.id}`;
            const existingPin = collabDoc.data().pin;
            
            const renew = confirm(`Ai deja un link de colaborare activ (PIN: ${existingPin}).\nLink: ${collabLink}\n\nDoreÈ™ti sÄƒ generezi un PIN nou pentru acest link? Anularea va pÄƒstra PIN-ul existent.`);
            if (renew) {
                 pinCode = prompt("IntroduceÈ›i un nou cod PIN numeric (minim 4 cifre):");
                 if (pinCode && /^\d{4,}$/.test(pinCode)) {
                    await updateDoc(doc(db, "collaborations", collabDoc.id), { pin: pinCode, updatedAt: new Date() });
                    prompt(`PIN actualizat! Link-ul de colaborare rÄƒmÃ¢ne acelaÈ™i. Noul PIN este: ${pinCode}.\nLink: ${collabLink}`, `Link: ${collabLink}\nPIN nou: ${pinCode}`);
                 } else if(pinCode !== null) { 
                    alert("Cod PIN invalid. Trebuie sÄƒ fie numeric È™i minim 4 cifre. PIN-ul vechi a fost pÄƒstrat.");
                 }
            } else { 
                 prompt(`Link de colaborare existent (PIN: ${existingPin}). ÃŽl poÈ›i redistribui:\nLink È™i PIN:`, `${collabLink} (PIN: ${existingPin})`);
            }
            return; 
        }

        pinCode = prompt("IntroduceÈ›i un cod PIN numeric (minim 4 cifre) pentru noul link de colaborare:");
        if (!pinCode || !/^\d{4,}$/.test(pinCode)) { 
            alert("Cod PIN invalid. Trebuie sÄƒ fie numeric È™i sÄƒ conÈ›inÄƒ cel puÈ›in 4 cifre.");
            return;
        }
        try {
            const docRef = await addDoc(collection(db, "collaborations"), { 
                owner: user.uid, 
                pin: pinCode, 
                createdAt: new Date() 
            });
            const collaborationLink = `${window.location.origin}${window.location.pathname}?collabId=${docRef.id}`;
            prompt(`Link de colaborare generat! Distribuie acest link ÃŽMPREUNÄ‚ cu codul PIN.\nLink: ${collaborationLink}\nPIN: ${pinCode}`, `Link: ${collaborationLink} (PIN: ${pinCode})`);
        } catch (error) {
            console.error("Eroare la generarea link-ului de colaborare:", error);
            alert("A apÄƒrut o eroare la generarea linkului.");
        }
    }

    window.addEventListener('DOMContentLoaded', async () => {
        console.log("DOMContentLoaded - Se verificÄƒ pentru modul colaborare.");
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (collabId) {
            dataAlreadyLoaded = false; 
            document.body.classList.add("collab-view"); 
            ['exercitiuForm', 'generateLinkButton', '.form-container > h2:not(.collab-title)', '.form-container > p', '.form-container .progress-bar', '.table-container'].forEach(sel => {
                const el = document.querySelector(sel) || document.getElementById(sel);
                if (el && el.id !== 'exercitiuForm') el.style.display = 'none'; 
                else if (el && el.id === 'exercitiuForm') { 
                    const formContainer = document.querySelector('.form-container');
                    if (formContainer) {
                        // PÄƒstreazÄƒ doar un titlu simplu pentru colaborare. Vechiul titlu e ascuns de `:not(.collab-title)`
                        if (!formContainer.querySelector('h2.collab-title')) {
                             const collabTitle = document.createElement('h2');
                             collabTitle.className = 'collab-title'; // AdaugÄƒ o clasÄƒ pentru a-l putea stiliza sau selecta diferit
                             collabTitle.style.textAlign = 'center';
                             collabTitle.textContent = 'Vizualizare FiÈ™Äƒ Colaborare';
                             formContainer.innerHTML = ''; // GoleÈ™te mai Ã®ntÃ¢i
                             formContainer.appendChild(collabTitle);
                        }
                    }
                }
            });
            
            setTimeout(async () => { 
                const pin = prompt("IntroduceÈ›i codul PIN pentru a vizualiza fiÈ™ele de colaborare:");
                if (!pin) {
                    alert("PIN-ul este necesar pentru a continua."); window.location.href = "login.html"; return;
                }
                try {
                    const collabDocRef = doc(db, "collaborations", collabId);
                    const collabSnapshot = await getDoc(collabDocRef);
                    if (collabSnapshot.exists()) {
                        const collabData = collabSnapshot.data();
                        if (collabData.pin === pin) {
                            console.log("PIN corect. ÃŽncÄƒrcare date colaborator pentru owner:", collabData.owner);
                            document.title = "Vizualizare FiÈ™Äƒ Colaborare - Psiho";
                            const formContainerTitle = document.querySelector('.form-container h2.collab-title');
                            if (formContainerTitle) formContainerTitle.textContent = "FiÈ™e de Colaborare Partajate";
                            
                            const cardView = document.getElementById('cardViewContainer');
                            if(cardView) cardView.innerHTML = '<p style="text-align:center;">Se Ã®ncarcÄƒ fiÈ™ele partajate...</p>'; 

                            await loadTableData(null, collabId, collabData.owner); 
                        } else {
                            alert("PIN incorect."); window.location.href = "login.html";
                        }
                    } else {
                        alert("Link de colaborare invalid sau expirat."); window.location.href = "login.html";
                    }
                } catch (error) {
                    console.error("Eroare la accesarea datelor de colaborare:", error);
                    alert("Eroare la accesarea datelor de colaborare. VerificaÈ›i link-ul È™i PIN-ul."); window.location.href = "login.html";
                }
            }, 100);
        }
    });
    </script>
    <style>
body {
    font-family: 'Ubuntu', 'Roboto', 'Montserrat', 'Nunito Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    margin: 0;
    padding: 20px;
    background: linear-gradient(to right, #ece9e6, #ffffff);
    color: #333;
    box-sizing: border-box;
}
.form-container {max-width: 900px; margin: 20px auto; background: #fff; padding: 30px; box-shadow: 0 16px 24px rgba(0,0,0,0.2); border-radius: 15px; border: 3px solid #87CEFA; transition: transform 0.3s ease;}
.form-container:hover {transform: scale(1.01);}
.progress-bar {width: 100%; background-color: #f3f3f3; border-radius: 25px; overflow: hidden; margin-bottom: 20px;}
.progress {height: 20px; width: 0; background-color: #87CEFA; transition: width 0.4s ease;}
.question-card {margin-bottom: 20px; padding: 20px; background: #fff; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: all 0.3s;}
.question-card:hover {box-shadow: 0 6px 15px rgba(0,0,0,0.15);}
.question-card h3 {font-weight: 700; font-size: 1.2em; margin-top: 0; margin-bottom: 10px;} /* Va moÈ™teni Ubuntu */
.question-card p {font-weight: 400; font-size: 0.95em; margin-bottom: 15px; color: #555; line-height: 1.6;} /* Am ajustat la font-weight: 400 pentru lizibilitate mai bunÄƒ cu Ubuntu */

textarea { /* Stiluri generale pentru textarea; textarea din chat e stilizat separat */
    width: calc(100% - 22px);
    padding: 10px;
    font-size: 16px; /* Poate fi ajustat la 1rem sau 0.95em pentru consistenÈ›Äƒ */
    font-family: inherit; /* Va moÈ™teni Ubuntu */
    border-radius: 8px;
    border: 1px solid #ccc;
    resize: vertical;
    min-height: 60px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: border-color 0.3s;
}
textarea:focus {border-color: #87CEFA; box-shadow: 0 2px 8px rgba(135,206,250,0.5); outline: none;}

input[type="submit"], button { /* Butoanele generale, cele din chat sunt stilizate separat */
    margin-top: 20px;
    padding: 12px 25px;
    font-family: inherit; /* Va moÈ™teni Ubuntu */
    font-size: 1em; /* Recomandat sÄƒ folosim em sau rem pentru consistenÈ›Äƒ */
    font-weight: 500; /* Ubuntu Medium */
    background: linear-gradient(to right, #87CEFA, #6bb9e7);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s, transform 0.2s;
}
input[type="submit"]:hover, button:hover {background: linear-gradient(to right, #6bb9e7, #4A90E2); transform: translateY(-2px);}
button:disabled { background: #ccc !important; color: #666 !important; cursor: not-allowed !important; transform: translateY(0) !important; }

.form-step {display: none;}
.form-step-active {display: block; animation: fadeIn 0.7s ease-in-out;}
@keyframes fadeIn { 0% {opacity: 0; transform: translateY(10px);} 100% {opacity: 1; transform: translateY(0);} }
.step-navigation {text-align: center; margin-top: 20px;}
.step-navigation button {margin: 0 10px;}
.table-container {margin:30px auto; padding:20px; background:#fff; border-radius:15px; box-shadow:0 4px 10px rgba(0,0,0,0.1); overflow-x:auto; max-width:900px;}
.card-view {display: flex; flex-direction: column; gap: 20px; max-width: 900px; margin: 30px auto;}
.response-card {background: #f9f9ff; padding: 0; border-radius: 15px; box-shadow: 0 8px 16px rgba(0,0,0,0.12); transition: box-shadow 0.3s ease; position: relative; overflow: hidden;}
.response-card:hover {box-shadow: 0 10px 20px rgba(0,0,0,0.18);}
.response-card .card-header {font-weight: 500; font-size: 1.1em; cursor: pointer; background: #87CEFA; padding: 12px 20px; color: #fff; text-align: left; position: relative; display: flex; justify-content: space-between; align-items: center;}
.response-card .card-header::after {content: 'â–¼'; font-size: 0.8em; transition: transform 0.3s ease;}
.response-card.open .card-header::after {transform: rotate(180deg);}
.response-card .card-content {max-height: 0; margin-top: 0; padding: 0 20px; background: #fff; line-height: 1.6; overflow: auto; transition: max-height 0.5s ease-out, padding-top 0.5s ease-out, padding-bottom 0.5s ease-out;}
.response-card.open .card-content {max-height: 3500px; padding-top: 15px; padding-bottom: 15px;}
.response-card .card-content p {margin-bottom: 12px; border-left: 3px solid #87CEFA; padding-left: 10px;}
.response-card .card-content p strong {font-weight: 700;} /* Ubuntu Bold pentru strong */
.response-card h4 {text-align: left; color: #4A90E2; font-weight: 700; margin-top: 20px; margin-bottom: 10px; font-size: 1.05em;}
.response-card h4:first-child {margin-top: 0;}
.card-actions {text-align: center; margin-top: 20px; padding-bottom: 10px; border-top: 1px solid #eee; padding-top: 15px;}
.card-actions button {font-size: 0.9em; margin: 5px;} /* Va moÈ™teni Ubuntu, font-weight 500 de la regulile generale pentru butoane */
.generate-ai-feedback-button {background-color: #5cb85c;}
.generate-ai-feedback-button:hover {background-color: #4cae4c;}
.delete-all-feedback-button {background-color: #ffc107;}
.delete-all-feedback-button:hover {background-color: #e0a800;}
.delete-button {background-color: #dc3545 !important;}
.delete-button:hover {background-color: #c82333 !important;}

.confirmation-message {
    display: none; text-align: center; padding: 15px;
    border: 1px solid transparent; border-radius: 5px;
    margin-top: 20px; animation: fadeIn 0.5s;
    font-weight: 500; /* Ubuntu Medium */
}
.confirmation-message.success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
.confirmation-message.error { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
.confirmation-message.warning { background-color: #fff3cd; color: #856404; border-color: #ffeeba; }

.collaboration-section {text-align:center; margin-top:30px; padding-bottom:20px;}
.collaboration-section button {background-color:#f0ad4e;} /* Va moÈ™teni Ubuntu, font-weight 500 */
.collaboration-section button:hover {background-color:#ec971f;}
.feedback-entry-card {background:#eef6ff; padding:15px; border-left:4px solid #4A90E2; border-radius:5px; margin-bottom:15px; font-size:0.95em; line-height:1.6;}
.feedback-timestamp {color:#555; font-size:0.9em; margin-bottom:12px;}
.feedback-section {margin-bottom:12px;}
.feedback-section h5 {font-size:1em; font-weight:700; color:#2c5282; margin-top:0; margin-bottom:6px;} /* Ubuntu Bold */
.feedback-section p, .feedback-section ul {margin-top:0; margin-bottom:8px; color:#1e293b;}
.feedback-section ul {padding-left:25px; list-style-position:outside; list-style-type:disc;}
.feedback-section li {margin-bottom:4px;}

/* --- MODERN CHAT STYLING with UBUNTU FONT --- */
.chat-container {
    display: flex;
    flex-direction: column;
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: clamp(350px, 50vw, 450px);
    max-height: calc(100vh - 100px);
    background: #ffffff;
    border-radius: 16px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.05);
    z-index: 1000;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
}

.chat-container h3 {
    text-align: center;
    color: #3d425c;
    margin: 0;
    padding: 18px 20px;
    font-size: 1.15em;
    font-weight: 500; /* Ubuntu Medium */
    background-color: #f8f9fc;
    border-bottom: 1px solid #e9edf2;
    flex-shrink: 0;
}

#chatMessages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    background: #ffffff;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

#chatMessages::-webkit-scrollbar { width: 6px; }
#chatMessages::-webkit-scrollbar-track { background: #f0f2f5; border-radius: 10px; }
#chatMessages::-webkit-scrollbar-thumb { background: #bfc8d3; border-radius: 10px; }
#chatMessages::-webkit-scrollbar-thumb:hover { background: #a8b3bf; }

.chat-message {
    padding: 12px 18px;
    border-radius: 20px;
    max-width: 82%;
    word-wrap: break-word;
    line-height: 1.55;
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    font-size: 0.96em;
    font-weight: 400; /* Ubuntu Regular for message text */
    position: relative;
}

.user-message {
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    color: white;
    align-self: flex-end;
    margin-left: auto;
    border-bottom-right-radius: 6px;
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    border-bottom-left-radius: 20px;
}

.ai-message {
    background: #f0f2f5;
    color: #2c3e50;
    align-self: flex-start;
    margin-right: auto;
    border-bottom-left-radius: 6px;
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;
    /* JavaScript-ul va seta white-space: pre-wrap; care va ajuta la afiÈ™area artei ASCII
       cu fontul monospace definit mai jos, chiar dacÄƒ textul normal moÈ™teneÈ™te Ubuntu. */
    font-family: 'Ubuntu', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
}
.ai-message em, .ai-message i {
    font-family: 'Ubuntu', inherit; /* AsigurÄƒ Ubuntu È™i moÈ™tenirea, 'inherit' preia fallback-urile */
    font-style: italic;
    font-weight: 400; /* Greutatea italic importatÄƒ */
}
.ai-message strong, .ai-message b {
    font-family: 'Ubuntu', inherit;
    font-weight: 700; /* Greutatea bold importatÄƒ */
}

.ai-message.ai-error {
    background-color: #ffe3e3;
    color: #b71c1c;
    border: 1px solid #ffc5c5;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
}

.chat-input-area {
    padding: 15px 20px;
    border-top: 1px solid #e9edf2;
    background-color: #f8f9fc;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#chatInput {
    width: 100%;
    padding: 12px 18px;
    border-radius: 12px;
    border: 1px solid #d9e0ea;
    resize: none;
    min-height: 48px;
    max-height: 120px;
    box-sizing: border-box;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
    font-size: 0.96em;
    font-weight: 400;
    line-height: 1.5;
    transition: border-color 0.2s, box-shadow 0.2s;
    background-color: #ffffff;
}
#chatInput:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 3.5px rgba(0,123,255,.18);
    outline: none;
}

#sendChatMessageButton {
    padding: 12px 20px;
    width: 100%;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
    font-size: 1em;
    font-weight: 500; /* Ubuntu Medium */
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 12px;
    transition: background-color 0.2s, transform 0.15s ease-out;
    cursor: pointer;
}
#sendChatMessageButton:hover:not(:disabled) { background-color: #0069d9; transform: translateY(-2px); }
#sendChatMessageButton:active:not(:disabled) { transform: translateY(-1px); }
#sendChatMessageButton:disabled { background-color: #c3d9f0 !important; color: #7c8da3 !important; cursor: not-allowed !important; transform: translateY(0) !important; }

#chatStatus {
    font-size: 0.85em;
    color: #6c757d;
    text-align: center;
    min-height: 1.2em;
    padding-bottom: 0;
    flex-shrink: 0;
    font-weight: 400; /* Ubuntu Regular */
}

#toggleChatButton {
    position: fixed;
    bottom: 25px;
    right: 25px;
    padding: 0;
    z-index: 1001;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 28px; /* Va folosi un simbol, nu litere Ubuntu direct */
    box-shadow: 0 5px 15px rgba(0, 123, 255, 0.25);
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
}
#toggleChatButton:hover { background-color: #0062cc; transform: scale(1.12) rotate(12deg); box-shadow: 0 7px 20px rgba(0, 98, 204, 0.35); }

.chat-container:not([style*="display: flex"]) { display: none !important; }
/* --- SFÃ‚RÈ˜ITUL STILURILOR MODERNE PENTRU CHAT --- */

@media (max-width: 768px) {
    body {padding:10px;} /* Ubuntu va fi moÈ™tenit */
    .form-container, .table-container, .card-view {padding:15px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);}
    .form-container > button, .step-navigation button {font-size:16px; padding:10px 20px;} /* Ubuntu Medium moÈ™tenit/setat */
    .card-actions button {font-size:0.85em; padding:7px 12px;}
    .question-card h3, .response-card .card-header {font-size:1.05em;}
    .question-card p, .response-card .card-content p {font-size:0.9em; font-weight: 400;} /* Ubuntu Regular */
    
    .chat-container { 
        width: calc(100% - 30px);
        max-height: calc(100vh - 110px);
        bottom: 15px;
        left: 15px;
        right: 15px;
        border-radius: 12px;
        font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif; /* Se asigurÄƒ aplicarea */
    }
    .chat-container h3 { padding: 15px; font-size: 1.1em; }
    #chatMessages { padding: 15px; gap: 10px; } 
    .chat-message { padding: 10px 15px; font-size: 0.92em; max-width: 85%; border-radius: 18px; }
     .user-message { border-bottom-right-radius: 5px; border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-left-radius: 18px;}
     .ai-message { border-bottom-left-radius: 5px; border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-right-radius: 18px;}

    #toggleChatButton { width: 55px; height: 55px; font-size: 24px; bottom: 20px; right: 20px;}

    .chat-input-area { padding: 12px 15px; gap: 8px; }
    #chatInput { padding: 10px 15px; font-size: 0.92em; min-height: 44px; border-radius: 10px; }
    #sendChatMessageButton { padding: 10px 15px; font-size: 0.95em; border-radius: 10px; }

    .table-container {overflow-x:auto;}
    table {display:block; width:100%;}
    thead, tbody, tr {display:block;}
    th {display:none;} 
    tr {margin-bottom:15px; border:1px solid #ddd; border-radius:5px; display:flex; flex-direction:column;}
    td {display:flex; justify-content:space-between; padding:10px; text-align:right; border-bottom:1px solid #eee; position:relative;}
    td:last-child {border-bottom:none;}
    td::before {content:attr(data-label); font-weight:700; text-align:left; margin-right:10px; color:#555; flex-shrink:0; width:auto; padding-right: 10px;} /* Ubuntu Bold pentru label */
    td > *:not(button) {flex-grow:1; word-break:break-word; text-align:left;} 
    td button {width:auto; padding:6px 12px; font-size:0.85em; margin-left:auto; flex-shrink:0;}
    td[colspan="10"] {display:block;}
}
@media (max-width: 480px) {
    .form-container, .table-container, .card-view {padding:10px; margin-left:5px; margin-right:5px; max-width:calc(100% - 10px);}
    .question-card h3, .response-card .card-header {font-size:1em;}
    .question-card p, .response-card .card-content p {font-size:0.85em; font-weight: 400;} /* Ubuntu Regular */
    .form-container textarea {font-size:0.9em; padding:6px; width:calc(100% - 14px);} /* Folosire em */

    .form-container > button, .step-navigation button {font-size:0.9em; padding:8px 15px;} /* Folosire em */
    .card-actions button {font-size:0.8em; padding:6px 10px;}
    .response-card .card-header {padding:10px;}
    .response-card .card-content {padding-left:15px; padding-right:15px; font-size:0.85em;}
    td {flex-direction:column; align-items:flex-start;} 
    td::before {width:100%; margin-bottom:5px; margin-right: 0;}
    td button {align-self:flex-end;}

    .chat-container { 
        max-height: calc(100vh - 90px); 
        bottom: 10px;
        left: 10px;
        right: 10px;
        width: calc(100% - 20px);
        border-radius: 10px;
        font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
    }
    .chat-container h3 { font-size: 1.05em; padding: 12px 15px; }
    #chatMessages { padding: 12px; gap: 8px; }
    .chat-message { font-size: 0.9em; padding: 9px 14px; border-radius: 16px; }
     .user-message { border-bottom-right-radius: 4px; border-top-left-radius: 16px; border-top-right-radius: 16px; border-bottom-left-radius: 16px;}
     .ai-message { border-bottom-left-radius: 4px; border-top-left-radius: 16px; border-top-right-radius: 16px; border-bottom-right-radius: 16px;}

    .chat-input-area { padding: 10px 12px; gap: 8px;}
    #chatInput {font-size: 0.9em; min-height: 42px; padding: 9px 12px; border-radius: 8px;}
    #sendChatMessageButton {font-size: 0.9em; padding: 9px 12px; border-radius: 8px;}
    #toggleChatButton { width: 50px; height: 50px; font-size: 22px; bottom: 15px; right: 15px; }
}

        /* CSS combinat È™i ajustat */
        body {
            font-family: 'Ubuntu', 'Roboto', 'Montserrat', 'Nunito Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            margin: 0; padding: 20px; background: #f0f2f5; 
            color: #333a40; line-height: 1.6;
        }
        .form-container {
            max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
            transition: transform 0.3s ease;
        }
        .progress-bar {width: 100%; background-color: #e9ecef; border-radius: 25px; overflow: hidden; margin-bottom: 25px; height: 12px;}
        .progress {height: 100%; width: 0; background-color: #5c85d6; transition: width 0.4s ease;}
        .question-card {
            margin-bottom: 22px; padding: 20px; background: #fdfdff; 
            border-radius: 8px; box-shadow: 0 3px 8px rgba(0,0,0,0.05);
            border: 1px solid #eef2f7;
        }
        .question-card h3 {
            font-weight: 500; font-size: 1.15em; margin-top: 0; margin-bottom: 10px; color: #334155;
            text-align: left;
        }
        .question-card p {
            font-weight: 400; font-size: 0.95em; margin-bottom: 15px; color: #475569; line-height: 1.65;
            text-align: left;
        }
        .form-container h2.main-form-title {
             font-size: 1.7em; margin-bottom: 10px; text-align: center; color: #2c3840; font-weight: 500;
        }
         .form-container h2.collab-title {
             font-size: 1.6em; margin-bottom: 20px; text-align: center; color: #2c3840; font-weight: 500;
        }
        .form-container > p:not(#confirmationMessage):not(.loading-message):not(.no-entries-message):not(.error-loading-message) {
            text-align: center; margin-top: -5px; margin-bottom: 25px; font-size: 0.95em; color: #556575;
        }
        textarea { 
            width: 100%; padding: 12px 15px; font-size: 1em;
            font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
            resize: vertical; min-height: 70px; 
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
        }
        textarea:focus {border-color: #5c85d6; box-shadow: inset 0 1px 2px rgba(0,0,0,0.06), 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;}
        .form-step-active {display: block; animation: fadeInFormStep 0.5s ease-in-out;}
        @keyframes fadeInFormStep { 0% {opacity: 0; transform: translateY(12px);} 100% {opacity: 1; transform: translateY(0);} }
        .form-step {display: none;}
        .step-navigation {text-align: center; margin-top: 25px; display: flex; justify-content: space-between; gap:15px;}
        .step-navigation button, button#addButton {
            padding: 11px 22px; font-family: inherit; font-size: 1em; font-weight: 500; 
            color: white; border: none; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, transform 0.15s ease-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step-navigation button#prevButton { background-color: #6c757d; }
        .step-navigation button#prevButton:hover { background-color: #5a6268; transform: translateY(-1px); }
        .step-navigation button#nextButton { background-color: #5c85d6; }
        .step-navigation button#nextButton:hover { background-color: #4a6fb5; transform: translateY(-1px); }
        button#addButton { background-color: #28a745; display:block; width:100%; margin-top:20px; font-size: 1.05em;}
        button#addButton:hover:not(:disabled) { background-color: #218838; transform: translateY(-1px); }
        .step-navigation button:disabled, button#addButton:disabled { 
            background: #b0c4de !important; color: #707c8b !important; 
            cursor: not-allowed !important; box-shadow: none !important; transform: translateY(0) !important;
        }
        .confirmation-message, 
        .no-entries-message, .loading-message, .error-loading-message { 
            text-align: center; margin-top:20px; font-style: italic; 
            color: #556575; font-size: 1em; padding:12px; border-radius: 6px; 
        }
        .confirmation-message { font-style: normal; font-weight:500; animation: fadeIn 0.4s; display:none;}
        .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border:1px solid #b3d9c0; }
        .confirmation-message.error   { background-color: #fdecea; color: #b32d21; border:1px solid #f8c6c1; }
        .confirmation-message.warning { background-color: #fff8e1; color: #795508; border:1px solid #ffecb3; }
        .error-loading-message        { color: #c0392b; font-weight: 500; background-color: #fdecea; border:1px solid #f8c6c1;}
        .loading-message              { background-color: #e9f0ff; border:1px solid #d1dfff;}
        @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
        
        h3#cardViewTitle {
            color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
            font-size: 1.4em; margin-top: 40px; 
        }
        .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
        .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
        .response-card .card-header {
            font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
            padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
            display: flex; justify-content: space-between; align-items: center;
        }
        .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap; font-weight: 400;}
        .response-card .card-header::after {content: 'â–¼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
        .response-card.open .card-header::after {transform: rotate(180deg);}
        .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
        .response-card.open .card-content { max-height: 8000px; padding: 20px 20px; }
        .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
        .journal-entry-details summary { 
            cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
            background-color: #f8f9fa; border-radius: 6px 6px 0 0; list-style-position: inside; 
        }
        .journal-entry-details summary:hover { background-color: #f1f3f6; }
        .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
        .journal-entry-content-text {
            padding: 12px; font-size: 0.95em; line-height: 1.65; color: #3e4c59; 
            max-height: 450px; overflow-y: auto;
        }
        .journal-entry-content-text hr {margin: 15px 0; border: 0; border-top: 1px dashed #dde2e7;}
        .journal-entry-content-text h4 {
             font-size: 1.05em; color: #5c85d6; margin-top: 15px; margin-bottom:8px; font-weight: 500;
        }
        .journal-entry-content-text p { margin-bottom: 10px; }
        .journal-entry-content-text p strong { font-weight: 500; color: #1e293b; margin-right: 5px; }
        .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
        .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }
        .response-card > .card-content > h4.ai-feedback-title { /* Clasa adaugata in HTML */
            color: #5c85d6; font-weight: 500; margin-top: 0px; 
            margin-bottom: 15px; font-size: 1.1em; 
            border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
        }
        .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }
        .ai-feedback-history-container { margin-top: 10px; }
        .feedback-entry-card { 
            background:#fdfdff; padding: 15px; border: 1px solid #e7ecf2;
            border-left: 4px solid #5c85d6; border-radius:8px; margin-bottom:15px; 
            font-size:0.95em; line-height:1.6; box-shadow: 0 2px 5px rgba(0,0,0,0.03);
        }
        .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
        .card-actions { 
            text-align: right; margin-top: 20px; padding-top: 15px; 
            border-top: 1px solid #eef2f7; display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
        }
        .card-actions button {
            padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
            transition: all 0.2s; border: 1px solid transparent; cursor: pointer;
        }
        button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
        button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
        button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
        button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
        button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
        button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
        button.delete-all-feedback-button { background-color:transparent; color: #9b2c2c; border-color: #fed7d7;} 
        button.delete-all-feedback-button:hover { background-color: #9b2c2c; color: white;}
        .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
        .content-ai .ai-main-section-title, 
        .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 { 
            font-weight: 600; color: #3b74d7; margin-top: 1.2em; margin-bottom: 0.6em; 
            font-size: 1.05em; padding-bottom: 4px;
        }
        .content-ai .ai-main-section-title:first-child, 
        .content-ai h1:first-child, .content-ai h2:first-child, 
        .content-ai h3:first-child, .content-ai h4:first-child { margin-top: 0.3em; }
        .content-ai p.ai-text-paragraph { margin-bottom: 0.9em; }
        .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; } 
        .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; } 
        .content-ai ul.ai-list, .content-ai ol.ai-list {
            margin-left: 5px; padding-left: 22px; margin-bottom: 0.9em; list-style-position: outside;
        }
        .content-ai .ai-list-item { margin-bottom: 0.5em; }
        .content-ai .ai-list-item::marker { color: #4a69bd; font-weight: bold; } 
        .content-ai .ai-text-error {
            color: #c0392b; font-weight: 500; background-color: #fff5f5; 
            padding: 10px 12px; border-radius: 4px; border: 1px solid #fecaca; border-left: 4px solid #ef4444;
            white-space: pre-wrap; font-size: 0.9em;
        }
        .chat-container {
            display: none; flex-direction: column; position: fixed; bottom: 20px; right: 20px;
            width: clamp(350px, 40vw, 450px); max-height: calc(100vh - 90px); 
            background: #ffffff; border-radius: 16px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 1000; padding: 0; box-sizing: border-box; overflow: hidden;
            font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        }
        .chat-container h3 {
            text-align: center; color: #334155; margin: 0; padding: 16px 20px;
            font-size: 1.1em; font-weight: 500; background-color: #f8f9fc;
            border-bottom: 1px solid #e9edf2; flex-shrink: 0;
        }
        #chatMessages {
            flex-grow: 1; overflow-y: auto; padding: 18px; background: #ffffff;
            display: flex; flex-direction: column; gap: 12px;
        }
        #chatMessages::-webkit-scrollbar { width: 6px; }
        #chatMessages::-webkit-scrollbar-track { background: #f0f2f5; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb { background: #bfc8d3; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb:hover { background: #a8b3bf; }
        .chat-message {
            padding: 11px 16px; border-radius: 18px; max-width: 83%;
            word-wrap: break-word; line-height: 1.55;
            box-shadow: 0 2px 5px rgba(0,0,0,0.06);
            font-size: 0.96em; font-weight: 400; position: relative;
        }
        .user-message {
            background: linear-gradient(135deg, #5c85d6 0%, #3b6cb7 100%); 
            color: white; align-self: flex-end; margin-left: auto;
            border-bottom-right-radius: 6px; 
        }
        .ai-message {
            background: #f0f3f7; color: #2c3e50; align-self: flex-start;
            margin-right: auto; border-bottom-left-radius: 6px;
            font-family: 'Ubuntu', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
        }
         .ai-message em, .ai-message i { font-family: 'Ubuntu', inherit; font-style: italic; font-weight: 400; }
         .ai-message strong, .ai-message b { font-family: 'Ubuntu', inherit; font-weight: 700; }
        .ai-message.ai-error {
            background-color: #ffe3e3; color: #b71c1c; border: 1px solid #ffc5c5;
            font-family: 'Ubuntu', sans-serif;
        }
        .chat-input-area {
            padding: 15px 20px; border-top: 1px solid #e9edf2;
            background-color: #f8f9fc; flex-shrink: 0;
            display: flex; flex-direction: column; gap: 10px;
        }
        #chatInput {
            width: 100%; padding: 11px 16px; border-radius: 10px;
            border: 1px solid #d9e0ea; resize: none; min-height: 46px; max-height: 120px;
            box-sizing: border-box; font-family: 'Ubuntu', sans-serif;
            font-size: 0.96em; font-weight: 400; line-height: 1.5;
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #ffffff;
        }
        #chatInput:focus {
            border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.18);
            outline: none;
        }
        #sendChatMessageButton {
            padding: 11px 20px; width: 100%;
            font-family: 'Ubuntu', sans-serif; font-size: 1em; font-weight: 500; 
            background-color: #5c85d6; color: white; border: none;
            border-radius: 10px; transition: background-color 0.2s, transform 0.15s ease-out;
            cursor: pointer; margin-top:0; 
        }
        #sendChatMessageButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); }
        #sendChatMessageButton:disabled { background-color: #c3d9f0 !important; color: #7c8da3 !important; transform: translateY(0) !important;}
        #chatStatus {
            font-size: 0.85em; color: #6c757d; text-align: center;
            min-height: 1.2em; padding-bottom: 0; flex-shrink: 0; font-weight: 400;
        }
        #toggleChatButton {
            position: fixed; bottom: 25px; right: 25px; padding: 0; z-index: 1001;
            display: flex; align-items: center; justify-content: center;
            background-color: #5c85d6; color: white; border: none; border-radius: 50%;
            width: 58px; height: 58px; font-size: 26px; 
            box-shadow: 0 5px 15px rgba(92, 133, 214, 0.25);
            cursor: pointer; transition: all 0.3s ease;
        }
        #toggleChatButton:hover { background-color: #4a6fb5; transform: scale(1.1) rotate(10deg); box-shadow: 0 7px 20px rgba(74, 107, 181, 0.35); }
        
        @media (max-width: 820px) {
             .form-container, .card-view {padding:20px; margin-left:15px; margin-right:15px; max-width:calc(100% - 30px);}
        }
        @media (max-width: 768px) {
            body {padding:15px; font-size: 15px;}
            .form-container, .card-view {padding:15px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);} /* Ajustat padding/margin */
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.5em;} 
            h3#cardViewTitle {font-size: 1.25em;}
            .step-navigation button, button#addButton {font-size:0.95em; padding:10px 18px;} 
            .card-actions button {font-size:0.78em; padding:7px 10px; flex-basis:auto;}
            .response-card .card-header {font-size:1.05em;}
            .question-card h3 {font-size:1.1em;}
            .question-card p {font-size:0.92em;}
            .journal-entry-content-text { font-size: 0.92em;}
            .chat-container { 
                width: calc(100% - 30px); max-height: calc(100vh - 100px); 
                bottom: 15px; left: 15px; right: auto; 
                border-radius: 12px; 
            }
            .chat-container h3 { padding: 14px 15px; font-size: 1.05em; }
            #chatMessages { padding: 15px; gap: 10px; } 
            .chat-message { padding: 10px 14px; font-size: 0.92em; max-width: 88%; border-radius: 16px; }
            #toggleChatButton { width: 55px; height: 55px; font-size: 24px; bottom: 20px; right: 20px;}
            .chat-input-area { padding: 12px 15px; gap: 8px; }
            #chatInput { padding: 10px 14px; font-size: 0.92em; min-height: 44px; border-radius: 10px; }
            #sendChatMessageButton { padding: 10px 15px; font-size: 0.95em; border-radius: 10px; }
        }
        @media (max-width: 480px) {
            body {padding:10px; font-size: 14px;}
            .form-container, .card-view {padding:12px; margin-left:5px; margin-right:5px; max-width:calc(100% - 10px);}
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.35em;} h3#cardViewTitle {font-size: 1.2em;}
            .question-card h3, .response-card .card-header {font-size:1em;}
            .question-card p {font-size:0.9em;}
            .journal-entry-content-text { font-size: 0.9em;}
            textarea {font-size:0.95em; padding:10px; min-height: 60px;}
            .step-navigation button, button#addButton {font-size:0.9em; padding:9px 15px;}
            .card-actions button {font-size:0.75em; padding:6px 8px; flex-basis: calc(50% - 5px);}
            .response-card .card-header {padding:12px 15px; flex-direction: column; align-items: flex-start; gap: 4px;}
            .response-card .card-header::after { align-self: flex-end; margin-top: -1.3em; } 
            .chat-container { max-height: calc(100vh - 80px); bottom: 10px; left: 10px; width: calc(100% - 20px); border-radius: 10px; }
            .chat-container h3 { font-size: 1em; padding: 12px 15px; }
            #chatMessages { padding: 12px; gap: 8px; }
            .chat-message { font-size: 0.9em; padding: 9px 12px; border-radius: 14px; }
            .chat-input-area { padding: 10px 12px; gap: 8px;}
            #chatInput {font-size: 0.9em; min-height: 42px; padding: 9px 12px; border-radius: 8px;}
            #sendChatMessageButton {font-size: 0.9em; padding: 9px 12px; border-radius: 8px;}
            #toggleChatButton { width: 50px; height: 50px; font-size: 22px; bottom: 15px; right: 15px; }
        }

    </style>
</head>
<body>

    <div class="form-container">
        <h2 class="main-form-title">FiÈ™Äƒ Monitorizare</h2> <!-- AdÄƒugat o clasÄƒ pentru a o putea ascunde selectiv -->
        <p>CompleteazÄƒ fiecare Ã®ntrebare pentru a Ã®nÈ›elege mai bine situaÈ›iile tale. Fiecare secÈ›iune reprezintÄƒ o parte importantÄƒ a reflecÈ›iei tale. ÃŽn acest exerciÈ›iu, Ã®È›i voi ghida fiecare pas, astfel Ã®ncÃ¢t sÄƒ poÈ›i explora Ã®n profunzime gÃ¢ndurile, emoÈ›iile È™i comportamentele tale.</p>
    
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    
        <form id="exercitiuForm" novalidate>
            <!-- PASUL 1 -->
            <div class="question-card form-step form-step-active" id="step-1">
                <h3>Care este situaÈ›ia?</h3>
                <p>Te rog sÄƒ descrii contextul care a declanÈ™at emoÈ›iile sau comportamentul tÄƒu. ÃŽncearcÄƒ sÄƒ fii cÃ¢t mai specific È™i detaliat. Aceasta poate fi o situaÈ›ie concretÄƒ din viaÈ›a de zi cu zi Ã®n care te-ai simÈ›it copleÈ™it, stresat sau Ã®ntr-o altÄƒ stare emoÈ›ionalÄƒ intensÄƒ.</p>
                <textarea name="situatie" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-2">
                <h3>Ce Ã®mi trece prin minte?</h3>
                <p>ÃŽÈ›i cer sÄƒ identifici gÃ¢ndurile automate care au apÄƒrut Ã®n aceastÄƒ situaÈ›ie. Acestea sunt gÃ¢nduri rapide, involuntare, care Ã®È›i trec prin minte Ã®n momentele de stres. Ce Ã®È›i spui Ã®n acel moment? Este un gÃ¢nd critic sau Ã®ngrijorÄƒtor?</p>
                <textarea name="ganduri" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-3">
                <h3>Cum mÄƒ face acel gÃ¢nd sÄƒ mÄƒ simt?</h3>
                <p>Te rog sÄƒ notezi emoÈ›iile pe care le simÈ›i Ã®n urma acelui gÃ¢nd. Ce simÈ›i? FricÄƒ, tristeÈ›e, furie? DÄƒ o intensitate emoÈ›iei (de la 0 la 100) pentru a vedea cÃ¢t de puternicÄƒ este.</p>
                <textarea name="emotii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-4">
                <h3>Ce mod este activ?</h3>
                <p>IdentificÄƒ modul Ã®n care te afli Ã®n aceastÄƒ situaÈ›ie. Este un mod de copil vulnerabil, critic interior, sau poate adultul sÄƒnÄƒtos? ConÈ™tientizarea modului Ã®È›i poate oferi o mai bunÄƒ Ã®nÈ›elegere a reacÈ›iilor tale.</p>
                <textarea name="mod_activ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-5">
                <h3>Ce comportament simÈ›i cÄƒ adopÈ›i?</h3>
                <p>Descrie comportamentul pe care Ã®l manifeÈ™ti Ã®n aceastÄƒ situaÈ›ie. Este un comportament de evitare, de confruntare, de sacrificiu de sine? RecunoaÈ™terea comportamentului te ajutÄƒ sÄƒ Ã®nÈ›elegi mai bine cum reacÈ›ionezi.</p>
                <textarea name="comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-6">
                <h3>Care sunt nevoile tale mai profunde?</h3>
                <p>Ce nevoi stau la baza acestor emoÈ›ii È™i comportamente? Poate fi nevoia de siguranÈ›Äƒ, de validare, de acceptare? Identificarea acestor nevoi te poate ajuta sÄƒ gÄƒseÈ™ti strategii mai sÄƒnÄƒtoase pentru a le Ã®ndeplini.</p>
                <textarea name="nevoi_profunde" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-7">
                <h3>MÄƒ ajutÄƒ comportamentul meu sÄƒ Ã®ndeplinesc aceste nevoi?</h3>
                <p>ReflecteazÄƒ dacÄƒ felul Ã®n care reacÈ›ionezi te ajutÄƒ cu adevÄƒrat sÄƒ Ã®È›i Ã®ndeplineÈ™ti nevoile. Poate fi util sÄƒ te gÃ¢ndeÈ™ti dacÄƒ existÄƒ alternative mai eficiente.</p>
                <textarea name="ajutor_comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-8">
                <h3>Cum ar gÃ¢ndi È™i cum s-ar comporta Adultul SÄƒnÄƒtos?</h3>
                <p>GÃ¢ndeÈ™te-te la cum ar reacÈ›iona partea ta AdultÄƒ SÄƒnÄƒtoasÄƒ Ã®n aceastÄƒ situaÈ›ie. Cum ai putea sÄƒ abordezi diferit pentru a avea grijÄƒ de tine È™i de nevoile tale?</p>
                <textarea name="adult_sanatos" rows="3" required></textarea>
            </div>

            <!-- PASUL 2 -->
            <div class="question-card form-step" id="step-9">
                <h3>Ce mÄƒ face sÄƒ cred cÄƒ gÃ¢ndul automat este adevÄƒrat?</h3>
                <p>ExploreazÄƒ motivele pentru care crezi cÄƒ acest gÃ¢nd este adevÄƒrat. Ce dovezi ai care Ã®È›i confirmÄƒ acest lucru? De multe ori, ne bazÄƒm pe experienÈ›e trecute sau frici pentru a justifica un gÃ¢nd.</p>
                <textarea name="dovezi_adevar" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-10">
                <h3>Ce mÄƒ face sÄƒ cred cÄƒ nu este adevÄƒrat?</h3>
                <p>Acum, sÄƒ ne uitÄƒm la dovezile Ã®mpotriva gÃ¢ndului tÄƒu. ExistÄƒ argumente sau experienÈ›e care contrazic acest gÃ¢nd? Poate existÄƒ o altÄƒ perspectivÄƒ pe care nu ai luat-o Ã®n considerare?</p>
                <textarea name="dovezi_fals" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-11">
                <h3>ExistÄƒ o explicaÈ›ie alternativÄƒ?</h3>
                <p>Uneori, existÄƒ mai multe explicaÈ›ii pentru ceea ce se Ã®ntÃ¢mplÄƒ. Ce alte interpretÄƒri ai putea avea pentru aceastÄƒ situaÈ›ie? GÃ¢ndeÈ™te-te la alte posibilitÄƒÈ›i care ar putea explica contextul.</p>
                <textarea name="explicatie_alternativa" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-12">
                <h3>Care este cel mai rÄƒu lucru care s-ar putea Ã®ntÃ¢mpla?</h3>
                <p>Ce este cel mai rÄƒu care ar putea avea loc Ã®n aceastÄƒ situaÈ›ie? SÄƒ identificÄƒm acele frici catastrofale care adesea ne alimenteazÄƒ gÃ¢ndurile negative.</p>
                <textarea name="scenariu_negativ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-13">
                <h3>Care este cel mai bun lucru care s-ar putea Ã®ntÃ¢mpla?</h3>
                <p>Pe de altÄƒ parte, care ar fi cel mai pozitiv scenariu? Uneori uitÄƒm sÄƒ ne gÃ¢ndim È™i la posibilitÄƒÈ›ile bune. Cum ar arÄƒta cel mai bun rezultat al acestei situaÈ›ii?</p>
                <textarea name="scenariu_optimist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-14">
                <h3>Care este cel mai realist rezultat?</h3>
                <p>DupÄƒ ce am explorat extremele, ce crezi cÄƒ este cel mai probabil sÄƒ se Ã®ntÃ¢mple? Cum ar arÄƒta un rezultat realist, È›inÃ¢nd cont de toate perspectivele?</p>
                <textarea name="rezultat_realist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-15">
                <h3>Ce s-ar Ã®ntÃ¢mpla dacÄƒ mi-aÈ™ schimba modul de gÃ¢ndire?</h3>
                <p>ÃŽntreabÄƒ-te cum ar fi dacÄƒ ai aborda situaÈ›ia cu un alt tip de gÃ¢ndire. Cum ar influenÈ›a asta emoÈ›iile È™i comportamentele tale?</p>
                <textarea name="schimbare_gandire" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-16">
                <h3>Ce i-aÈ™ spune unui prieten dacÄƒ ar fi Ã®n aceeaÈ™i situaÈ›ie?</h3>
                <p>GÃ¢ndeÈ™te-te la cum ai reacÈ›iona dacÄƒ un prieten drag ar avea aceleaÈ™i gÃ¢nduri. Ce i-ai spune pentru a-l sprijini? Cum ai Ã®ncerca sÄƒ-l Ã®ncurajezi?</p>
                <textarea name="sfat_prieten" rows="3" required></textarea>
            </div>

            <!-- PASUL 3 -->
            <div class="question-card form-step" id="step-17">
                <h3>VÄƒd doar partea rea a lucrurilor?</h3>
                <p>Este posibil sÄƒ fii prins Ã®ntr-un tipar negativ de gÃ¢ndire, concentrÃ¢ndu-te doar pe aspectele negative. ÃŽncearcÄƒ sÄƒ observi dacÄƒ existÄƒ È™i aspecte pozitive pe care le-ai ignorat.</p>
                <textarea name="partea_rea" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-18">
                <h3>ÃŽmi asum responsabilitatea pentru lucruri care nu au stat Ã®n puterea mea?</h3>
                <p>ReflecteazÄƒ dacÄƒ Ã®È›i asumi responsabilitatea pentru situaÈ›ii asupra cÄƒrora nu aveai control. Este important sÄƒ Ã®È›i dai seama de limitele influenÈ›ei tale.</p>
                <textarea name="responsabilitate" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-19">
                <h3>MÄƒ condamn Ã®n baza unui singur eveniment?</h3>
                <p>ÃŽÈ›i evaluezi valoarea personalÄƒ bazÃ¢ndu-te pe un singur eveniment negativ? AminteÈ™te-È›i cÄƒ un eveniment nu defineÈ™te cine eÈ™ti Ã®n totalitate.</p>
                <textarea name="condamnare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-20">
                <h3>Privesc situaÈ›ia Ã®n termeni extremi?</h3>
                <p>VerificÄƒ dacÄƒ vezi situaÈ›ia doar Ã®n alb sau negru, fÄƒrÄƒ nuanÈ›e de gri. GÃ¢ndirea extremÄƒ poate distorsiona realitatea.</p>
                <textarea name="termeni_extremi" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-21">
                <h3>Exagerez situaÈ›ia?</h3>
                <p>ÃŽÈ›i amplifici reacÈ›iile faÈ›Äƒ de o situaÈ›ie? ÃŽncearcÄƒ sÄƒ te gÃ¢ndeÈ™ti dacÄƒ ceea ce percepi este realist sau dacÄƒ exagerezi impactul situaÈ›iei.</p>
                <textarea name="exagerare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-22">
                <h3>ExistÄƒ È™i alÈ›i factori responsabili?</h3>
                <p>ExistÄƒ alÈ›i factori care contribuie la aceastÄƒ situaÈ›ie, pe lÃ¢ngÄƒ tine? Este important sÄƒ ai o perspectivÄƒ completÄƒ asupra cauzelor unei situaÈ›ii.</p>
                <textarea name="factori_responsabili" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-23">
                <h3>Am sÄƒrit direct la concluzii?</h3>
                <p>Te-ai grÄƒbit sÄƒ ajungi la o concluzie fÄƒrÄƒ suficiente dovezi? ÃŽncearcÄƒ sÄƒ observi dacÄƒ existÄƒ alte posibilitÄƒÈ›i care ar putea explica situaÈ›ia.</p>
                <textarea name="concluzii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-24">
                <h3>ÃŽmi pun Ã®ntrebÄƒri fÄƒrÄƒ rÄƒspuns?</h3>
                <p>Te frÄƒmÃ¢ntÄƒ Ã®ntrebÄƒri care nu au un rÄƒspuns clar sau realist? Aceste Ã®ntrebÄƒri pot fi o sursÄƒ majorÄƒ de anxietate.</p>
                <textarea name="intrebari_fara_raspuns" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-25">
                <h3>MÄƒ concentrez doar asupra slÄƒbiciunilor mele?</h3>
                <p>Ai tendinÈ›a sÄƒ te focalizezi doar pe slÄƒbiciuni È™i sÄƒ ignori punctele tale forte? ÃŽncearcÄƒ sÄƒ Ã®È›i recunoÈ™ti È™i punctele pozitive.</p>
                <textarea name="slabiciuni" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-26">
                <h3>MÄƒ zbat prea mult gÃ¢ndind la cum ar trebui sÄƒ fie lucrurile?</h3>
                <p>Ai tendinÈ›a sÄƒ te gÃ¢ndeÈ™ti mereu la cum ar trebui sÄƒ fie lucrurile, Ã®n loc sÄƒ accepÈ›i situaÈ›ia aÈ™a cum este? Acceptarea poate reduce stresul È™i anxietatea.</p>
                <textarea name="cum_ar_trebui" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-27">
                <h3>MÄƒ aÈ™tept sÄƒ fiu perfect?</h3>
                <p>ÃŽÈ›i setezi standarde foarte Ã®nalte, imposibil de atins? PerfecÈ›ionismul poate fi o sursÄƒ majorÄƒ de frustrare È™i descurajare.</p>
                <textarea name="perfectiune" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-28">
                <h3>Completare finalizatÄƒ!</h3>
                <p>FelicitÄƒri pentru parcurgerea acestui exerciÈ›iu de auto-reflecÈ›ie! ApasÄƒ butonul de mai jos pentru a salva datele È™i a genera un feedback automatizat, dacÄƒ este disponibil.</p>
                <p>Feedback-ul AI te poate ajuta sÄƒ obÈ›ii noi perspective. DacÄƒ Ã®ntÃ¢mpini probleme cu generarea (ex: erori de limitÄƒ de utilizare sau cheie API invalidÄƒ), poÈ›i Ã®ncerca din nou mai tÃ¢rziu sau contacta administratorul.</p>
            </div>

            <div class="step-navigation">
                <button type="button" id="prevButton">ÃŽnapoi</button>
                <button type="button" id="nextButton">ÃŽnainte</button>
            </div>
            <button type="button" id="addButton">SalveazÄƒ È™i GenereazÄƒ Feedback AI</button>
        </form>

        <div id="confirmationMessage" class="confirmation-message">
            <!-- Mesajul va fi setat de JavaScript -->
        </div>

        <div class="collaboration-section">
            <button type="button" id="generateLinkButton">GenereazÄƒ Link de Colaborare</button>
        </div>
    </div>
    
    <h3 style="text-align: center; margin-top: 40px; margin-bottom: 10px; color: #333; font-weight: 500;">RÄƒspunsurile Tale È™i Istoricul Feedback-ului AI:</h3>
    
    <div class="card-view" id="cardViewContainer">
        <!-- Cardurile cu rÄƒspunsuri È™i feedback AI vor fi adÄƒugate aici de JavaScript -->
    </div>
    
    <!-- Chat Container -->
    <div class="chat-container" id="chatContainer"> <!-- Se va afiÈ™a via JS: style="display: flex;" -->
        <h3>DiscutÄƒ cu PsihoGPT</h3>
        <div id="chatMessages">
            <!-- Mesajele vor apÄƒrea aici -->
        </div>
        <textarea id="chatInput" rows="2" placeholder="Scrie mesajul tÄƒu aici... ApasÄƒ Enter pentru a trimite."></textarea>
        <button id="sendChatMessageButton" disabled>Trimite Mesaj</button> <!-- IniÈ›ial dezactivat -->
        <p id="chatStatus"></p>
    </div>

    <button id="toggleChatButton" style="display: none;">ðŸ’¬</button>


    <div class="table-container" style="display: none;"> 
        <table>
            <thead>
                <tr>
                    <th>Data</th><th>SituaÈ›ia</th><th>GÃ¢nduri</th><th>EmoÈ›ii</th><th>Mod activ</th>
                    <th>Comportament</th><th>Nevoile</th><th>Ajutor comport.</th><th>Adult SÄƒnÄƒtos</th><th>Detalii</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <br/>
</body>
</html>