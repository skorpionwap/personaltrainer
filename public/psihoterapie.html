<!DOCTYPE html>
<html>
<head>
    <title>Fișă Monitorizare - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, deleteField, doc, getDoc, updateDoc, arrayUnion, query, where, setDoc, orderBy, limit } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    // Configurarea Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // Înlocuiește cu cheia ta reală dacă e diferită
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    // Inițializare Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // --- Configurare Gemini API ---
    // !!! ÎNLOCUIEȘTE CU CHEIA TA API GEMINI VALIDĂ ȘI ACTIVĂ !!!
    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- CHEIA TA API GEMINI
    const GEMINI_MODEL_NAME_FEEDBACK = "gemini-2.5-flash-preview-04-17";
    const GEMINI_MODEL_NAME_CHAT = "gemini-2.5-flash-preview-04-17";
    let genAI, geminiModelFeedback, geminiModelChat;

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_FEEDBACK });
            geminiModelChat = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_CHAT });
            console.log("SDK Gemini inițializat. Model Feedback:", GEMINI_MODEL_NAME_FEEDBACK, "Model Chat:", GEMINI_MODEL_NAME_CHAT);
        } catch (e) {
            console.error("Eroare critică la inițializarea SDK Gemini:", e);
            alert("Eroare la inițializarea serviciului AI. Verificați cheia API Gemini și configurația din Google Cloud. Funcționalitatea AI va fi limitată.");
            geminiModelFeedback = null; geminiModelChat = null;
        }
    } else  {
        console.warn(`Cheia API Gemini pare a fi un placeholder ('${GEMINI_API_KEY}'). Te rog înlocuiește-o cu cheia ta API validă pentru a activa funcționalitatea AI.`);
        // alert("Funcționalitatea AI este dezactivată. Te rog configurează o cheie API Gemini validă în codul sursă (variabila GEMINI_API_KEY).");
        geminiModelFeedback = null; geminiModelChat = null;
        // Cheie goală sau doar spații
        console.warn("Cheia API Gemini nu este configurată. Funcționalitatea AI va fi dezactivată.");
        // alert("Cheia API Gemini nu este configurată. Funcționalitatea AI va fi dezactivată.");
        geminiModelFeedback = null; geminiModelChat = null;
    }


    let currentStep = 1;
    let totalSteps = 0;
    let dataAlreadyLoaded = false;

    // --- Variabile Globale pentru Chat ---
    let chatSession = null;
    const CHAT_HISTORY_DOC_ID_PREFIX = "chatHistory_";
    let isChatInitialized = false;


    window.onload = function () {
        totalSteps = document.querySelectorAll('.form-step').length;
        updateProgressBar();
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (!collabId) {
            onAuthStateChanged(auth, async (user) => {
                const toggleChatBtn = document.getElementById("toggleChatButton");
                const chatContainer = document.getElementById("chatContainer");

                if (user) {
                    console.log("Utilizator autentificat:", user.uid);
                    if (!dataAlreadyLoaded) {
                        populateTableData(user.uid);
                        loadTableData(user.uid);
                        dataAlreadyLoaded = true;
                    }
                    if(toggleChatBtn) toggleChatBtn.style.display = 'flex';
                } else {
                    console.log("Utilizator neautentificat, redirecționare...");
                    if(toggleChatBtn) toggleChatBtn.style.display = 'none';
                    if(chatContainer) chatContainer.style.display = 'none';
                    isChatInitialized = false;
                    chatSession = null;
                    window.location.href = "login.html";
                }
            });
        } else {
            const toggleChatBtn = document.getElementById("toggleChatButton");
            if(toggleChatBtn) toggleChatBtn.style.display = 'none';
            const chatContainer = document.getElementById("chatContainer");
            if(chatContainer) chatContainer.style.display = 'none';
        }

        document.getElementById("nextButton")?.addEventListener("click", nextStep);
        document.getElementById("prevButton")?.addEventListener("click", previousStep);
        document.getElementById("addButton")?.addEventListener("click", salveazaRaspunsSiGenereazaFeedback);
        document.getElementById("generateLinkButton")?.addEventListener("click", generateCollaborationLink);
        
        document.getElementById("toggleChatButton")?.addEventListener("click", handleToggleChat);
        document.getElementById("sendChatMessageButton")?.addEventListener("click", handleSendChatMessage);
        document.getElementById("chatInput")?.addEventListener("keypress", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); 
                handleSendChatMessage();
            }
        });
    };

    function nextStep() {
        if (currentStep < totalSteps) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep++;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function previousStep() {
        if (currentStep > 1) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep--;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function updateProgressBar() {
        const progress = document.getElementById('progress');
        if(progress && totalSteps > 0) {
            const progressPercentage = (currentStep / totalSteps) * 100;
            progress.style.width = progressPercentage + '%';
        }
    }
    
    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) {
            console.error("Modelul Gemini specificat este invalid sau neinițializat.", modelToUse === geminiModelChat ? "(Model Chat)" : "(Model Feedback)");
            return "EROARE: Model AI neinițializat. Verifică cheia API.";
        }
        try {
            const requestPayload = {
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.55, ...generationConfigOptions }
            };
            const result = await modelToUse.generateContent(requestPayload); 
            const response = result.response;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Gemini a oprit generarea prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    return `EROARE Gemini: Generare oprită (Motiv: ${response.candidates[0].finishReason}). Filtre de siguranță posibile active.`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                console.error("Prompt blocat de Gemini:", response.promptFeedback.blockReasonDetail || response.promptFeedback.blockReason);
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Revizuiește conținutul trimis.`;
            }
             else {
                console.error("Răspuns Gemini neașteptat sau gol:", JSON.stringify(response, null, 2));
                return "EROARE Gemini: Răspuns invalid sau gol de la API.";
            }
        } catch (error) {
            console.error("Eroare detaliată la callGeminiAPI:", error, error.stack);
            let errorMessage = `EROARE Gemini: ${error.message || "Eroare API necunoscută"}`;
            if (error.toString().toLowerCase().includes("api key not valid") || 
                (error.message && error.message.toLowerCase().includes("permission denied")) ||
                (error.message && error.message.toLowerCase().includes("api_key_invalid")) ||
                (error.status && error.status === 403)) {
                 errorMessage = "EROARE: Cheia API Gemini nu este validă sau nu are permisiuni. Verifică restricțiile din Google Cloud Console (HTTP Referrers, API Restrictions pentru Generative Language API) și cheia din cod. Asigură-te că domeniul " + window.location.hostname + " este permis.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429) || (error.toString().toLowerCase().includes("resource has been exhausted")) )) {
                errorMessage = "EROARE: Limita de utilizare (posibil gratuită) a API-ului Gemini (RPM/TPM sau alta) a fost depășită. Încearcă mai târziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety_settings"))) {
                errorMessage = "EROARE Gemini: Generarea a fost oprită (posibil din motive de siguranță, conținut inadecvat, sau alte restricții ale modelului). Încearcă un prompt diferit sau ajustează setările de siguranță dacă ai acces.";
            }  else if (error.toString().toLowerCase().includes("404") && error.toString().toLowerCase().includes("model not found")) {
                 errorMessage = `EROARE Gemini: Modelul specificat nu a fost găsit sau nu este suportat. Verifică numele modelului în cod.`;
            }
            return errorMessage;
         }
    }

    async function genereazaFeedbackCuGeminiDinFrontend(promptText) { 
        if (!geminiModelFeedback) {
            console.error("Modelul Gemini pentru feedback (geminiModelFeedback) nu este inițializat. Verifică cheia API.");
            return "EROARE: Configurare Gemini incorectă pentru feedback. Verifică dacă ai introdus corect cheia API în cod.";
        }
        try {
            console.log("Trimitere prompt către Gemini (feedback fișă, primele 100 caractere):", promptText.substring(0, 100) + "...");
            return await callGeminiAPI(promptText, geminiModelFeedback); 
        } catch (error) { 
            console.error("Eroare specifică în genereazaFeedbackCuGeminiDinFrontend:", error);
            return `EROARE internă la pregătirea cererii către Gemini (feedback): ${error.message}`;
        }
    }

    async function genereazaSiProceseazaFeedbackAI(rowData, docId) {
      const prompt = `
Analizează în profunzime această fișă completă de auto-reflecție. Utilizatorul a parcurs un exercițiu detaliat pentru a-și înțelege o situație specifică. Oferă feedback psihologic structurat, empatic și acționabil. Respectă cu strictețe formatul și ordinea secțiunilor de mai jos, folosind exact prefixele indicate.

**Datele Complete din Fișa de Reflecție a Utilizatorului:**

**Secțiunea 1: Explorarea Situației și a Nevoilor**
*   Care este situația?: ${rowData.situatie || 'N/A'}
*   Ce îmi trece prin minte (gânduri automate)?: ${rowData.ganduri || 'N/A'}
*   Cum mă face acel gând să mă simt (emoții)?: ${rowData.emotii || 'N/A'}
*   Ce mod este activ?: ${rowData.mod_activ || 'N/A'}
*   Ce comportament simți că adopți?: ${rowData.comportament || 'N/A'}
*   Care sunt nevoile tale mai profunde?: ${rowData.nevoi_profunde || 'N/A'}
*   Mă ajută comportamentul meu să îndeplinesc aceste nevoi?: ${rowData.ajutor_comportament || 'N/A'}
*   Cum ar gândi și cum s-ar comporta Adultul Sănătos (perspectiva utilizatorului)?: ${rowData.adult_sanatos || 'N/A'}

**Secțiunea 2: Analiza Gândurilor și a Percepțiilor**
*   Ce mă face să cred că gândul automat este adevărat?: ${rowData.dovezi_adevar || 'N/A'}
*   Ce mă face să cred că nu este adevărat?: ${rowData.dovezi_fals || 'N/A'}
*   Există o explicație alternativă?: ${rowData.explicatie_alternativa || 'N/A'}
*   Care este cel mai rău lucru care s-ar putea întâmpla?: ${rowData.scenariu_negativ || 'N/A'}
*   Care este cel mai bun lucru care s-ar putea întâmpla?: ${rowData.scenariu_optimist || 'N/A'}
*   Care este cel mai realist rezultat?: ${rowData.rezultat_realist || 'N/A'}
*   Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?: ${rowData.schimbare_gandire || 'N/A'}
*   Ce i-aș spune unui prieten dacă ar fi în aceeași situație?: ${rowData.sfat_prieten || 'N/A'}

**Secțiunea 3: Întrebări pentru Claritate și Reflecție Suplimentară**
*   Văd doar partea rea a lucrurilor?: ${rowData.partea_rea || 'N/A'}
*   Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?: ${rowData.responsabilitate || 'N/A'}
*   Mă condamn în baza unui singur eveniment?: ${rowData.condamnare || 'N/A'}
*   Privesc situația în termeni extremi (alb/negru)?: ${rowData.termeni_extremi || 'N/A'}
*   Exagerez situația?: ${rowData.exagerare || 'N/A'}
*   Există și alți factori responsabili?: ${rowData.factori_responsabili || 'N/A'}
*   Am sărit direct la concluzii?: ${rowData.concluzii || 'N/A'}
*   Îmi pun întrebări fără răspuns?: ${rowData.intrebari_fara_raspuns || 'N/A'}
*   Mă concentrez doar asupra slăbiciunilor mele?: ${rowData.slabiciuni || 'N/A'}
*   Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?: ${rowData.cum_ar_trebui || 'N/A'}
*   Mă aștept să fiu perfect?: ${rowData.perfectiune || 'N/A'}

**CERINȚE PENTRU FEEDBACK-UL AI (folosește prefixele EXACT așa cum sunt scrise):**

Feedback General:
EmpatieInițială: (1-2 propoziții empatice scurte, recunoscând efortul utilizatorului.)

Analiză Detaliată:
PuncteForteObservate: (Identifică 1-2 aspecte pozitive sau de auto-conștientizare.)
TiparePrincipale: (Descrie succint 1-3 tipare de gândire/emoționale/comportamentale centrale.)

Legătura Gând-Emoție-Comportament-Nevoie:
ConexiuniCheie: (Sintetizează legătura S-G-E-C-N bazată pe '${rowData.ganduri}', '${rowData.emotii}', '${rowData.comportament}', '${rowData.nevoi_profunde}'.)

Analiza Gândurilor Automate și Distorsiuni:
DistorsiuniIdentificate: (Identifică 2-4 distorsiuni principale. Pentru fiecare: Numele, Explicația, Exemplu din răspunsuri, Întrebare de contestare. Listează fiecare ca sub-punct precedat de '* '.)

Scheme și Moduri Cognitive:
SchemeActivate: (Identifică 1-3 scheme. Pentru fiecare: Numele, Cum se manifestă. Listează fiecare ca sub-punct precedat de '* '.)
ModuriImplicate: (Sugerează ce moduri Schema Therapy ar putea fi implicate.)

Rolul Adultului Sănătos:
PerspectivaAdultSănătos: (Comentează răspunsul utilizatorului '${rowData.adult_sanatos}'. Oferă descriere detaliată: interpretare situație, gânduri alternative, gestionare emoții, comportamente adaptative, contracarare scheme.)

Sugestii și Reflecții Finale:
ÎntrebareFinalăReflecție: (O întrebare generală puternică pentru învățare și aplicare viitoare.)
SugestieMicPas: (O sugestie concretă pentru un mic pas următor.)
ÎncurajareFinală: (1-2 propoziții de încurajare.)

Răspunde doar cu textul cerut conform structurii, fără introduceri, concluzii sau formatări suplimentare în afara celor specificate).`;

      let feedbackText = null;
      let modelFolosit = "N/A";

      if (geminiModelFeedback) {
        console.log("Solicitare feedback de la Gemini pentru fișă...");
        modelFolosit = `Gemini (${GEMINI_MODEL_NAME_FEEDBACK})`;
        feedbackText = await genereazaFeedbackCuGeminiDinFrontend(prompt);
      } else {
        console.warn("Gemini (geminiModelFeedback) nu este configurat. Nu se poate genera feedback AI pentru fișă.");
        return {
            paragraf: "Serviciul de feedback AI (Gemini) nu este configurat corect pentru fișe. Verifică cheia API și numele modelului.",
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "", 
            model: "Configurare Gemini Eronată", timestamp: new Date().toISOString(), error: true
        };
      }

      if (!feedbackText || (typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:"))) {
        console.warn(`Eroare de la ${modelFolosit} la generarea feedback-ului fișei:`, feedbackText);
        return { 
            paragraf: feedbackText || `Nu s-a putut obține feedback de la ${modelFolosit}.`,
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "",
            model: modelFolosit + " (Eroare API)", timestamp: new Date().toISOString(), error: true
        };
      }

      console.log("Răspuns brut de la Gemini (feedback fișă):\n---\n" + feedbackText + "\n---");

      const feedbackStructure = {
            empatie_initiala: /^EmpatieInițială:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            puncte_forte: /^PuncteForteObservate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            tipare_principale: /^TiparePrincipale:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            conexiuni_cheie: /^ConexiuniCheie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            distorsiuni_identificate: /^DistorsiuniIdentificate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            scheme_activate: /^SchemeActivate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            moduri_implicate: /^ModuriImplicate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            perspectiva_adult_sanatos: /^PerspectivaAdultSănătos:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            intrebare_finala_reflectie: /^ÎntrebareFinalăReflecție:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            sugestie_mic_pas: /^SugestieMicPas:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            incurajare_finala: /^ÎncurajareFinală:\s*([\s\S]*?$)/im,
        };
        
        const parsedFeedback = { model: modelFolosit, timestamp: new Date().toISOString(), error: false, error_parsing: false };
        let allParsingOk = true;

        for (const key in feedbackStructure) {
            const match = feedbackText.match(feedbackStructure[key]);
            if (match && match[1] && match[1].trim() !== "") {
                 parsedFeedback[key] = match[1].trim();
            } else {
                console.warn(`Feedback fișă: Nu s-a putut extrage sau este gol conținutul pentru: '${key}'`);
                parsedFeedback[key] = `(Secțiune neextrasă sau goală din răspunsul AI: ${key})`;
                allParsingOk = false;
            }
        }
        
        if (!allParsingOk) {
            console.warn("Feedback fișă: Cel puțin o secțiune nu a putut fi parsată corect din răspunsul AI. Verifică formatul răspunsului AI și regex-urile.");
            parsedFeedback.error_parsing = true;
        }

        if (docId) {
            const docRef = doc(db, "raspunsuri", docId);
            try {
                const updatePayload = { feedback_history: arrayUnion(parsedFeedback) };
                Object.keys(parsedFeedback).forEach(key => {
                    updatePayload[`feedback_${key}`] = parsedFeedback[key];
                });
                await updateDoc(docRef, updatePayload);
                console.log(`Feedback AI (nou, ${modelFolosit}) salvat pentru fișa ${docId}`);
            } catch (updateError) {
                console.error(`Eroare update Firestore feedback nou pentru fișa ${docId}:`, updateError);
            }
        }
        return parsedFeedback;
    }

    // --- CHAT FUNCTIONALITY ---

    function displayChatMessage(message, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) {
            console.error("Elementul chatMessages nu a fost găsit.");
            return; 
        }
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");
        
        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        // CORECTIE: Adaugă clasele separat
        const classesToAdd = messageClass.split(' ');
        messageElement.classList.add(...classesToAdd);

        messageElement.style.whiteSpace = "pre-wrap"; 
        messageElement.textContent = message; 

        messagesDiv.appendChild(messageElement);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    async function loadChatHistory(userId) {
        if (!userId) return [];
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists() && docSnap.data().messages && Array.isArray(docSnap.data().messages)) {
                const messages = docSnap.data().messages;
                messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                return messages;
            }
            return []; 
        } catch (error) {
            console.error("Eroare la încărcarea istoricului de chat din Firestore:", error);
            return [];
        }
    }
    
    async function saveChatMessage(userId, messageObject) {
        if (!userId || !messageObject || typeof messageObject.content !== 'string' || messageObject.content.trim() === "") {
            console.warn("Tentativă de salvare a unui mesaj invalid sau gol:", messageObject);
            return;
        }
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists()) {
                 await updateDoc(historyDocRef, {
                    messages: arrayUnion(messageObject) 
                });
            } else {
                await setDoc(historyDocRef, {
                    messages: [messageObject]
                });
            }
            console.log("Mesaj de chat salvat pentru utilizatorul:", userId);
        } catch (error) {
            console.error("Eroare la salvarea mesajului de chat în Firestore:", error);
        }
    }
    
    async function initializeAndStartChatSession(userId) {
        const chatStatus = document.getElementById("chatStatus");
        const sendButton = document.getElementById("sendChatMessageButton");
        const messagesDiv = document.getElementById("chatMessages");

        if (sendButton) sendButton.disabled = true;
        if (chatStatus) chatStatus.textContent = "Inițializare chat AI...";
        if (messagesDiv) messagesDiv.innerHTML = ''; 

        if (!geminiModelChat) { // Verificarea e crucială aici
            if (chatStatus) chatStatus.textContent = "EROARE: Modelul AI Chat nu este disponibil.";
            console.error("initializeAndStartChatSession: geminiModelChat nu este inițializat. Verifică cheia API GEMINI.");
            displayChatMessage("Serviciul de chat AI nu este disponibil momentan. Te rog verifică configurația sau contactează administratorul (Cheie API Gemini neconfigurată/invalidă).", "AI-error");
            return null; // Nu se poate continua
        }
        
        isChatInitialized = false; 

        let initialContextSummary = "REZUMAT DIN FIȘELE ANTERIOARE (ULTIMELE 3):\n";
        try {
            if (userId) {
                const q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId), orderBy("date", "desc"), limit(3)); 
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    querySnapshot.forEach(doc => {
                        const data = doc.data();
                        const entryDate = data.date || (data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleDateString("ro-RO") : 'N/A');
                        initialContextSummary += ` - Fișă (${entryDate}): Situația - ${(data.situatie || "").substring(0, 70)}...; Gânduri - ${(data.ganduri || "").substring(0, 70)}...; Emoții - ${data.emotii || 'N/A'}.\n`;
                    });
                } else { initialContextSummary += "Nicio fișă de monitorizare recentă găsită.\n"; }
            }
        } catch(e) { 
            console.error("Eroare la încărcarea contextului din fișe pentru chat:", e); 
            initialContextSummary += "Eroare la încărcarea contextului din fișe.\n";
        }

        const systemInstructionText =
`# ROL PRINCIPAL ȘI PERSONA:
Tu ești PsihoGPT (alias Dr. Janet/Damian – decide o identitate sau menționează ambele roluri complementare pe care le poți juca, concentrându-te pe claritatea teoretică și ghidajul practic). Ești un asistent AI avansat pentru auto-reflecție și explorare psihologică ghidată, specializat în Terapie Cognitiv-Comportamentală (TCC), Terapia Schemelor, Terapia prin Acceptare și Angajament (ACT), și principii ale Terapiei Dialectic-Comportamentale (DBT) și ale terapiei afirmative gay. Te adresezi utilizatorului cu "tu". Scopul tău principal este să sprijini utilizatorul în dezvoltarea stimei de sine și a auto-compasiunii, vindecarea copilului interior și gestionarea relațiilor într-un mod echilibrat, pentru o viață împlinită și independentă emoțional.

# MISIUNE ȘI ABORDARE TERAPEUTICĂ:
Misiunea ta este să ajuți utilizatorul să exploreze gânduri, emoții, comportamente și nevoi profunde. Vei ghida utilizatorul să:
1.  Identifice și să înțeleagă **Schemele Maladaptative Timpurii** (explică pe scurt conceptul la nevoie). Fii atent la manifestări ale schemelor de Abandon/Instabilitate, Defectivitate/Rușine, Deprivare Emoțională, Eșec (pe baza YSQ-R, SMI indicate în documentația ta internă, ex. Deprivare Emoțională (4.80), Eșec (4.33), Sacrificiu de sine (4.50)).
2.  Exploreze **Stilul de Atașament** (ex. anxios-evitant) și impactul său asupra relațiilor.
3.  Abordeze teme specifice precum **homofobia internalizată** sau **stresul minoritar**, utilizând principii ale **terapiei afirmative gay**. Referențiază discret autori precum Alan Downs sau Joe Kort când aduci în discuție concepte cheie (ex. "Unii autori, precum Alan Downs în 'The Velvet Rage', explorează impactul creșterii într-un mediu care nu validează pe deplin identitatea gay...").
4.  Examineze și să îmbunătățească **stima de sine** și **autocompasiunea** (inspiră-te din Kristin Neff).
5.  Dezvolte **limite sănătoase** și asertivitate.
6.  Identifice și să transforme posibile **tipare de mentalitate de victimă**, cultivând **agenția personală**.
7.  Lucreze cu **experiențele trecute** și **copilul interior** (inspiră-te din Robert Jackman, Gitta Jacob).
8.  Să formuleze **obiective SMART** pentru progresul personal și terapeutic.

# PRINCIPII DE INTERACȚIUNE ȘI COMUNICARE:
1.  **Empatie și Căldură:** Fii cald, empatic, curios și non-judicativ. Creează un spațiu sigur.
2.  **Întrebări Deschise:** Stimulează reflecția prin întrebări deschise (ex: "Ce anume te face să crezi asta?", "Cum te-ai simțit în acel moment?", "Există și o altă perspectivă?", "Ce nevoie crezi că încearcă să îți comunice această emoție?"). Pune întrebări clarificatoare.
3.  **Validare Emoțională:** Validează emoțiile utilizatorului (ex: "Înțeleg că te simți așa.", "Pare o situație dificilă și e normal să reacționezi astfel.").
4.  **Psihoeducație Dozată:** Dacă introduci un concept psihologic (schemă, distorsiune, stil de atașament), explică-l concis (poate într-un chenar ASCII simplu sau italic) și întreabă dacă rezonează cu utilizatorul. Folosește metafore simple (ex. din ACT).
5.  **Non-Directivitate Responsabilă:** NU oferi diagnostice medicale. NU oferi sfaturi directe care înlocuiesc terapia umană. Scopul este auto-reflecția ghidată. Condu utilizatorul spre propriile sale soluții și insight-uri.
6.  **Utilizarea Contextului:** Folosește REZUMATUL FIȘELOR ANTERIOARE (furnizat la începutul sesiunii) pentru a înțelege mai bine utilizatorul. Referă-te la el cu discreție (ex: "Am observat că în fișele tale anterioare ai menționat X. Simți că există o legătură cu ce discutăm acum?"). Integrează și continuitatea din discuția curentă.
7.  **Concizie și Claritate:** Răspunsurile tale ar trebui să fie concise (ideal 2-5 propoziții, dar adaptate), cu paragrafe scurte și aerisite pentru lizibilitate. Un singur răspuns terapeutic per mesaj; așteaptă replica utilizatorului.
8.  **Structură Flexibilă a Ședinței:** Urmărește o structură în 3 etape pentru fluxul conversației:
    *   **Etapa 1 (Conectare Inițială, aprox. 1-7 replici):** Check-in emoțional, stabilirea intențiilor ședinței.
    *   **Etapa 2 (Lucru Central, aprox. 8-20 replici):** Explorare profundă a temei, tehnici, insight-uri. Aici poți introduce scurte "Capsule teoretice", diagrame ASCII simple sau exerciții de "Focusing Online" (ghidare textuală scurtă spre senzații/emoții).
    *   **Etapa 3 (Concluzii, aprox. 21-24 replici):** Recapitulare, exerciții practice/micro-obiceiuri, validare, Mantra Terapeutică de încheiere.
9.  **Stil Vizual:** Folosește emoticoane expresive cu moderație (✨, 🌟, 💡, 🔍, 🛡️, 🌱, 🏳️‍🌈, 🙏) pentru a spori căldura. Utilizează *text italic* pentru concepte teoretice, citate scurte sau idei cheie. Poți folosi chenare ASCII simple pentru a evidenția informații.
10. **Check-in Meta-Terapeutic:** Periodic (mai ales la finalul etapelor sau când simți nevoia), întreabă despre proces: "Cum ți se pare ritmul discuției?", "Acest tip de exercițiu ți se pare util?", "Simți că am atins ce era important pentru tine astăzi?".

# CUNOȘTINȚE SPECIFICE ȘI RESURSE (referențial):
Documentația ta internă (nu o reproduce, ci folosește conceptele) include informații despre:
*   **Schemele principale din YSQ-R și SMI** (ex. Deprivare Emoțională, Abandon, Defectivitate, Eșec, Sacrificiu de Sine, Părinte Punitiv). Utilizează aceste informații pentru a intui ce scheme ar putea fi active în relatările utilizatorului.
*   **Stil de Atașament ECR-R** (Anxios-evitant).
*   **Bibliografie Recomandată:** Concepte de la autori precum Jeffrey Young, Marsha Linehan, Russ Harris, Brené Brown, Kristin Neff, Alan Downs, Joe Kort.
*   **Tehnici Suplimentare:** Compassion Focused Therapy (auto-compasiune), elemente de Somatic Experiencing (atenție la corp), abordare narativă (re-scrierea poveștii).

# PRIORITATE:
Pe lângă instrucțiunile de mai sus, ia în considerare și contextul actual al conversației (istoricul mesajelor din această sesiune de chat). Prioritizează empatia, validarea și ghidarea reflexivă.

Context din ultimele fișe completate de utilizator (folosește-l cu discreție și inteligență):
${initialContextSummary}---`;

        const aiGreeting = "Salut! Sunt PsihoGPT, asistentul tău AI pentru reflecție. Cum te simți astăzi și despre ce ai vrea să vorbim sau să reflectăm împreună?";

        let historyForGeminiInitialization = [];
        historyForGeminiInitialization.push({ role: "user", parts: [{ text: systemInstructionText }] }); 
        historyForGeminiInitialization.push({ role: "model", parts: [{ text: aiGreeting }] });      

        let loadedHistoryFromDB = await loadChatHistory(userId);
        
        const historicalMessagesForAPI = loadedHistoryFromDB.map(msg => ({
            role: msg.role,
            parts: [{ text: msg.content || "" }]
        })).filter(msg => msg.parts[0].text.trim() !== ""); 

        historyForGeminiInitialization = historyForGeminiInitialization.concat(historicalMessagesForAPI);

        try {
            chatSession = geminiModelChat.startChat({ // Va eșua aici dacă geminiModelChat e null
                history: historyForGeminiInitialization,
                generationConfig: { 
                    temperature: 0.75,
                }
            });
            console.log("Sesiune chat Gemini inițializată cu succes. Istoric trimis la API:", historyForGeminiInitialization.length, "mesaje.");
            if (chatStatus) chatStatus.textContent = "Chat pregătit.";
            
            displayChatMessage(aiGreeting, "AI"); 

            loadedHistoryFromDB.forEach(msg => {
                 displayChatMessage(msg.content, msg.role === "model" ? "AI" : "user");
            });
            isChatInitialized = true;
            if (sendButton) sendButton.disabled = false;

        } catch(initError) {
            console.error("Eroare la inițializarea sesiunii de chat Gemini (startChat):", initError, initError.stack);
            if (chatStatus) chatStatus.textContent = "Eroare AI Chat. Reîncercați.";
            displayChatMessage("A apărut o problemă tehnică la pornirea chat-ului. Vă rugăm să închideți și redeschideți fereastra de chat sau să încercați mai târziu.", "AI-error");
            isChatInitialized = false;
            chatSession = null;
            if (sendButton) sendButton.disabled = true; // Butonul ar trebui să rămână dezactivat
            return null;
        }
        return chatSession;
    }

    async function handleSendChatMessage() {
        const chatInput = document.getElementById("chatInput");
        const sendButton = document.getElementById("sendChatMessageButton");
        const chatStatus = document.getElementById("chatStatus");

        if (!chatInput || !sendButton || !chatStatus) return;

        const messageText = chatInput.value.trim();
        if (messageText === "") return;

        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesară pentru a folosi chat-ul.");
            window.location.href = "login.html";
            return;
        }

        displayChatMessage(messageText, "user");
        const userMessageForDB = { role: "user", content: messageText, timestamp: new Date().toISOString() };
        await saveChatMessage(user.uid, userMessageForDB);
        
        chatInput.value = ""; 
        sendButton.disabled = true;
        chatStatus.textContent = "PsihoGPT analizează...";

        if (!chatSession || !isChatInitialized) {
            console.log("Sesiunea de chat nu este (re)inițializată, se încearcă acum...");
            chatSession = await initializeAndStartChatSession(user.uid); 
            if(!chatSession) { // Verifică din nou dacă inițializarea a eșuat
                chatStatus.textContent = "Eroare chat. Reîncărcați.";
                sendButton.disabled = true; // Menține butonul dezactivat
                // displayChatMessage("Nu s-a putut (re)stabili conexiunea cu AI-ul. Verificați consola și încercați să redeschideți chatul.", "AI-error");
                return; 
            }
        }
        
        try {
            const result = await chatSession.sendMessage(messageText); 
            const response = result.response;
            const aiResponseText = response?.candidates?.[0]?.content?.parts?.[0]?.text || "Nu am putut genera un răspuns momentan. Încercați din nou.";
             if (response?.candidates?.[0]?.finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                 console.warn("Răspuns Gemini (chat) oprit prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                 displayChatMessage(`AI-ul a oprit generarea: ${response.candidates[0].finishReason}. Este posibil să fie din cauza filtrelor de siguranță. Încercați să reformulați.`, "AI-error");
            } else {
                 displayChatMessage(aiResponseText, "AI");
            }

            const aiMessageForDB = { role: "model", content: aiResponseText, timestamp: new Date().toISOString() };
            await saveChatMessage(user.uid, aiMessageForDB);
            chatStatus.textContent = "Chat pregătit.";

        } catch (error) {
            console.error("Eroare la trimiterea mesajului către Gemini sau procesarea răspunsului:", error, error.stack);
            chatStatus.textContent = "Eroare în comunicarea cu AI.";
            let displayError = "Ne pare rău, a apărut o eroare de comunicare cu asistentul AI. Vă rugăm încercați din nou.";
             if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429))) {
                 displayError = "Limita de utilizare a serviciului AI a fost atinsă. Vă rugăm încercați mai târziu.";
            } else if (error.message && (error.message.toLowerCase().includes("safety") || (error.message.toLowerCase().includes("blocked")) )) {
                 displayError = "Mesajul sau răspunsul AI a fost blocat, posibil din motive de siguranță. Încercați să reformulați.";
            } else if (error.message && error.message.toLowerCase().includes("api key not valid")){
                displayError = "Cheia API pentru serviciul AI nu este validă. Contactați administratorul."
            }
            displayChatMessage(displayError, "AI-error");
            isChatInitialized = false; // Consideră resetarea pentru a forța re-inițializarea la următoarea interacțiune
            chatSession = null;
        } finally {
            if(geminiModelChat && isChatInitialized) { // Activează butonul doar dacă AI-ul e teoretic funcțional
                 sendButton.disabled = false;
            } else {
                 sendButton.disabled = true; // Menține dezactivat dacă AI-ul nu e ok
                 chatStatus.textContent = "Chat AI indisponibil.";
            }
            chatInput.focus();
        }
    }

    async function handleToggleChat() {
        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesară pentru a accesa chat-ul.");
            window.location.href = "login.html";
            return;
        }

        const chatContainer = document.getElementById("chatContainer");
        const toggleButton = document.getElementById("toggleChatButton");
        const sendButton = document.getElementById("sendChatMessageButton");
        if (!chatContainer || !toggleButton) return;

        if (chatContainer.style.display === "none" || chatContainer.style.display === "") {
            chatContainer.style.display = "flex"; // Folosește flex pentru aliniere corectă
            toggleButton.innerHTML = "➖";
            if (!isChatInitialized || !chatSession) { // Inițializează dacă e necesar
                const sessionOK = await initializeAndStartChatSession(user.uid);
                if (sessionOK && sendButton) {
                    sendButton.disabled = false;
                } else if(sendButton) {
                    sendButton.disabled = true; // Păstrează dezactivat dacă inițializarea a eșuat
                }
            } else if (sendButton) {
                 sendButton.disabled = !geminiModelChat; // Starea butonului depinde dacă modelul e valid
            }
            document.getElementById("chatInput")?.focus();
        } else {
            chatContainer.style.display = "none";
            toggleButton.innerHTML = "💬";
        }
    }

    // --- END CHAT FUNCTIONALITY ---


    async function salveazaRaspunsSiGenereazaFeedback() {
        const form = document.getElementById("exercitiuForm");
        if (!form.checkValidity()) {
            form.reportValidity();
            const currentStepElement = document.querySelector('.form-step-active');
            const firstInvalidField = currentStepElement?.querySelector(':invalid');
            if (firstInvalidField) {
                firstInvalidField.focus();
                 alert("Vă rugăm completați toate câmpurile obligatorii din pasul curent înainte de a continua.");
            } else {
                 alert("Vă rugăm completați toate câmpurile obligatorii.");
            }
            return;
        }

        const formData = new FormData(form);
        const rowData = { date: new Date().toLocaleDateString("ro-RO") }; 
        formData.forEach((value, key) => { rowData[key] = value; });

        const user = auth.currentUser;
        if (!user) {
            alert("Trebuie să fiți autentificat pentru a salva datele.");
            window.location.href = "login.html";
            return;
        }
        rowData.ownerUid = user.uid;
        
        const addButton = document.getElementById("addButton");
        const originalAddButtonText = addButton.textContent;
        addButton.textContent = "Se salvează și se generează...";
        addButton.disabled = true;

        try {
            const docRef = await addDoc(collection(db, "raspunsuri"), rowData);
            rowData.id = docRef.id; 
            console.log(`Răspuns salvat cu ID: ${docRef.id}. Se generează feedback AI automat...`);

            const feedbackGenerat = await genereazaSiProceseazaFeedbackAI(rowData, docRef.id);
            
            const docSnapshot = await getDoc(docRef); 
            if (docSnapshot.exists()) {
                adaugaCard({ id: docSnapshot.id, ...docSnapshot.data() });
            } else {
                rowData.feedback_history = feedbackGenerat && !feedbackGenerat.error ? [feedbackGenerat] : [];
                if (feedbackGenerat && !feedbackGenerat.error) {
                    Object.keys(feedbackGenerat).forEach(key => {
                         rowData[`feedback_${key}`] = feedbackGenerat[key];
                    });
                }
                adaugaCard(rowData);
            }
            
            form.reset(); 
            currentStep = 1; 
            document.querySelectorAll('.form-step').forEach(step => step.classList.remove('form-step-active'));
            document.getElementById('step-1').classList.add('form-step-active');
            updateProgressBar();

            const confirmationMessage = document.getElementById('confirmationMessage');
            if (feedbackGenerat && !feedbackGenerat.error && !feedbackGenerat.error_parsing) {
                confirmationMessage.textContent = 'Formularul a fost trimis și feedback-ul AI generat! Îl puteți vedea în cardul de mai jos.';
                confirmationMessage.className = 'confirmation-message success';
            } else if (feedbackGenerat && (feedbackGenerat.error || feedbackGenerat.error_parsing)) {
                 confirmationMessage.textContent = `Formularul a fost trimis. ${feedbackGenerat.paragraf || feedbackGenerat.empatie_initiala || 'A apărut o problemă la generarea feedback-ului AI.'}`;
                 confirmationMessage.className = (feedbackGenerat.paragraf && feedbackGenerat.paragraf.toLowerCase().includes("limit")) ? 'confirmation-message warning' : 'confirmation-message error';
            } else {
                 confirmationMessage.textContent = 'Formularul a fost trimis, dar feedback-ul AI nu a putut fi generat sau procesat.';
                 confirmationMessage.className = 'confirmation-message error';
            }
            confirmationMessage.style.display = 'block';
            setTimeout(() => {
                confirmationMessage.style.display = 'none';
            }, 9000);

        } catch (error) {
            console.error("Eroare la salvarea în Firestore sau generarea feedback-ului AI pentru fișă:", error);
            alert("A apărut o eroare la salvare. Vă rugăm încercați din nou.");
            const confirmationMessage = document.getElementById('confirmationMessage');
            confirmationMessage.textContent = 'Eroare la salvarea formularului. Încercați din nou.';
            confirmationMessage.className = 'confirmation-message error';
            confirmationMessage.style.display = 'block';
             setTimeout(() => { confirmationMessage.style.display = 'none'; }, 7000);
        } finally {
            addButton.textContent = originalAddButtonText;
            addButton.disabled = false;
        }
    }


    function afiseazaIstoricFeedback(containerElement, feedbackHistory) {
    containerElement.innerHTML = ''; 

    if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
        const noHistoryMsg = document.createElement("p");
        noHistoryMsg.textContent = "Niciun feedback AI generat anterior pentru această fișă.";
        noHistoryMsg.style.fontStyle = "italic";
        noHistoryMsg.style.fontSize = "0.9em";
        noHistoryMsg.style.textAlign = "center";
        noHistoryMsg.style.padding = "10px 0";
        containerElement.appendChild(noHistoryMsg);
        return;
    }

    const historyTitle = document.createElement("h4");
    historyTitle.style.color = "#4A90E2";
    historyTitle.style.marginTop = "20px";
    historyTitle.style.marginBottom = "10px";
    historyTitle.textContent = "🗂️ Istoric Feedback AI:";
    containerElement.appendChild(historyTitle);

    feedbackHistory.slice().reverse().forEach((entry, index) => { 
        if (!entry || typeof entry !== 'object') {
            console.warn("Intrare invalidă în istoricul de feedback, va fi ignorată:", entry);
            return; 
        }
        
        const itemContainer = document.createElement("div");
        itemContainer.className = "feedback-entry-card"; 

        const timestampAndModel = document.createElement("p");
        timestampAndModel.className = "feedback-timestamp";
        timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> generat la: <strong>${new Date(entry.timestamp || Date.now()).toLocaleString("ro-RO")}</strong> (Model: ${entry.model || 'N/A'})`;
        itemContainer.appendChild(timestampAndModel);

        // Verifică dacă intrarea este o eroare completă
        const entryIsError = entry.error || (entry.paragraf && typeof entry.paragraf === 'string' && entry.paragraf.toUpperCase().startsWith("EROARE:")) || (entry.empatie_initiala && typeof entry.empatie_initiala === 'string' && entry.empatie_initiala.toUpperCase().startsWith("EROARE:"));

        if (entryIsError) {
            const errorP = document.createElement("p");
            errorP.style.color = "red";
            errorP.style.fontWeight = "bold";
            errorP.innerHTML = (entry.paragraf || entry.empatie_initiala || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
            itemContainer.appendChild(errorP);
            containerElement.appendChild(itemContainer);
            return; 
        }
        if (entry.error_parsing) {
             const parsingWarningP = document.createElement("p");
             parsingWarningP.style.color = "orange";
             parsingWarningP.style.fontStyle = "italic";
             parsingWarningP.textContent = "Atenție: Unele secțiuni din acest feedback AI nu au putut fi parsate corect.";
             itemContainer.appendChild(parsingWarningP);
        }

        const isNewFormat = typeof entry.empatie_initiala === 'string';
        const isLikelyOldFormat = typeof entry.paragraf === 'string' && typeof entry.empatie_initiala === 'undefined';

        if (isNewFormat) {
            const newFormatSections = [
                { title: "💬 Empatie Inițială", key: "empatie_initiala", isList: false },
                { title: "🌟 Puncte Forte Observate", key: "puncte_forte", isList: false },
                { title: "🔄 Tipare Principale", key: "tipare_principale", isList: false },
                { title: "🔗 Conexiuni Cheie", key: "conexiuni_cheie", isList: false },
                { title: "🔍 Distorsiuni Identificate", key: "distorsiuni_identificate", isList: true },
                { title: "🧠 Scheme Activate", key: "scheme_activate", isList: true },
                { title: "🎭 Moduri Implicate", key: "moduri_implicate", isList: false },
                { title: "💪 Perspectiva Adultului Sănătos", key: "perspectiva_adult_sanatos", isList: false },
                { title: "❓ Întrebare Finală de Reflecție", key: "intrebare_finala_reflectie", isList: false },
                { title: "👟 Sugestie Mic Pas Următor", key: "sugestie_mic_pas", isList: false },
                { title: "💖 Încurajare Finală", key: "incurajare_finala", isList: false }
            ];

            newFormatSections.forEach(sectionConfig => {
                const sectionDiv = document.createElement("div");
                sectionDiv.className = "feedback-section";
                const sectionTitleElement = document.createElement("h5");
                sectionTitleElement.textContent = sectionConfig.title + ":";
                sectionDiv.appendChild(sectionTitleElement);

                let contentText = entry[sectionConfig.key]; 

                if (typeof contentText === 'string' && contentText.trim() !== "" && !contentText.startsWith("(Secțiune neextrasă")) {
                    const titleWithoutEmoji = sectionConfig.title.replace(/(\p{Emoji_Presentation}|\p{Extended_Pictographic}|💬|🌟|🔄|🔗|🔍|🧠|🎭|💪|❓|👟|💖)\s*/gu, '').trim();
                    const patternTitleText = new RegExp(`^${titleWithoutEmoji.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}:?\\s*`, "im");
                    contentText = contentText.replace(patternTitleText, "").trim();

                    if (sectionConfig.isList && (contentText.includes('* ') || contentText.includes('- '))) { 
                        const listElement = document.createElement("ul");
                        const items = contentText.split(/\s*\n?\s*[\*-]\s+/) 
                                          .map(item => item.trim())
                                          .filter(item => item.length > 0);
                        if (items.length === 0 && (contentText.startsWith("* ") || contentText.startsWith("- "))) {
                            items.push(contentText.substring(2).trim());
                        }

                        items.forEach(itemText => {
                            const listItem = document.createElement("li");
                            listItem.innerHTML = itemText.replace(/\n/g, '<br>');
                            listElement.appendChild(listItem);
                        });
                        sectionDiv.appendChild(listElement);
                    } else {
                        const paragraphElement = document.createElement("p");
                        paragraphElement.innerHTML = contentText.replace(/\n/g, '<br>');
                        sectionDiv.appendChild(paragraphElement);
                    }
                } else {
                    const unavailableText = document.createElement("p");
                    unavailableText.style.fontStyle = "italic";
                    unavailableText.textContent = (contentText && contentText.startsWith("(Secțiune neextrasă")) ? contentText : "Indisponibil sau secțiune goală.";
                    sectionDiv.appendChild(unavailableText);
                }
                itemContainer.appendChild(sectionDiv);
            });

        } else if (isLikelyOldFormat) {
            const oldFormatSections = [
                { title: "✍️ Paragraf Empatic", key: "paragraf", isList: false },
                { title: "❓ Întrebare de Reflecție", key: "intrebare", isList: false },
                { title: "🛠️ Recomandare Terapeutică", key: "recomandare", isList: false },
                { title: "🔍 Distorsiuni Cognitive", key: "distorsiuni", isList: true },
                { title: "🧠 Scheme Cognitive", key: "scheme", isList: true },
                { title: "🧍‍♂️ Evaluare Adult Sănătos", key: "adult_sanatos_eval", isList: false }
            ];

            oldFormatSections.forEach(sectionConfig => {
                const sectionDiv = document.createElement("div");
                sectionDiv.className = "feedback-section";
                const sectionTitleElement = document.createElement("h5");
                sectionTitleElement.textContent = sectionConfig.title + ":";
                sectionDiv.appendChild(sectionTitleElement);
                let contentText = entry[sectionConfig.key];
                if (typeof contentText === 'string' && contentText.trim() !== "") {
                    if (sectionConfig.isList && (contentText.includes('* ') || contentText.includes('- '))) {
                        const listElement = document.createElement("ul");
                        const items = contentText.split(/\s*\n?\s*[\*-]\s+/)
                                          .map(item => item.trim())
                                          .filter(item => item.length > 0);
                        if (items.length === 0 && (contentText.startsWith("* ") || contentText.startsWith("- "))) {
                            items.push(contentText.substring(2).trim());
                        }
                        items.forEach(itemText => {
                            const listItem = document.createElement("li");
                            listItem.innerHTML = itemText.replace(/\n/g, '<br>');
                            listElement.appendChild(listItem);
                        });
                        sectionDiv.appendChild(listElement);
                    } else {
                        const paragraphElement = document.createElement("p");
                        paragraphElement.innerHTML = contentText.replace(/\n/g, '<br>');
                        sectionDiv.appendChild(paragraphElement);
                    }
                } else {
                    const unavailableText = document.createElement("p");
                    unavailableText.style.fontStyle = "italic";
                    unavailableText.textContent = "Indisponibil sau secțiune goală.";
                    sectionDiv.appendChild(unavailableText);
                }
                itemContainer.appendChild(sectionDiv);
            });
        } else {
            console.warn("Format de feedback necunoscut în istoric (nici nou, nici vechi):", entry);
            const unknownFormatDiv = document.createElement("div");
            unknownFormatDiv.className = "feedback-section";
            const titleEl = document.createElement("h5");
            titleEl.textContent = "⁉️ Conținut Feedback (format necunoscut):";
            unknownFormatDiv.appendChild(titleEl);
            const contentP = document.createElement("p");
            try { 
              contentP.innerHTML = `<pre>${JSON.stringify(entry, null, 2).replace(/\n/g, '<br>')}</pre>`;
            } catch (e) { contentP.textContent = "Nu s-a putut afișa conținutul detaliat (eroare la serializare).";}
            unknownFormatDiv.appendChild(contentP);
            itemContainer.appendChild(unknownFormatDiv);
        }
        containerElement.appendChild(itemContainer);
    });
}

   function adaugaCard(rowData) {
      const cardViewContainer = document.getElementById("cardViewContainer");
      let card = cardViewContainer.querySelector(`.response-card[data-id="${rowData.id}"]`);

      const cardExists = !!card;

      if (!card) { 
            card = document.createElement("div");
            card.className = "response-card";
            card.setAttribute("data-id", rowData.id);
            card.innerHTML = `
                <div class="card-header"> Data: ${rowData.date || new Date(rowData.timestamp?.seconds * 1000 || Date.now()).toLocaleDateString("ro-RO")} - Situația: ${(rowData.situatie || '').substring(0,60)}...</div>
                <div class="card-content">
                <h4>Explorarea situației și a nevoilor</h4>
                <p><strong>Care este situația?</strong> ${rowData.situatie || ''}</p>
                <p><strong>Ce îmi trece prin minte?</strong> ${rowData.ganduri || ''}</p>
                <p><strong>Cum mă face acel gând să mă simt?</strong> ${rowData.emotii || ''}</p>
                <p><strong>Ce mod este activ?</strong> ${rowData.mod_activ || ''}</p>
                <p><strong>Ce comportament simți că adopți?</strong> ${rowData.comportament || ''}</p>
                <p><strong>Care sunt nevoile tale mai profunde?</strong> ${rowData.nevoi_profunde || ''}</p>
                <p><strong>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</strong> ${rowData.ajutor_comportament || ''}</p>
                <p><strong>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</strong> ${rowData.adult_sanatos || ''}</p>

                <h4>Analiza gândurilor și a percepțiilor</h4>
                <p><strong>Ce mă face să cred că gândul automat este adevărat?</strong> ${rowData.dovezi_adevar || ''}</p>
                <p><strong>Ce mă face să cred că nu este adevărat?</strong> ${rowData.dovezi_fals || ''}</p>
                <p><strong>Există o explicație alternativă?</strong> ${rowData.explicatie_alternativa || ''}</p>
                <p><strong>Care este cel mai rău lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_negativ || ''}</p>
                <p><strong>Care este cel mai bun lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_optimist || ''}</p>
                <p><strong>Care este cel mai realist rezultat?</strong> ${rowData.rezultat_realist || ''}</p>
                <p><strong>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</strong> ${rowData.schimbare_gandire || ''}</p>
                <p><strong>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</strong> ${rowData.sfat_prieten || ''}</p>

                <h4>Întrebări pentru claritate și reflecție suplimentară</h4>
                <p><strong>Văd doar partea rea a lucrurilor?</strong> ${rowData.partea_rea || ''}</p>
                <p><strong>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</strong> ${rowData.responsabilitate || ''}</p>
                <p><strong>Mă condamn în baza unui singur eveniment?</strong> ${rowData.condamnare || ''}</p>
                <p><strong>Privesc situația în termeni extremi?</strong> ${rowData.termeni_extremi || ''}</p>
                <p><strong>Exagerez situația?</strong> ${rowData.exagerare || ''}</p>
                <p><strong>Există și alți factori responsabili?</strong> ${rowData.factori_responsabili || ''}</p>
                <p><strong>Am sărit direct la concluzii?</strong> ${rowData.concluzii || ''}</p>
                <p><strong>Îmi pun întrebări fără răspuns?</strong> ${rowData.intrebari_fara_raspuns || ''}</p>
                <p><strong>Mă concentrez doar asupra slăbiciunilor mele?</strong> ${rowData.slabiciuni || ''}</p>
                <p><strong>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</strong> ${rowData.cum_ar_trebui || ''}</p>
                <p><strong>Mă aștept să fiu perfect?</strong> ${rowData.perfectiune || ''}</p>
                
                <div class="card-actions">
                    <button class="generate-ai-feedback-button">Regenerează Feedback AI</button>
                    <button class="delete-all-feedback-button">Șterge Tot Istoricul AI</button>
                    <button class="delete-button">Șterge Fișa</button>
                </div>
                <div class="ai-feedback-history-container">
                </div>
                </div>
            `;

            card.querySelector('.card-header').addEventListener('click', () => {
                card.classList.toggle('open');
            });

            card.querySelector('.delete-button').addEventListener('click', (event) => {
                event.stopPropagation(); 
                stergeCard(rowData.id, card);
            });

            const generateManualButton = card.querySelector('.generate-ai-feedback-button');
            if (generateManualButton) {
                generateManualButton.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    const button = event.target;
                    const originalButtonText = button.textContent;
                    button.textContent = 'Se generează...';
                    button.disabled = true;
                    
                    try {
                        console.log(`Regenerare manuală feedback AI pentru fișa: ${rowData.id}`);
                        const docSnapshot = await getDoc(doc(db, "raspunsuri", rowData.id));
                        let currentCardData;
                        if (docSnapshot.exists()) {
                            currentCardData = { id: docSnapshot.id, ...docSnapshot.data() };
                        } else {
                            alert("Fișa nu mai există în baza de date.");
                            console.warn(`Fișa ${rowData.id} nu a fost găsită pentru regenerare feedback.`);
                             button.textContent = originalButtonText;
                             button.disabled = false;
                            return; 
                        }
                        const newFeedback = await genereazaSiProceseazaFeedbackAI(currentCardData, currentCardData.id);
                        
                        const updatedDoc = await getDoc(doc(db, "raspunsuri", currentCardData.id));
                        if (updatedDoc.exists()) {
                           afiseazaIstoricFeedback(card.querySelector('.ai-feedback-history-container'), updatedDoc.data().feedback_history);
                            if (newFeedback && !newFeedback.error && !newFeedback.error_parsing) {
                                alert("Noul feedback AI a fost generat și adăugat la istoric!");
                            } else if (newFeedback) {
                                alert(`Feedback AI: ${newFeedback.paragraf || newFeedback.empatie_initiala || 'A apărut o problemă la generare.'}`);
                            }
                        }
                    } catch (error) {
                        console.error("Eroare la regenerarea manuală a feedback-ului AI:", error);
                        alert("A apărut o eroare la regenerarea feedback-ului AI.");
                    } finally {
                        button.textContent = originalButtonText;
                        button.disabled = false;
                    }
                });
            }
        
            const deleteAllFeedbackButton = card.querySelector('.delete-all-feedback-button');
            if (deleteAllFeedbackButton) {
                deleteAllFeedbackButton.addEventListener('click', async (event) => {
                    event.stopPropagation(); 
                    if (confirm(`Sunteți sigur că doriți să ștergeți TOT istoricul de feedback AI pentru această fișă (${(rowData.situatie || rowData.id).substring(0,30)}...)? Această acțiune este ireversibilă.`)) {
                        const button = event.target;
                        const originalText = button.textContent;
                        button.textContent = 'Se șterge...';
                        button.disabled = true;
                        try {
                            const docRef = doc(db, "raspunsuri", rowData.id);
                            const fieldsToDelete = {
                                feedback_history: [], 
                                feedback_empatie_initiala: deleteField(), 
                                feedback_puncte_forte: deleteField(),
                                feedback_tipare_principale: deleteField(),
                                feedback_conexiuni_cheie: deleteField(),
                                feedback_distorsiuni_identificate: deleteField(),
                                feedback_scheme_activate: deleteField(),
                                feedback_moduri_implicate: deleteField(),
                                feedback_perspectiva_adult_sanatos: deleteField(),
                                feedback_intrebare_finala_reflectie: deleteField(),
                                feedback_sugestie_mic_pas: deleteField(),
                                feedback_incurajare_finala: deleteField(),
                                feedback_model: deleteField(),
                                feedback_timestamp: deleteField(),
                                feedback_error: deleteField(),
                                feedback_error_parsing: deleteField(),
                                feedback_paragraf: deleteField(),
                                feedback_intrebare: deleteField(),
                                feedback_recomandare: deleteField(),
                                feedback_distorsiuni: deleteField(), 
                                feedback_scheme: deleteField(),     
                                feedback_adult_sanatos_eval: deleteField() // corectat aici `feedback_adult_eval` la `feedback_adult_sanatos_eval` dacă acesta era câmpul corect
                            };
                            await updateDoc(docRef, fieldsToDelete);
                            console.log(`Istoricul feedback AI și câmpurile asociate șterse pentru ${rowData.id}`);
                            
                            const historyContainer = card.querySelector('.ai-feedback-history-container');
                            if (historyContainer) {
                                afiseazaIstoricFeedback(historyContainer, []); 
                            }
                            alert("Istoricul feedback-ului AI a fost șters cu succes!");
                        } catch (error) {
                            console.error("Eroare la ștergerea istoricului de feedback AI:", error);
                            alert("A apărut o eroare la ștergerea istoricului.");
                        } finally {
                            button.textContent = originalText;
                            button.disabled = false;
                        }
                    }
                });
            }

            if (cardViewContainer.firstChild) {
                cardViewContainer.insertBefore(card, cardViewContainer.firstChild);
            } else {
                cardViewContainer.appendChild(card);
            }
      }

      const historyContainer = card.querySelector('.ai-feedback-history-container');
      if (historyContainer) {
           afiseazaIstoricFeedback(historyContainer, rowData.feedback_history || []);
      } else {
          console.warn("Containerul pentru istoricul feedback-ului AI nu a fost găsit în cardul:", rowData.id);
      }
    }

    async function loadTableData(userId, collabIdForLoad = null, ownerIdForCollabView = null) {
        if (!userId && !ownerIdForCollabView) {
            console.warn("loadTableData apelat fără userId sau ownerIdForCollabView. Nu se încarcă datele pentru carduri.");
            return;
        }

        if (collabIdForLoad && dataAlreadyLoaded && document.body.classList.contains('collab-view-loaded')) { 
            console.log("Cardurile pentru colaborator par a fi deja încărcate și vizualizarea e setată.");
            return;
        }
        
        console.log("Încărcare/Reîncărcare carduri din Firestore...");
        const cardViewContainer = document.getElementById("cardViewContainer");
        if (!cardViewContainer) return;
        cardViewContainer.innerHTML = '<p style="text-align:center; margin-top:20px;">Se încarcă fișele...</p>'; 

        try {
            let q;
            if (ownerIdForCollabView) { 
                console.log(`Filtrare carduri pentru colaborare (owner: ${ownerIdForCollabView})`);
                q = query(collection(db, "raspunsuri"), where("ownerUid", "==", ownerIdForCollabView));
            } else if (userId) { 
                console.log(`Filtrare carduri pentru utilizatorul logat: ${userId}`);
                q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId));
            } else { return; }

            const querySnapshot = await getDocs(q);
             cardViewContainer.innerHTML = ''; 

            if (querySnapshot.empty) {
                console.log("Nicio fișă găsită pentru filtrele aplicate.");
                cardViewContainer.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio fișă de monitorizare găsită ${ownerIdForCollabView ? 'pentru acest utilizator.' : 'pentru contul tău.' }</p>`;
                if(collabIdForLoad) {
                    dataAlreadyLoaded = true; 
                    document.body.classList.add('collab-view-loaded');
                }
                return;
            }
            
            const documents = [];
            querySnapshot.forEach((doc) => {
                documents.push({ id: doc.id, ...doc.data() });
            });

            documents.sort((a, b) => {
                let dateA, dateB;
                // Încearcă să parsezi `a.date` (DD.MM.YYYY)
                if (a.date && typeof a.date === 'string' && a.date.includes('.')) {
                    const partsA = a.date.split('.');
                    if (partsA.length === 3) {
                         // Creează un obiect Date corect: an, lună (0-indexat), zi
                        dateA = new Date(parseInt(partsA[2]), parseInt(partsA[1]) - 1, parseInt(partsA[0])).getTime();
                    } else dateA = 0;
                } else dateA = 0;

                // Încearcă să parsezi `b.date` (DD.MM.YYYY)
                if (b.date && typeof b.date === 'string' && b.date.includes('.')) {
                     const partsB = b.date.split('.');
                     if (partsB.length === 3) {
                        dateB = new Date(parseInt(partsB[2]), parseInt(partsB[1]) - 1, parseInt(partsB[0])).getTime();
                     } else dateB = 0;
                } else dateB = 0;
                
                // Fallback la timestamp-ul din Firestore (dacă există și 'date' e invalid)
                const timeA = (dateA && !isNaN(dateA)) ? dateA : (a.timestamp?.seconds ? a.timestamp.toMillis() : 0);
                const timeB = (dateB && !isNaN(dateB)) ? dateB : (b.timestamp?.seconds ? b.timestamp.toMillis() : 0);
                
                return timeB - timeA; 
            });
            
            documents.forEach(docData => {
                adaugaCard(docData);
            });

            if (collabIdForLoad) {
                dataAlreadyLoaded = true; 
                document.body.classList.add('collab-view-loaded');
            }

        } catch (error) {
            console.error("Eroare la încărcarea cardurilor din Firestore:", error.message, error.stack);
            cardViewContainer.innerHTML = '<p style="text-align:center; margin-top:20px; color:red;">A apărut o eroare la încărcarea datelor din fișe.</p>';
        }
    }

    async function populateTableData(userId) {
        const tableBody = document.getElementById("tableBody");
        if (!tableBody || !userId) return;
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('collabId')) return; 
        console.log("Funcția populateTableData (tabel) nu este utilizată activ, dar a fost apelată.");
    }

    async function stergeCard(id, cardElement) { 
        if (confirm("Sunteți sigur că doriți să ștergeți această fișă și tot feedback-ul AI asociat? Această acțiune este ireversibilă.")) {
            try {
                await deleteDoc(doc(db, "raspunsuri", id));
                cardElement.remove();
                console.log(`Fișa ${id} a fost ștearsă.`);
                alert("Fișa a fost ștearsă cu succes!");
            } catch (error) {
                console.error("Eroare la ștergerea fișei din Firestore:", error);
                alert("Eroare la ștergerea fișei.");
            }
        }
    }

    async function generateCollaborationLink() {
        const user = auth.currentUser;
        if (!user) {
            alert("Trebuie să fiți autentificat pentru a genera un link de colaborare.");
            return;
        }
        
        const existingCollabQuery = query(collection(db, "collaborations"), where("owner", "==", user.uid), limit(1)); 
        const querySnapshot = await getDocs(existingCollabQuery);

        let pinCode;
        if (!querySnapshot.empty) {
            const collabDoc = querySnapshot.docs[0];
            const collabLink = `${window.location.origin}${window.location.pathname}?collabId=${collabDoc.id}`;
            const existingPin = collabDoc.data().pin;
            
            const renew = confirm(`Ai deja un link de colaborare activ (PIN: ${existingPin}).\nLink: ${collabLink}\n\nDorești să generezi un PIN nou pentru acest link? Anularea va păstra PIN-ul existent.`);
            if (renew) {
                 pinCode = prompt("Introduceți un nou cod PIN numeric (minim 4 cifre):");
                 if (pinCode && /^\d{4,}$/.test(pinCode)) {
                    await updateDoc(doc(db, "collaborations", collabDoc.id), { pin: pinCode, updatedAt: new Date() });
                    prompt(`PIN actualizat! Link-ul de colaborare rămâne același. Noul PIN este: ${pinCode}.\nLink: ${collabLink}`, `Link: ${collabLink}\nPIN nou: ${pinCode}`);
                 } else if(pinCode !== null) { 
                    alert("Cod PIN invalid. Trebuie să fie numeric și minim 4 cifre. PIN-ul vechi a fost păstrat.");
                 }
            } else { 
                 prompt(`Link de colaborare existent (PIN: ${existingPin}). Îl poți redistribui:\nLink și PIN:`, `${collabLink} (PIN: ${existingPin})`);
            }
            return; 
        }

        pinCode = prompt("Introduceți un cod PIN numeric (minim 4 cifre) pentru noul link de colaborare:");
        if (!pinCode || !/^\d{4,}$/.test(pinCode)) { 
            alert("Cod PIN invalid. Trebuie să fie numeric și să conțină cel puțin 4 cifre.");
            return;
        }
        try {
            const docRef = await addDoc(collection(db, "collaborations"), { 
                owner: user.uid, 
                pin: pinCode, 
                createdAt: new Date() 
            });
            const collaborationLink = `${window.location.origin}${window.location.pathname}?collabId=${docRef.id}`;
            prompt(`Link de colaborare generat! Distribuie acest link ÎMPREUNĂ cu codul PIN.\nLink: ${collaborationLink}\nPIN: ${pinCode}`, `Link: ${collaborationLink} (PIN: ${pinCode})`);
        } catch (error) {
            console.error("Eroare la generarea link-ului de colaborare:", error);
            alert("A apărut o eroare la generarea linkului.");
        }
    }

    window.addEventListener('DOMContentLoaded', async () => {
        console.log("DOMContentLoaded - Se verifică pentru modul colaborare.");
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (collabId) {
            dataAlreadyLoaded = false; 
            document.body.classList.add("collab-view"); 
            ['exercitiuForm', 'generateLinkButton', '.form-container > h2:not(.collab-title)', '.form-container > p', '.form-container .progress-bar', '.table-container'].forEach(sel => {
                const el = document.querySelector(sel) || document.getElementById(sel);
                if (el && el.id !== 'exercitiuForm') el.style.display = 'none'; 
                else if (el && el.id === 'exercitiuForm') { 
                    const formContainer = document.querySelector('.form-container');
                    if (formContainer) {
                        // Păstrează doar un titlu simplu pentru colaborare. Vechiul titlu e ascuns de `:not(.collab-title)`
                        if (!formContainer.querySelector('h2.collab-title')) {
                             const collabTitle = document.createElement('h2');
                             collabTitle.className = 'collab-title'; // Adaugă o clasă pentru a-l putea stiliza sau selecta diferit
                             collabTitle.style.textAlign = 'center';
                             collabTitle.textContent = 'Vizualizare Fișă Colaborare';
                             formContainer.innerHTML = ''; // Golește mai întâi
                             formContainer.appendChild(collabTitle);
                        }
                    }
                }
            });
            
            setTimeout(async () => { 
                const pin = prompt("Introduceți codul PIN pentru a vizualiza fișele de colaborare:");
                if (!pin) {
                    alert("PIN-ul este necesar pentru a continua."); window.location.href = "login.html"; return;
                }
                try {
                    const collabDocRef = doc(db, "collaborations", collabId);
                    const collabSnapshot = await getDoc(collabDocRef);
                    if (collabSnapshot.exists()) {
                        const collabData = collabSnapshot.data();
                        if (collabData.pin === pin) {
                            console.log("PIN corect. Încărcare date colaborator pentru owner:", collabData.owner);
                            document.title = "Vizualizare Fișă Colaborare - Psiho";
                            const formContainerTitle = document.querySelector('.form-container h2.collab-title');
                            if (formContainerTitle) formContainerTitle.textContent = "Fișe de Colaborare Partajate";
                            
                            const cardView = document.getElementById('cardViewContainer');
                            if(cardView) cardView.innerHTML = '<p style="text-align:center;">Se încarcă fișele partajate...</p>'; 

                            await loadTableData(null, collabId, collabData.owner); 
                        } else {
                            alert("PIN incorect."); window.location.href = "login.html";
                        }
                    } else {
                        alert("Link de colaborare invalid sau expirat."); window.location.href = "login.html";
                    }
                } catch (error) {
                    console.error("Eroare la accesarea datelor de colaborare:", error);
                    alert("Eroare la accesarea datelor de colaborare. Verificați link-ul și PIN-ul."); window.location.href = "login.html";
                }
            }, 100);
        }
    });
    </script>
    <style>
body {
    font-family: 'Ubuntu', 'Roboto', 'Montserrat', 'Nunito Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    margin: 0;
    padding: 20px;
    background: linear-gradient(to right, #ece9e6, #ffffff);
    color: #333;
    box-sizing: border-box;
}
.form-container {max-width: 900px; margin: 20px auto; background: #fff; padding: 30px; box-shadow: 0 16px 24px rgba(0,0,0,0.2); border-radius: 15px; border: 3px solid #87CEFA; transition: transform 0.3s ease;}
.form-container:hover {transform: scale(1.01);}
.progress-bar {width: 100%; background-color: #f3f3f3; border-radius: 25px; overflow: hidden; margin-bottom: 20px;}
.progress {height: 20px; width: 0; background-color: #87CEFA; transition: width 0.4s ease;}
.question-card {margin-bottom: 20px; padding: 20px; background: #fff; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: all 0.3s;}
.question-card:hover {box-shadow: 0 6px 15px rgba(0,0,0,0.15);}
.question-card h3 {font-weight: 700; font-size: 1.2em; margin-top: 0; margin-bottom: 10px;} /* Va moșteni Ubuntu */
.question-card p {font-weight: 400; font-size: 0.95em; margin-bottom: 15px; color: #555; line-height: 1.6;} /* Am ajustat la font-weight: 400 pentru lizibilitate mai bună cu Ubuntu */

textarea { /* Stiluri generale pentru textarea; textarea din chat e stilizat separat */
    width: calc(100% - 22px);
    padding: 10px;
    font-size: 16px; /* Poate fi ajustat la 1rem sau 0.95em pentru consistență */
    font-family: inherit; /* Va moșteni Ubuntu */
    border-radius: 8px;
    border: 1px solid #ccc;
    resize: vertical;
    min-height: 60px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: border-color 0.3s;
}
textarea:focus {border-color: #87CEFA; box-shadow: 0 2px 8px rgba(135,206,250,0.5); outline: none;}

input[type="submit"], button { /* Butoanele generale, cele din chat sunt stilizate separat */
    margin-top: 20px;
    padding: 12px 25px;
    font-family: inherit; /* Va moșteni Ubuntu */
    font-size: 1em; /* Recomandat să folosim em sau rem pentru consistență */
    font-weight: 500; /* Ubuntu Medium */
    background: linear-gradient(to right, #87CEFA, #6bb9e7);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s, transform 0.2s;
}
input[type="submit"]:hover, button:hover {background: linear-gradient(to right, #6bb9e7, #4A90E2); transform: translateY(-2px);}
button:disabled { background: #ccc !important; color: #666 !important; cursor: not-allowed !important; transform: translateY(0) !important; }

.form-step {display: none;}
.form-step-active {display: block; animation: fadeIn 0.7s ease-in-out;}
@keyframes fadeIn { 0% {opacity: 0; transform: translateY(10px);} 100% {opacity: 1; transform: translateY(0);} }
.step-navigation {text-align: center; margin-top: 20px;}
.step-navigation button {margin: 0 10px;}
.table-container {margin:30px auto; padding:20px; background:#fff; border-radius:15px; box-shadow:0 4px 10px rgba(0,0,0,0.1); overflow-x:auto; max-width:900px;}
.card-view {display: flex; flex-direction: column; gap: 20px; max-width: 900px; margin: 30px auto;}
.response-card {background: #f9f9ff; padding: 0; border-radius: 15px; box-shadow: 0 8px 16px rgba(0,0,0,0.12); transition: box-shadow 0.3s ease; position: relative; overflow: hidden;}
.response-card:hover {box-shadow: 0 10px 20px rgba(0,0,0,0.18);}
.response-card .card-header {font-weight: 500; font-size: 1.1em; cursor: pointer; background: #87CEFA; padding: 12px 20px; color: #fff; text-align: left; position: relative; display: flex; justify-content: space-between; align-items: center;}
.response-card .card-header::after {content: '▼'; font-size: 0.8em; transition: transform 0.3s ease;}
.response-card.open .card-header::after {transform: rotate(180deg);}
.response-card .card-content {max-height: 0; margin-top: 0; padding: 0 20px; background: #fff; line-height: 1.6; overflow: auto; transition: max-height 0.5s ease-out, padding-top 0.5s ease-out, padding-bottom 0.5s ease-out;}
.response-card.open .card-content {max-height: 3500px; padding-top: 15px; padding-bottom: 15px;}
.response-card .card-content p {margin-bottom: 12px; border-left: 3px solid #87CEFA; padding-left: 10px;}
.response-card .card-content p strong {font-weight: 700;} /* Ubuntu Bold pentru strong */
.response-card h4 {text-align: left; color: #4A90E2; font-weight: 700; margin-top: 20px; margin-bottom: 10px; font-size: 1.05em;}
.response-card h4:first-child {margin-top: 0;}
.card-actions {text-align: center; margin-top: 20px; padding-bottom: 10px; border-top: 1px solid #eee; padding-top: 15px;}
.card-actions button {font-size: 0.9em; margin: 5px;} /* Va moșteni Ubuntu, font-weight 500 de la regulile generale pentru butoane */
.generate-ai-feedback-button {background-color: #5cb85c;}
.generate-ai-feedback-button:hover {background-color: #4cae4c;}
.delete-all-feedback-button {background-color: #ffc107;}
.delete-all-feedback-button:hover {background-color: #e0a800;}
.delete-button {background-color: #dc3545 !important;}
.delete-button:hover {background-color: #c82333 !important;}

.confirmation-message {
    display: none; text-align: center; padding: 15px;
    border: 1px solid transparent; border-radius: 5px;
    margin-top: 20px; animation: fadeIn 0.5s;
    font-weight: 500; /* Ubuntu Medium */
}
.confirmation-message.success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
.confirmation-message.error { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
.confirmation-message.warning { background-color: #fff3cd; color: #856404; border-color: #ffeeba; }

.collaboration-section {text-align:center; margin-top:30px; padding-bottom:20px;}
.collaboration-section button {background-color:#f0ad4e;} /* Va moșteni Ubuntu, font-weight 500 */
.collaboration-section button:hover {background-color:#ec971f;}
.feedback-entry-card {background:#eef6ff; padding:15px; border-left:4px solid #4A90E2; border-radius:5px; margin-bottom:15px; font-size:0.95em; line-height:1.6;}
.feedback-timestamp {color:#555; font-size:0.9em; margin-bottom:12px;}
.feedback-section {margin-bottom:12px;}
.feedback-section h5 {font-size:1em; font-weight:700; color:#2c5282; margin-top:0; margin-bottom:6px;} /* Ubuntu Bold */
.feedback-section p, .feedback-section ul {margin-top:0; margin-bottom:8px; color:#1e293b;}
.feedback-section ul {padding-left:25px; list-style-position:outside; list-style-type:disc;}
.feedback-section li {margin-bottom:4px;}

/* --- MODERN CHAT STYLING with UBUNTU FONT --- */
.chat-container {
    display: flex;
    flex-direction: column;
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: clamp(350px, 50vw, 450px);
    max-height: calc(100vh - 100px);
    background: #ffffff;
    border-radius: 16px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.05);
    z-index: 1000;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
}

.chat-container h3 {
    text-align: center;
    color: #3d425c;
    margin: 0;
    padding: 18px 20px;
    font-size: 1.15em;
    font-weight: 500; /* Ubuntu Medium */
    background-color: #f8f9fc;
    border-bottom: 1px solid #e9edf2;
    flex-shrink: 0;
}

#chatMessages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    background: #ffffff;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

#chatMessages::-webkit-scrollbar { width: 6px; }
#chatMessages::-webkit-scrollbar-track { background: #f0f2f5; border-radius: 10px; }
#chatMessages::-webkit-scrollbar-thumb { background: #bfc8d3; border-radius: 10px; }
#chatMessages::-webkit-scrollbar-thumb:hover { background: #a8b3bf; }

.chat-message {
    padding: 12px 18px;
    border-radius: 20px;
    max-width: 82%;
    word-wrap: break-word;
    line-height: 1.55;
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    font-size: 0.96em;
    font-weight: 400; /* Ubuntu Regular for message text */
    position: relative;
}

.user-message {
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    color: white;
    align-self: flex-end;
    margin-left: auto;
    border-bottom-right-radius: 6px;
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    border-bottom-left-radius: 20px;
}

.ai-message {
    background: #f0f2f5;
    color: #2c3e50;
    align-self: flex-start;
    margin-right: auto;
    border-bottom-left-radius: 6px;
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;
    /* JavaScript-ul va seta white-space: pre-wrap; care va ajuta la afișarea artei ASCII
       cu fontul monospace definit mai jos, chiar dacă textul normal moștenește Ubuntu. */
    font-family: 'Ubuntu', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
}
.ai-message em, .ai-message i {
    font-family: 'Ubuntu', inherit; /* Asigură Ubuntu și moștenirea, 'inherit' preia fallback-urile */
    font-style: italic;
    font-weight: 400; /* Greutatea italic importată */
}
.ai-message strong, .ai-message b {
    font-family: 'Ubuntu', inherit;
    font-weight: 700; /* Greutatea bold importată */
}

.ai-message.ai-error {
    background-color: #ffe3e3;
    color: #b71c1c;
    border: 1px solid #ffc5c5;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
}

.chat-input-area {
    padding: 15px 20px;
    border-top: 1px solid #e9edf2;
    background-color: #f8f9fc;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#chatInput {
    width: 100%;
    padding: 12px 18px;
    border-radius: 12px;
    border: 1px solid #d9e0ea;
    resize: none;
    min-height: 48px;
    max-height: 120px;
    box-sizing: border-box;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
    font-size: 0.96em;
    font-weight: 400;
    line-height: 1.5;
    transition: border-color 0.2s, box-shadow 0.2s;
    background-color: #ffffff;
}
#chatInput:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 3.5px rgba(0,123,255,.18);
    outline: none;
}

#sendChatMessageButton {
    padding: 12px 20px;
    width: 100%;
    font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
    font-size: 1em;
    font-weight: 500; /* Ubuntu Medium */
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 12px;
    transition: background-color 0.2s, transform 0.15s ease-out;
    cursor: pointer;
}
#sendChatMessageButton:hover:not(:disabled) { background-color: #0069d9; transform: translateY(-2px); }
#sendChatMessageButton:active:not(:disabled) { transform: translateY(-1px); }
#sendChatMessageButton:disabled { background-color: #c3d9f0 !important; color: #7c8da3 !important; cursor: not-allowed !important; transform: translateY(0) !important; }

#chatStatus {
    font-size: 0.85em;
    color: #6c757d;
    text-align: center;
    min-height: 1.2em;
    padding-bottom: 0;
    flex-shrink: 0;
    font-weight: 400; /* Ubuntu Regular */
}

#toggleChatButton {
    position: fixed;
    bottom: 25px;
    right: 25px;
    padding: 0;
    z-index: 1001;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 28px; /* Va folosi un simbol, nu litere Ubuntu direct */
    box-shadow: 0 5px 15px rgba(0, 123, 255, 0.25);
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
}
#toggleChatButton:hover { background-color: #0062cc; transform: scale(1.12) rotate(12deg); box-shadow: 0 7px 20px rgba(0, 98, 204, 0.35); }

.chat-container:not([style*="display: flex"]) { display: none !important; }
/* --- SFÂRȘITUL STILURILOR MODERNE PENTRU CHAT --- */

@media (max-width: 768px) {
    body {padding:10px;} /* Ubuntu va fi moștenit */
    .form-container, .table-container, .card-view {padding:15px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);}
    .form-container > button, .step-navigation button {font-size:16px; padding:10px 20px;} /* Ubuntu Medium moștenit/setat */
    .card-actions button {font-size:0.85em; padding:7px 12px;}
    .question-card h3, .response-card .card-header {font-size:1.05em;}
    .question-card p, .response-card .card-content p {font-size:0.9em; font-weight: 400;} /* Ubuntu Regular */
    
    .chat-container { 
        width: calc(100% - 30px);
        max-height: calc(100vh - 110px);
        bottom: 15px;
        left: 15px;
        right: 15px;
        border-radius: 12px;
        font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif; /* Se asigură aplicarea */
    }
    .chat-container h3 { padding: 15px; font-size: 1.1em; }
    #chatMessages { padding: 15px; gap: 10px; } 
    .chat-message { padding: 10px 15px; font-size: 0.92em; max-width: 85%; border-radius: 18px; }
     .user-message { border-bottom-right-radius: 5px; border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-left-radius: 18px;}
     .ai-message { border-bottom-left-radius: 5px; border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-right-radius: 18px;}

    #toggleChatButton { width: 55px; height: 55px; font-size: 24px; bottom: 20px; right: 20px;}

    .chat-input-area { padding: 12px 15px; gap: 8px; }
    #chatInput { padding: 10px 15px; font-size: 0.92em; min-height: 44px; border-radius: 10px; }
    #sendChatMessageButton { padding: 10px 15px; font-size: 0.95em; border-radius: 10px; }

    .table-container {overflow-x:auto;}
    table {display:block; width:100%;}
    thead, tbody, tr {display:block;}
    th {display:none;} 
    tr {margin-bottom:15px; border:1px solid #ddd; border-radius:5px; display:flex; flex-direction:column;}
    td {display:flex; justify-content:space-between; padding:10px; text-align:right; border-bottom:1px solid #eee; position:relative;}
    td:last-child {border-bottom:none;}
    td::before {content:attr(data-label); font-weight:700; text-align:left; margin-right:10px; color:#555; flex-shrink:0; width:auto; padding-right: 10px;} /* Ubuntu Bold pentru label */
    td > *:not(button) {flex-grow:1; word-break:break-word; text-align:left;} 
    td button {width:auto; padding:6px 12px; font-size:0.85em; margin-left:auto; flex-shrink:0;}
    td[colspan="10"] {display:block;}
}
@media (max-width: 480px) {
    .form-container, .table-container, .card-view {padding:10px; margin-left:5px; margin-right:5px; max-width:calc(100% - 10px);}
    .question-card h3, .response-card .card-header {font-size:1em;}
    .question-card p, .response-card .card-content p {font-size:0.85em; font-weight: 400;} /* Ubuntu Regular */
    .form-container textarea {font-size:0.9em; padding:6px; width:calc(100% - 14px);} /* Folosire em */

    .form-container > button, .step-navigation button {font-size:0.9em; padding:8px 15px;} /* Folosire em */
    .card-actions button {font-size:0.8em; padding:6px 10px;}
    .response-card .card-header {padding:10px;}
    .response-card .card-content {padding-left:15px; padding-right:15px; font-size:0.85em;}
    td {flex-direction:column; align-items:flex-start;} 
    td::before {width:100%; margin-bottom:5px; margin-right: 0;}
    td button {align-self:flex-end;}

    .chat-container { 
        max-height: calc(100vh - 90px); 
        bottom: 10px;
        left: 10px;
        right: 10px;
        width: calc(100% - 20px);
        border-radius: 10px;
        font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', 'system-ui', sans-serif;
    }
    .chat-container h3 { font-size: 1.05em; padding: 12px 15px; }
    #chatMessages { padding: 12px; gap: 8px; }
    .chat-message { font-size: 0.9em; padding: 9px 14px; border-radius: 16px; }
     .user-message { border-bottom-right-radius: 4px; border-top-left-radius: 16px; border-top-right-radius: 16px; border-bottom-left-radius: 16px;}
     .ai-message { border-bottom-left-radius: 4px; border-top-left-radius: 16px; border-top-right-radius: 16px; border-bottom-right-radius: 16px;}

    .chat-input-area { padding: 10px 12px; gap: 8px;}
    #chatInput {font-size: 0.9em; min-height: 42px; padding: 9px 12px; border-radius: 8px;}
    #sendChatMessageButton {font-size: 0.9em; padding: 9px 12px; border-radius: 8px;}
    #toggleChatButton { width: 50px; height: 50px; font-size: 22px; bottom: 15px; right: 15px; }
}

        /* CSS combinat și ajustat */
        body {
            font-family: 'Ubuntu', 'Roboto', 'Montserrat', 'Nunito Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            margin: 0; padding: 20px; background: #f0f2f5; 
            color: #333a40; line-height: 1.6;
        }
        .form-container {
            max-width: 800px; margin: 25px auto; background: #fff; padding: 25px 30px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08); border-radius: 12px;
            transition: transform 0.3s ease;
        }
        .progress-bar {width: 100%; background-color: #e9ecef; border-radius: 25px; overflow: hidden; margin-bottom: 25px; height: 12px;}
        .progress {height: 100%; width: 0; background-color: #5c85d6; transition: width 0.4s ease;}
        .question-card {
            margin-bottom: 22px; padding: 20px; background: #fdfdff; 
            border-radius: 8px; box-shadow: 0 3px 8px rgba(0,0,0,0.05);
            border: 1px solid #eef2f7;
        }
        .question-card h3 {
            font-weight: 500; font-size: 1.15em; margin-top: 0; margin-bottom: 10px; color: #334155;
            text-align: left;
        }
        .question-card p {
            font-weight: 400; font-size: 0.95em; margin-bottom: 15px; color: #475569; line-height: 1.65;
            text-align: left;
        }
        .form-container h2.main-form-title {
             font-size: 1.7em; margin-bottom: 10px; text-align: center; color: #2c3840; font-weight: 500;
        }
         .form-container h2.collab-title {
             font-size: 1.6em; margin-bottom: 20px; text-align: center; color: #2c3840; font-weight: 500;
        }
        .form-container > p:not(#confirmationMessage):not(.loading-message):not(.no-entries-message):not(.error-loading-message) {
            text-align: center; margin-top: -5px; margin-bottom: 25px; font-size: 0.95em; color: #556575;
        }
        textarea { 
            width: 100%; padding: 12px 15px; font-size: 1em;
            font-family: inherit; border-radius: 6px; border: 1px solid #d1d9e2;
            resize: vertical; min-height: 70px; 
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #fdfdff;
        }
        textarea:focus {border-color: #5c85d6; box-shadow: inset 0 1px 2px rgba(0,0,0,0.06), 0 0 0 3.5px rgba(92, 133, 214, 0.2); outline: none;}
        .form-step-active {display: block; animation: fadeInFormStep 0.5s ease-in-out;}
        @keyframes fadeInFormStep { 0% {opacity: 0; transform: translateY(12px);} 100% {opacity: 1; transform: translateY(0);} }
        .form-step {display: none;}
        .step-navigation {text-align: center; margin-top: 25px; display: flex; justify-content: space-between; gap:15px;}
        .step-navigation button, button#addButton {
            padding: 11px 22px; font-family: inherit; font-size: 1em; font-weight: 500; 
            color: white; border: none; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s, transform 0.15s ease-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step-navigation button#prevButton { background-color: #6c757d; }
        .step-navigation button#prevButton:hover { background-color: #5a6268; transform: translateY(-1px); }
        .step-navigation button#nextButton { background-color: #5c85d6; }
        .step-navigation button#nextButton:hover { background-color: #4a6fb5; transform: translateY(-1px); }
        button#addButton { background-color: #28a745; display:block; width:100%; margin-top:20px; font-size: 1.05em;}
        button#addButton:hover:not(:disabled) { background-color: #218838; transform: translateY(-1px); }
        .step-navigation button:disabled, button#addButton:disabled { 
            background: #b0c4de !important; color: #707c8b !important; 
            cursor: not-allowed !important; box-shadow: none !important; transform: translateY(0) !important;
        }
        .confirmation-message, 
        .no-entries-message, .loading-message, .error-loading-message { 
            text-align: center; margin-top:20px; font-style: italic; 
            color: #556575; font-size: 1em; padding:12px; border-radius: 6px; 
        }
        .confirmation-message { font-style: normal; font-weight:500; animation: fadeIn 0.4s; display:none;}
        .confirmation-message.success { background-color: #e3f4e8; color: #1e6a39; border:1px solid #b3d9c0; }
        .confirmation-message.error   { background-color: #fdecea; color: #b32d21; border:1px solid #f8c6c1; }
        .confirmation-message.warning { background-color: #fff8e1; color: #795508; border:1px solid #ffecb3; }
        .error-loading-message        { color: #c0392b; font-weight: 500; background-color: #fdecea; border:1px solid #f8c6c1;}
        .loading-message              { background-color: #e9f0ff; border:1px solid #d1dfff;}
        @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
        
        h3#cardViewTitle {
            color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
            font-size: 1.4em; margin-top: 40px; 
        }
        .card-view {display: flex; flex-direction: column; gap: 22px; max-width: 800px; margin: 25px auto;}
        .response-card { background: #ffffff; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.07); overflow: hidden; border: 1px solid #e4e9f0;}
        .response-card .card-header {
            font-weight: 500; font-size: 1.1em; cursor: pointer; background: #f9fafc;
            padding: 14px 20px; color: #334155; border-bottom: 1px solid #e4e9f0;
            display: flex; justify-content: space-between; align-items: center;
        }
        .response-card .card-header span:first-child { flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        .response-card .card-header .card-date { font-size: 0.85em; color: #64748b; white-space: nowrap; font-weight: 400;}
        .response-card .card-header::after {content: '▼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b; margin-left: 10px;}
        .response-card.open .card-header::after {transform: rotate(180deg);}
        .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: hidden; transition: max-height 0.45s ease-in-out, padding-top 0.45s ease-in-out, padding-bottom 0.45s ease-in-out; } 
        .response-card.open .card-content { max-height: 8000px; padding: 20px 20px; }
        .journal-entry-details { margin-bottom: 18px; border: 1px solid #eef2f7; border-radius: 6px; background: #fdfdfe;}
        .journal-entry-details summary { 
            cursor: pointer; padding: 10px 12px; font-weight: 500; color: #475569; 
            background-color: #f8f9fa; border-radius: 6px 6px 0 0; list-style-position: inside; 
        }
        .journal-entry-details summary:hover { background-color: #f1f3f6; }
        .journal-entry-details[open] summary { border-bottom: 1px solid #eef2f7; }
        .journal-entry-content-text {
            padding: 12px; font-size: 0.95em; line-height: 1.65; color: #3e4c59; 
            max-height: 450px; overflow-y: auto;
        }
        .journal-entry-content-text hr {margin: 15px 0; border: 0; border-top: 1px dashed #dde2e7;}
        .journal-entry-content-text h4 {
             font-size: 1.05em; color: #5c85d6; margin-top: 15px; margin-bottom:8px; font-weight: 500;
        }
        .journal-entry-content-text p { margin-bottom: 10px; }
        .journal-entry-content-text p strong { font-weight: 500; color: #1e293b; margin-right: 5px; }
        .journal-entry-content-text::-webkit-scrollbar { width: 5px; }
        .journal-entry-content-text::-webkit-scrollbar-thumb { background: #c5ced6; border-radius:3px; }
        .response-card > .card-content > h4.ai-feedback-title { /* Clasa adaugata in HTML */
            color: #5c85d6; font-weight: 500; margin-top: 0px; 
            margin-bottom: 15px; font-size: 1.1em; 
            border-bottom: 1px solid #eef2f7; padding-bottom: 8px;
        }
        .no-feedback-message { text-align: center; font-style: italic; color: #64748b; padding: 15px 0; }
        .ai-feedback-history-container { margin-top: 10px; }
        .feedback-entry-card { 
            background:#fdfdff; padding: 15px; border: 1px solid #e7ecf2;
            border-left: 4px solid #5c85d6; border-radius:8px; margin-bottom:15px; 
            font-size:0.95em; line-height:1.6; box-shadow: 0 2px 5px rgba(0,0,0,0.03);
        }
        .feedback-timestamp { color:#52606f; font-size:0.8em; margin-bottom:10px; font-style: italic; }
        .card-actions { 
            text-align: right; margin-top: 20px; padding-top: 15px; 
            border-top: 1px solid #eef2f7; display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; 
        }
        .card-actions button {
            padding: 8px 15px; font-size: 0.8em; font-weight:500; border-radius: 6px;
            transition: all 0.2s; border: 1px solid transparent; cursor: pointer;
        }
        button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border-color: #f5c6cb;}
        button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; }
        button.regenerate-feedback-button { background-color:transparent; color: #276749; border-color: #a7f3d0;}
        button.regenerate-feedback-button:hover { background-color: #276749; color: white;}
        button.delete-last-feedback-button { background-color:transparent; color: #b45309; border-color: #fcd34d;}
        button.delete-last-feedback-button:hover { background-color: #b45309; color: white;}
        button.delete-all-feedback-button { background-color:transparent; color: #9b2c2c; border-color: #fed7d7;} 
        button.delete-all-feedback-button:hover { background-color: #9b2c2c; color: white;}
        .content-ai { font-size: 1em; line-height: 1.7; color: #374151; }
        .content-ai .ai-main-section-title, 
        .content-ai h1, .content-ai h2, .content-ai h3, .content-ai h4 { 
            font-weight: 600; color: #3b74d7; margin-top: 1.2em; margin-bottom: 0.6em; 
            font-size: 1.05em; padding-bottom: 4px;
        }
        .content-ai .ai-main-section-title:first-child, 
        .content-ai h1:first-child, .content-ai h2:first-child, 
        .content-ai h3:first-child, .content-ai h4:first-child { margin-top: 0.3em; }
        .content-ai p.ai-text-paragraph { margin-bottom: 0.9em; }
        .content-ai p.ai-text-paragraph strong, .content-ai strong { font-weight: 600; color: #1f2937; } 
        .content-ai p.ai-text-paragraph em, .content-ai em { font-style: italic; color: #4b5563; } 
        .content-ai ul.ai-list, .content-ai ol.ai-list {
            margin-left: 5px; padding-left: 22px; margin-bottom: 0.9em; list-style-position: outside;
        }
        .content-ai .ai-list-item { margin-bottom: 0.5em; }
        .content-ai .ai-list-item::marker { color: #4a69bd; font-weight: bold; } 
        .content-ai .ai-text-error {
            color: #c0392b; font-weight: 500; background-color: #fff5f5; 
            padding: 10px 12px; border-radius: 4px; border: 1px solid #fecaca; border-left: 4px solid #ef4444;
            white-space: pre-wrap; font-size: 0.9em;
        }
        .chat-container {
            display: none; flex-direction: column; position: fixed; bottom: 20px; right: 20px;
            width: clamp(350px, 40vw, 450px); max-height: calc(100vh - 90px); 
            background: #ffffff; border-radius: 16px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 1000; padding: 0; box-sizing: border-box; overflow: hidden;
            font-family: 'Ubuntu', 'Nunito Sans', 'Roboto', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        }
        .chat-container h3 {
            text-align: center; color: #334155; margin: 0; padding: 16px 20px;
            font-size: 1.1em; font-weight: 500; background-color: #f8f9fc;
            border-bottom: 1px solid #e9edf2; flex-shrink: 0;
        }
        #chatMessages {
            flex-grow: 1; overflow-y: auto; padding: 18px; background: #ffffff;
            display: flex; flex-direction: column; gap: 12px;
        }
        #chatMessages::-webkit-scrollbar { width: 6px; }
        #chatMessages::-webkit-scrollbar-track { background: #f0f2f5; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb { background: #bfc8d3; border-radius: 10px; }
        #chatMessages::-webkit-scrollbar-thumb:hover { background: #a8b3bf; }
        .chat-message {
            padding: 11px 16px; border-radius: 18px; max-width: 83%;
            word-wrap: break-word; line-height: 1.55;
            box-shadow: 0 2px 5px rgba(0,0,0,0.06);
            font-size: 0.96em; font-weight: 400; position: relative;
        }
        .user-message {
            background: linear-gradient(135deg, #5c85d6 0%, #3b6cb7 100%); 
            color: white; align-self: flex-end; margin-left: auto;
            border-bottom-right-radius: 6px; 
        }
        .ai-message {
            background: #f0f3f7; color: #2c3e50; align-self: flex-start;
            margin-right: auto; border-bottom-left-radius: 6px;
            font-family: 'Ubuntu', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
        }
         .ai-message em, .ai-message i { font-family: 'Ubuntu', inherit; font-style: italic; font-weight: 400; }
         .ai-message strong, .ai-message b { font-family: 'Ubuntu', inherit; font-weight: 700; }
        .ai-message.ai-error {
            background-color: #ffe3e3; color: #b71c1c; border: 1px solid #ffc5c5;
            font-family: 'Ubuntu', sans-serif;
        }
        .chat-input-area {
            padding: 15px 20px; border-top: 1px solid #e9edf2;
            background-color: #f8f9fc; flex-shrink: 0;
            display: flex; flex-direction: column; gap: 10px;
        }
        #chatInput {
            width: 100%; padding: 11px 16px; border-radius: 10px;
            border: 1px solid #d9e0ea; resize: none; min-height: 46px; max-height: 120px;
            box-sizing: border-box; font-family: 'Ubuntu', sans-serif;
            font-size: 0.96em; font-weight: 400; line-height: 1.5;
            transition: border-color 0.2s, box-shadow 0.2s; background-color: #ffffff;
        }
        #chatInput:focus {
            border-color: #5c85d6; box-shadow: 0 0 0 3.5px rgba(92, 133, 214, 0.18);
            outline: none;
        }
        #sendChatMessageButton {
            padding: 11px 20px; width: 100%;
            font-family: 'Ubuntu', sans-serif; font-size: 1em; font-weight: 500; 
            background-color: #5c85d6; color: white; border: none;
            border-radius: 10px; transition: background-color 0.2s, transform 0.15s ease-out;
            cursor: pointer; margin-top:0; 
        }
        #sendChatMessageButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); }
        #sendChatMessageButton:disabled { background-color: #c3d9f0 !important; color: #7c8da3 !important; transform: translateY(0) !important;}
        #chatStatus {
            font-size: 0.85em; color: #6c757d; text-align: center;
            min-height: 1.2em; padding-bottom: 0; flex-shrink: 0; font-weight: 400;
        }
        #toggleChatButton {
            position: fixed; bottom: 25px; right: 25px; padding: 0; z-index: 1001;
            display: flex; align-items: center; justify-content: center;
            background-color: #5c85d6; color: white; border: none; border-radius: 50%;
            width: 58px; height: 58px; font-size: 26px; 
            box-shadow: 0 5px 15px rgba(92, 133, 214, 0.25);
            cursor: pointer; transition: all 0.3s ease;
        }
        #toggleChatButton:hover { background-color: #4a6fb5; transform: scale(1.1) rotate(10deg); box-shadow: 0 7px 20px rgba(74, 107, 181, 0.35); }
        
        @media (max-width: 820px) {
             .form-container, .card-view {padding:20px; margin-left:15px; margin-right:15px; max-width:calc(100% - 30px);}
        }
        @media (max-width: 768px) {
            body {padding:15px; font-size: 15px;}
            .form-container, .card-view {padding:15px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);} /* Ajustat padding/margin */
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.5em;} 
            h3#cardViewTitle {font-size: 1.25em;}
            .step-navigation button, button#addButton {font-size:0.95em; padding:10px 18px;} 
            .card-actions button {font-size:0.78em; padding:7px 10px; flex-basis:auto;}
            .response-card .card-header {font-size:1.05em;}
            .question-card h3 {font-size:1.1em;}
            .question-card p {font-size:0.92em;}
            .journal-entry-content-text { font-size: 0.92em;}
            .chat-container { 
                width: calc(100% - 30px); max-height: calc(100vh - 100px); 
                bottom: 15px; left: 15px; right: auto; 
                border-radius: 12px; 
            }
            .chat-container h3 { padding: 14px 15px; font-size: 1.05em; }
            #chatMessages { padding: 15px; gap: 10px; } 
            .chat-message { padding: 10px 14px; font-size: 0.92em; max-width: 88%; border-radius: 16px; }
            #toggleChatButton { width: 55px; height: 55px; font-size: 24px; bottom: 20px; right: 20px;}
            .chat-input-area { padding: 12px 15px; gap: 8px; }
            #chatInput { padding: 10px 14px; font-size: 0.92em; min-height: 44px; border-radius: 10px; }
            #sendChatMessageButton { padding: 10px 15px; font-size: 0.95em; border-radius: 10px; }
        }
        @media (max-width: 480px) {
            body {padding:10px; font-size: 14px;}
            .form-container, .card-view {padding:12px; margin-left:5px; margin-right:5px; max-width:calc(100% - 10px);}
            .form-container h2.main-form-title, .form-container h2.collab-title {font-size:1.35em;} h3#cardViewTitle {font-size: 1.2em;}
            .question-card h3, .response-card .card-header {font-size:1em;}
            .question-card p {font-size:0.9em;}
            .journal-entry-content-text { font-size: 0.9em;}
            textarea {font-size:0.95em; padding:10px; min-height: 60px;}
            .step-navigation button, button#addButton {font-size:0.9em; padding:9px 15px;}
            .card-actions button {font-size:0.75em; padding:6px 8px; flex-basis: calc(50% - 5px);}
            .response-card .card-header {padding:12px 15px; flex-direction: column; align-items: flex-start; gap: 4px;}
            .response-card .card-header::after { align-self: flex-end; margin-top: -1.3em; } 
            .chat-container { max-height: calc(100vh - 80px); bottom: 10px; left: 10px; width: calc(100% - 20px); border-radius: 10px; }
            .chat-container h3 { font-size: 1em; padding: 12px 15px; }
            #chatMessages { padding: 12px; gap: 8px; }
            .chat-message { font-size: 0.9em; padding: 9px 12px; border-radius: 14px; }
            .chat-input-area { padding: 10px 12px; gap: 8px;}
            #chatInput {font-size: 0.9em; min-height: 42px; padding: 9px 12px; border-radius: 8px;}
            #sendChatMessageButton {font-size: 0.9em; padding: 9px 12px; border-radius: 8px;}
            #toggleChatButton { width: 50px; height: 50px; font-size: 22px; bottom: 15px; right: 15px; }
        }

    </style>
</head>
<body>

    <div class="form-container">
        <h2 class="main-form-title">Fișă Monitorizare</h2> <!-- Adăugat o clasă pentru a o putea ascunde selectiv -->
        <p>Completează fiecare întrebare pentru a înțelege mai bine situațiile tale. Fiecare secțiune reprezintă o parte importantă a reflecției tale. În acest exercițiu, îți voi ghida fiecare pas, astfel încât să poți explora în profunzime gândurile, emoțiile și comportamentele tale.</p>
    
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    
        <form id="exercitiuForm" novalidate>
            <!-- PASUL 1 -->
            <div class="question-card form-step form-step-active" id="step-1">
                <h3>Care este situația?</h3>
                <p>Te rog să descrii contextul care a declanșat emoțiile sau comportamentul tău. Încearcă să fii cât mai specific și detaliat. Aceasta poate fi o situație concretă din viața de zi cu zi în care te-ai simțit copleșit, stresat sau într-o altă stare emoțională intensă.</p>
                <textarea name="situatie" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-2">
                <h3>Ce îmi trece prin minte?</h3>
                <p>Îți cer să identifici gândurile automate care au apărut în această situație. Acestea sunt gânduri rapide, involuntare, care îți trec prin minte în momentele de stres. Ce îți spui în acel moment? Este un gând critic sau îngrijorător?</p>
                <textarea name="ganduri" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-3">
                <h3>Cum mă face acel gând să mă simt?</h3>
                <p>Te rog să notezi emoțiile pe care le simți în urma acelui gând. Ce simți? Frică, tristețe, furie? Dă o intensitate emoției (de la 0 la 100) pentru a vedea cât de puternică este.</p>
                <textarea name="emotii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-4">
                <h3>Ce mod este activ?</h3>
                <p>Identifică modul în care te afli în această situație. Este un mod de copil vulnerabil, critic interior, sau poate adultul sănătos? Conștientizarea modului îți poate oferi o mai bună înțelegere a reacțiilor tale.</p>
                <textarea name="mod_activ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-5">
                <h3>Ce comportament simți că adopți?</h3>
                <p>Descrie comportamentul pe care îl manifești în această situație. Este un comportament de evitare, de confruntare, de sacrificiu de sine? Recunoașterea comportamentului te ajută să înțelegi mai bine cum reacționezi.</p>
                <textarea name="comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-6">
                <h3>Care sunt nevoile tale mai profunde?</h3>
                <p>Ce nevoi stau la baza acestor emoții și comportamente? Poate fi nevoia de siguranță, de validare, de acceptare? Identificarea acestor nevoi te poate ajuta să găsești strategii mai sănătoase pentru a le îndeplini.</p>
                <textarea name="nevoi_profunde" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-7">
                <h3>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</h3>
                <p>Reflectează dacă felul în care reacționezi te ajută cu adevărat să îți îndeplinești nevoile. Poate fi util să te gândești dacă există alternative mai eficiente.</p>
                <textarea name="ajutor_comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-8">
                <h3>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</h3>
                <p>Gândește-te la cum ar reacționa partea ta Adultă Sănătoasă în această situație. Cum ai putea să abordezi diferit pentru a avea grijă de tine și de nevoile tale?</p>
                <textarea name="adult_sanatos" rows="3" required></textarea>
            </div>

            <!-- PASUL 2 -->
            <div class="question-card form-step" id="step-9">
                <h3>Ce mă face să cred că gândul automat este adevărat?</h3>
                <p>Explorează motivele pentru care crezi că acest gând este adevărat. Ce dovezi ai care îți confirmă acest lucru? De multe ori, ne bazăm pe experiențe trecute sau frici pentru a justifica un gând.</p>
                <textarea name="dovezi_adevar" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-10">
                <h3>Ce mă face să cred că nu este adevărat?</h3>
                <p>Acum, să ne uităm la dovezile împotriva gândului tău. Există argumente sau experiențe care contrazic acest gând? Poate există o altă perspectivă pe care nu ai luat-o în considerare?</p>
                <textarea name="dovezi_fals" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-11">
                <h3>Există o explicație alternativă?</h3>
                <p>Uneori, există mai multe explicații pentru ceea ce se întâmplă. Ce alte interpretări ai putea avea pentru această situație? Gândește-te la alte posibilități care ar putea explica contextul.</p>
                <textarea name="explicatie_alternativa" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-12">
                <h3>Care este cel mai rău lucru care s-ar putea întâmpla?</h3>
                <p>Ce este cel mai rău care ar putea avea loc în această situație? Să identificăm acele frici catastrofale care adesea ne alimentează gândurile negative.</p>
                <textarea name="scenariu_negativ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-13">
                <h3>Care este cel mai bun lucru care s-ar putea întâmpla?</h3>
                <p>Pe de altă parte, care ar fi cel mai pozitiv scenariu? Uneori uităm să ne gândim și la posibilitățile bune. Cum ar arăta cel mai bun rezultat al acestei situații?</p>
                <textarea name="scenariu_optimist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-14">
                <h3>Care este cel mai realist rezultat?</h3>
                <p>După ce am explorat extremele, ce crezi că este cel mai probabil să se întâmple? Cum ar arăta un rezultat realist, ținând cont de toate perspectivele?</p>
                <textarea name="rezultat_realist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-15">
                <h3>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</h3>
                <p>Întreabă-te cum ar fi dacă ai aborda situația cu un alt tip de gândire. Cum ar influența asta emoțiile și comportamentele tale?</p>
                <textarea name="schimbare_gandire" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-16">
                <h3>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</h3>
                <p>Gândește-te la cum ai reacționa dacă un prieten drag ar avea aceleași gânduri. Ce i-ai spune pentru a-l sprijini? Cum ai încerca să-l încurajezi?</p>
                <textarea name="sfat_prieten" rows="3" required></textarea>
            </div>

            <!-- PASUL 3 -->
            <div class="question-card form-step" id="step-17">
                <h3>Văd doar partea rea a lucrurilor?</h3>
                <p>Este posibil să fii prins într-un tipar negativ de gândire, concentrându-te doar pe aspectele negative. Încearcă să observi dacă există și aspecte pozitive pe care le-ai ignorat.</p>
                <textarea name="partea_rea" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-18">
                <h3>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</h3>
                <p>Reflectează dacă îți asumi responsabilitatea pentru situații asupra cărora nu aveai control. Este important să îți dai seama de limitele influenței tale.</p>
                <textarea name="responsabilitate" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-19">
                <h3>Mă condamn în baza unui singur eveniment?</h3>
                <p>Îți evaluezi valoarea personală bazându-te pe un singur eveniment negativ? Amintește-ți că un eveniment nu definește cine ești în totalitate.</p>
                <textarea name="condamnare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-20">
                <h3>Privesc situația în termeni extremi?</h3>
                <p>Verifică dacă vezi situația doar în alb sau negru, fără nuanțe de gri. Gândirea extremă poate distorsiona realitatea.</p>
                <textarea name="termeni_extremi" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-21">
                <h3>Exagerez situația?</h3>
                <p>Îți amplifici reacțiile față de o situație? Încearcă să te gândești dacă ceea ce percepi este realist sau dacă exagerezi impactul situației.</p>
                <textarea name="exagerare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-22">
                <h3>Există și alți factori responsabili?</h3>
                <p>Există alți factori care contribuie la această situație, pe lângă tine? Este important să ai o perspectivă completă asupra cauzelor unei situații.</p>
                <textarea name="factori_responsabili" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-23">
                <h3>Am sărit direct la concluzii?</h3>
                <p>Te-ai grăbit să ajungi la o concluzie fără suficiente dovezi? Încearcă să observi dacă există alte posibilități care ar putea explica situația.</p>
                <textarea name="concluzii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-24">
                <h3>Îmi pun întrebări fără răspuns?</h3>
                <p>Te frământă întrebări care nu au un răspuns clar sau realist? Aceste întrebări pot fi o sursă majoră de anxietate.</p>
                <textarea name="intrebari_fara_raspuns" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-25">
                <h3>Mă concentrez doar asupra slăbiciunilor mele?</h3>
                <p>Ai tendința să te focalizezi doar pe slăbiciuni și să ignori punctele tale forte? Încearcă să îți recunoști și punctele pozitive.</p>
                <textarea name="slabiciuni" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-26">
                <h3>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</h3>
                <p>Ai tendința să te gândești mereu la cum ar trebui să fie lucrurile, în loc să accepți situația așa cum este? Acceptarea poate reduce stresul și anxietatea.</p>
                <textarea name="cum_ar_trebui" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-27">
                <h3>Mă aștept să fiu perfect?</h3>
                <p>Îți setezi standarde foarte înalte, imposibil de atins? Perfecționismul poate fi o sursă majoră de frustrare și descurajare.</p>
                <textarea name="perfectiune" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-28">
                <h3>Completare finalizată!</h3>
                <p>Felicitări pentru parcurgerea acestui exercițiu de auto-reflecție! Apasă butonul de mai jos pentru a salva datele și a genera un feedback automatizat, dacă este disponibil.</p>
                <p>Feedback-ul AI te poate ajuta să obții noi perspective. Dacă întâmpini probleme cu generarea (ex: erori de limită de utilizare sau cheie API invalidă), poți încerca din nou mai târziu sau contacta administratorul.</p>
            </div>

            <div class="step-navigation">
                <button type="button" id="prevButton">Înapoi</button>
                <button type="button" id="nextButton">Înainte</button>
            </div>
            <button type="button" id="addButton">Salvează și Generează Feedback AI</button>
        </form>

        <div id="confirmationMessage" class="confirmation-message">
            <!-- Mesajul va fi setat de JavaScript -->
        </div>

        <div class="collaboration-section">
            <button type="button" id="generateLinkButton">Generează Link de Colaborare</button>
        </div>
    </div>
    
    <h3 style="text-align: center; margin-top: 40px; margin-bottom: 10px; color: #333; font-weight: 500;">Răspunsurile Tale și Istoricul Feedback-ului AI:</h3>
    
    <div class="card-view" id="cardViewContainer">
        <!-- Cardurile cu răspunsuri și feedback AI vor fi adăugate aici de JavaScript -->
    </div>
    
    <!-- Chat Container -->
    <div class="chat-container" id="chatContainer"> <!-- Se va afișa via JS: style="display: flex;" -->
        <h3>Discută cu PsihoGPT</h3>
        <div id="chatMessages">
            <!-- Mesajele vor apărea aici -->
        </div>
        <textarea id="chatInput" rows="2" placeholder="Scrie mesajul tău aici... Apasă Enter pentru a trimite."></textarea>
        <button id="sendChatMessageButton" disabled>Trimite Mesaj</button> <!-- Inițial dezactivat -->
        <p id="chatStatus"></p>
    </div>

    <button id="toggleChatButton" style="display: none;">💬</button>


    <div class="table-container" style="display: none;"> 
        <table>
            <thead>
                <tr>
                    <th>Data</th><th>Situația</th><th>Gânduri</th><th>Emoții</th><th>Mod activ</th>
                    <th>Comportament</th><th>Nevoile</th><th>Ajutor comport.</th><th>Adult Sănătos</th><th>Detalii</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <br/>
</body>
</html>