<!DOCTYPE html>
<html>
<head>
    <title>Fișă Monitorizare - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, query, where } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai"; // Import pentru Gemini SDK

    // Configurarea Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // Înlocuiește cu cheia ta reală dacă e diferită
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    // Inițializare Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // --- Configurare Gemini API (Folosit direct în frontend) ---
    // !! ATENȚIE MAXIMĂ: Asigură-te că ai RESTRICȚII puternice pe această cheie în Google Cloud Console.
    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÎNLOCUIEȘTE ASTA CU CHEIA TA REALĂ!
    const GEMINI_MODEL_NAME = "gemini-1.5-flash-latest"; // Sau gemini-pro
    let genAI, geminiModel;

    if (GEMINI_API_KEY && GEMINI_API_KEY !== "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModel = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME });
            console.log("SDK Gemini inițializat cu modelul:", GEMINI_MODEL_NAME);
        } catch (e) {
            console.error("Eroare la inițializarea SDK Gemini:", e);
            geminiModel = null; // Asigură-te că e null dacă inițializarea eșuează
        }
    } else {
        console.warn("Cheia API pentru Gemini nu este configurată. Feedback-ul AI prin Gemini va fi dezactivat.");
        geminiModel = null;
    }
    // --- Sfârșit Configurare Gemini API ---

    let currentStep = 1;
    let totalSteps = 0;
    let dataAlreadyLoaded = false;


    window.onload = function () {
        totalSteps = document.querySelectorAll('.form-step').length;
        updateProgressBar();
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        // Logica de autentificare și încărcare date
        if (collabId) {
            // Gestionarea vizualizării colaboratorului se face în listener-ul DOMContentLoaded
        } else {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    console.log("Utilizator autentificat:", user.uid);
                    // Dacă utilizatorul este autentificat, încărcăm datele lui
                    if (!dataAlreadyLoaded) { // Adăugat pentru a evita reîncărcări multiple
                        populateTableData(user.uid); // Pentru tabel (dacă se folosește)
                        loadTableData(user.uid);     // Pentru carduri
                        dataAlreadyLoaded = true;
                    }
                } else {
                    console.log("Utilizator neautentificat, redirecționare...");
                    window.location.href = "login.html";
                }
            });
        }


        const nextButton = document.getElementById("nextButton");
        if (nextButton) nextButton.addEventListener("click", nextStep);

        const prevButton = document.getElementById("prevButton");
        if (prevButton) prevButton.addEventListener("click", previousStep);

        const addButton = document.getElementById("addButton");
        if (addButton) addButton.addEventListener("click", salveazaRaspunsSiGenereazaFeedback);

        const generateLinkButton = document.getElementById("generateLinkButton");
        if (generateLinkButton) generateLinkButton.addEventListener("click", generateCollaborationLink);

    };

    function nextStep() {
        if (currentStep < totalSteps) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep++;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function previousStep() {
        if (currentStep > 1) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep--;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function updateProgressBar() {
        const progress = document.getElementById('progress');
        if(progress && totalSteps > 0) { // Adaugat totalSteps > 0
            const progressPercentage = (currentStep / totalSteps) * 100;
            progress.style.width = progressPercentage + '%';
        }
    }

    async function genereazaFeedbackCuGeminiDinFrontend(promptText) {
        if (!geminiModel) {
            console.error("Modelul Gemini nu este inițializat. Verifică cheia API.");
            return "EROARE: Configurare Gemini incorectă. Verifică dacă ai introdus corect cheia API în cod.";
        }
        try {
            console.log("Trimitere prompt către Gemini:", promptText.substring(0, 100) + "..."); // Loghează o parte din prompt
            const result = await geminiModel.generateContent(promptText);
            const response = result.response;
            if (!response || typeof response.text !== 'function') {
                 console.error("Răspuns neașteptat de la Gemini (nu conține text()):", response);
                 return `EROARE Gemini: Răspuns invalid de la API (status ${response?.status || 'necunoscut'}).`;
            }
            const text = response.text();
            return text;
        } catch (error) {
            console.error("Eroare detaliată la generarea feedback-ului Gemini:", error);
            let errorMessage = `EROARE Gemini: ${error.message || "Eroare necunoscută la comunicarea cu API-ul"}`;
            if (error.message && error.message.toLowerCase().includes("api key not valid")) {
                 errorMessage = "EROARE: Cheia API Gemini nu este validă sau nu are permisiuni. Verifică restricțiile din Google Cloud Console (HTTP Referrers, API Restrictions pentru Generative Language API) și cheia din cod.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429) )) {
                errorMessage = "EROARE: Limita de utilizare gratuită Gemini a fost depășită. Încearcă mai târziu.";
            } else if (error.message && error.message.toLowerCase().includes("candidate.finish_reason")){
                errorMessage = "EROARE Gemini: Generarea a fost oprită din motive de siguranță sau alte restricții ale modelului.";
            }
            return errorMessage;
        }
    }

    async function genereazaSiProceseazaFeedbackAI(rowData, docId) {
      const prompt = `
Analizează această fișă de auto-reflecție și oferă feedback psihologic structurat. Respectă cu strictețe formatul și ordinea secțiunilor de mai jos, folosind exact prefixele indicate (ex. "Paragraf:", "Întrebare:").
1. Paragraf empatic. (Începe cu "Paragraf:")
2. O întrebare de reflecție. (Începe cu "Întrebare:")
3. O recomandare terapeutică (CBT, DBT sau mindfulness). (Începe cu "Recomandare:")
4. Identifică posibile distorsiuni cognitive (ex: suprageneralizare, personalizare). Listează fiecare distorsiune pe un rând nou, precedată de '* '. (Începe cu "Distorsiuni:")
5. Identifică posibile scheme si moduri cognitive implicate, conform schema therapy. Listează fiecare schemă pe un rând nou, precedată de '* '. (Începe cu "Scheme:")
6. Evaluează dacă Adultul Sănătos este prezent și cum ar putea fi activat mai mult. (Începe cu "Adult Sănătos:")

Datele introduse de utilizator sunt următoarele:
Situație: ${rowData.situatie  || 'N/A'}
Gânduri: ${rowData.ganduri || 'N/A'}
Emoții: ${rowData.emotii || 'N/A'}
Comportament: ${rowData.comportament || 'N/A'}
Cum ar acționa Adultul Sănătos (menționat de utilizator): ${rowData.adult_sanatos || 'N/A'}

Te rog să răspunzi doar cu textul cerut conform structurii, fără introduceri sau concluzii suplimentare.`;

      let feedbackText = null;
      let modelFolosit = "N/A";

      if (geminiModel) {
        console.log("Solicitare feedback de la Gemini...");
        modelFolosit = `Gemini (${GEMINI_MODEL_NAME})`;
        feedbackText = await genereazaFeedbackCuGeminiDinFrontend(prompt);
      } else {
        console.warn("Gemini nu este configurat (cheia API lipsește sau este incorectă). Nu se poate genera feedback AI.");
        return {
            paragraf: "Serviciul de feedback AI (Gemini) nu este configurat corect. Verifică cheia API în codul sursă.",
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "",
            model: "Configurare Gemini Eronată", timestamp: new Date().toISOString()
        };
      }

      if (!feedbackText || feedbackText.startsWith("EROARE:")) {
        console.warn(`Eroare de la ${modelFolosit}:`, feedbackText);
        return {
            paragraf: feedbackText || `Nu s-a putut obține feedback de la ${modelFolosit}.`,
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "",
            model: modelFolosit + " (Eroare API)", timestamp: new Date().toISOString()
        };
      }

      console.log("Răspuns brut de la Gemini:\n---\n" + feedbackText + "\n---");

      const parsedFeedback = {
          paragraf: feedbackText.match(/^Paragraf:\s*([\s\S]*?)(?=\n(?:Întrebare:|Recomandare:|Distorsiuni:|Scheme:|Adult Sănătos:|$))/im)?.[1]?.trim() || "Nu s-a putut extrage 'Paragraf'.",
          intrebare: feedbackText.match(/^Întrebare:\s*([\s\S]*?)(?=\n(?:Recomandare:|Distorsiuni:|Scheme:|Adult Sănătos:|$))/im)?.[1]?.trim() || "Nu s-a putut extrage 'Întrebare'.",
          recomandare: feedbackText.match(/^Recomandare:\s*([\s\S]*?)(?=\n(?:Distorsiuni:|Scheme:|Adult Sănătos:|$))/im)?.[1]?.trim() || "Nu s-a putut extrage 'Recomandare'.",
          distorsiuni: feedbackText.match(/^Distorsiuni:\s*([\s\S]*?)(?=\n(?:Scheme:|Adult Sănătos:|$))/im)?.[1]?.trim() || "Nu s-au putut extrage 'Distorsiuni'.",
          scheme: feedbackText.match(/^Scheme:\s*([\s\S]*?)(?=\n(?:Adult Sănătos:|$))/im)?.[1]?.trim() || "Nu s-au putut extrage 'Scheme'.",
          adult_sanatos_eval: feedbackText.match(/^Adult Sănătos:\s*([\s\S]*?$)/im)?.[1]?.trim() || "Nu s-a putut extrage 'Adult Sănătos'.",
          model: modelFolosit,
          timestamp: new Date().toISOString()
      };
      
      // Verificare suplimentară dacă toate câmpurile parsate sunt mesaje de eroare de la parsare
        let allParsingFailed = true;
        for (const key in parsedFeedback) {
            if (key !== "model" && key !== "timestamp" && typeof parsedFeedback[key] === 'string' && !parsedFeedback[key].startsWith("Nu s-a putut")) {
                allParsingFailed = false;
                break;
            }
        }
        if (allParsingFailed && !feedbackText.startsWith("EROARE:")) {
             console.warn("Parsarea detaliată a eșuat pentru toate câmpurile. Este posibil ca formatul răspunsului de la AI să nu corespundă așteptărilor. Verifică promptul și regex-urile.");
             // Opcional: poți afișa tot textul într-un singur câmp dacă parsarea eșuează complet
             // parsedFeedback.paragraf = `Răspuns neparsat de la ${modelFolosit}:\n${feedbackText.replace(/\n\n/g, "\n").replace(/\n/g, "<br>")}`;
        }


      if (docId) {
          const docRef = doc(db, "raspunsuri", docId);
          try {
              await updateDoc(docRef, {
                  feedback_history: arrayUnion(parsedFeedback),
                  feedback_paragraf: parsedFeedback.paragraf,
                  feedback_intrebare: parsedFeedback.intrebare,
                  feedback_recomandare: parsedFeedback.recomandare,
                  feedback_distorsiuni: parsedFeedback.distorsiuni,
                  feedback_scheme: parsedFeedback.scheme,
                  feedback_adult_eval: parsedFeedback.adult_sanatos_eval,
                  feedback_model: parsedFeedback.model
              });
              console.log(`Feedback AI (${modelFolosit}) salvat pentru docId: ${docId}`);
          } catch (updateError) {
              console.error(`Eroare la actualizarea documentului ${docId} cu feedback AI:`, updateError);
          }
      }
      return parsedFeedback;
    }

    async function salveazaRaspunsSiGenereazaFeedback() { // Am redenumit adaugaInTabel
        const form = document.getElementById("exercitiuForm");
        if (!form.checkValidity()) { // Validare HTML5 de bază
            form.reportValidity();
            alert("Vă rugăm completați toate câmpurile marcate ca obligatorii din pasul curent.");
            return;
        }

        const formData = new FormData(form);
        const rowData = { date: new Date().toLocaleDateString("ro-RO") }; // Formatare data RO
        formData.forEach((value, key) => { rowData[key] = value; });

        const user = auth.currentUser;
        if (!user) {
            alert("Trebuie să fiți autentificat pentru a salva datele.");
            window.location.href = "login.html"; // Redirecționează dacă nu e autentificat
            return;
        }
        rowData.ownerUid = user.uid;

        try {
            const docRef = await addDoc(collection(db, "raspunsuri"), rowData);
            rowData.id = docRef.id;
            console.log(`Răspuns salvat cu ID: ${docRef.id}. Se generează feedback AI automat...`);

            const feedbackGenerat = await genereazaSiProceseazaFeedbackAI(rowData, docRef.id);
            
            const docSnapshot = await getDoc(docRef); // Recitim pentru a avea cel mai nou istoric
            if (docSnapshot.exists()) {
                adaugaCard({ id: docSnapshot.id, ...docSnapshot.data() });
            } else { // Puțin probabil, dar ca fallback
                rowData.feedback_history = feedbackGenerat ? [feedbackGenerat] : [];
                adaugaCard(rowData);
            }
            
            form.reset();
            currentStep = 1;
            document.querySelectorAll('.form-step').forEach(step => step.classList.remove('form-step-active'));
            document.getElementById('step-1').classList.add('form-step-active');
            updateProgressBar();

            const confirmationMessage = document.getElementById('confirmationMessage');
            if (feedbackGenerat && !feedbackGenerat.paragraf.startsWith("EROARE:") && !feedbackGenerat.paragraf.startsWith("Serviciul") && !feedbackGenerat.paragraf.startsWith("Configurare Gemini Eronată")) {
                confirmationMessage.textContent = 'Formularul a fost trimis și feedback-ul AI generat! Îl puteți vedea în cardul de mai jos.';
                confirmationMessage.style.backgroundColor = '#d4edda'; 
                confirmationMessage.style.color = '#155724';
            } else if (feedbackGenerat && feedbackGenerat.paragraf && feedbackGenerat.paragraf.includes("depășită")) { // Caută cuvântul cheie
                 confirmationMessage.textContent = 'Formularul a fost trimis. Feedback-ul AI nu a putut fi generat din cauza depășirii limitei de utilizare. Vă rugăm încercați mai târziu.';
                 confirmationMessage.style.backgroundColor = '#fff3cd';
                 confirmationMessage.style.color = '#664d03';
            } else {
                 confirmationMessage.textContent = `Formularul a fost trimis. Problemă la generarea feedback-ului AI: ${feedbackGenerat ? feedbackGenerat.paragraf : 'Eroare necunoscută'}`;
                 confirmationMessage.style.backgroundColor = '#f8d7da';
                 confirmationMessage.style.color = '#58151c';
            }
            confirmationMessage.style.display = 'block';
            setTimeout(() => {
                confirmationMessage.style.display = 'none';
                confirmationMessage.style.backgroundColor = '#d4edda'; // Reset default
                confirmationMessage.style.color = '#155724';
            }, 9000);

        } catch (error) {
            console.error("Eroare la salvarea în Firestore sau generarea feedback-ului AI:", error);
            alert("A apărut o eroare la salvare. Vă rugăm încercați din nou.");
        }
    }

    function afiseazaIstoricFeedback(containerElement, feedbackHistory) {
        containerElement.innerHTML = ''; 

        if (feedbackHistory && Array.isArray(feedbackHistory) && feedbackHistory.length > 0) {
            const historyTitle = document.createElement("h4");
            historyTitle.style.color = "#4A90E2";
            historyTitle.style.marginTop = "20px";
            historyTitle.style.marginBottom = "10px";
            historyTitle.textContent = "🗂️ Istoric Feedback AI:";
            containerElement.appendChild(historyTitle);

            feedbackHistory.slice().reverse().forEach(entry => { 
                const itemContainer = document.createElement("div");
                itemContainer.className = "feedback-entry-card"; // Adaugă o clasă pentru stilizare centralizată

                const timestampAndModel = document.createElement("p");
                timestampAndModel.className = "feedback-timestamp";
                timestampAndModel.innerHTML = `<strong>${new Date(entry.timestamp).toLocaleString("ro-RO")}</strong> (Model: ${entry.model || 'N/A'})`;
                itemContainer.appendChild(timestampAndModel);

                const sections = [
                    { title: "✍️ Paragraf Empatic", key: "paragraf", isList: false },
                    { title: "❓ Întrebare de Reflecție", key: "intrebare", isList: false },
                    { title: "🛠️ Recomandare Terapeutică", key: "recomandare", isList: false },
                    { title: "🔍 Distorsiuni Cognitive", key: "distorsiuni", isList: true },
                    { title: "🧠 Scheme Cognitive", key: "scheme", isList: true },
                    { title: "🧍‍♂️ Evaluare Adult Sănătos", key: "adult_sanatos_eval", isList: false }
                ];

                sections.forEach(sectionConfig => {
                    const sectionDiv = document.createElement("div");
                    sectionDiv.className = "feedback-section";

                    const sectionTitleElement = document.createElement("h5");
                    sectionTitleElement.textContent = sectionConfig.title + ":";
                    sectionDiv.appendChild(sectionTitleElement);

                    let contentText = entry[sectionConfig.key];

                    if (contentText && typeof contentText === 'string') {
                        const titleWithoutEmoji = sectionConfig.title.replace(/(\p{Emoji_Presentation}|\p{Extended_Pictographic})\s*/gu, '').trim();
                        const redundantTitlePatternGeneric = new RegExp(`^${titleWithoutEmoji.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}:?\\s*`, "im");
                        contentText = contentText.replace(redundantTitlePatternGeneric, "").trim();
                        const redundantKeyPattern = new RegExp(`^${sectionConfig.key.replace("_", " ")}:?\\s*`, "im");
                        contentText = contentText.replace(redundantKeyPattern, "").trim();

                        if (sectionConfig.isList && contentText.includes('*')) {
                            const listElement = document.createElement("ul");
                            const items = contentText.split(/\s*\*\s*/)
                                              .map(item => item.trim())
                                              .filter(item => item.length > 0);
                            items.forEach(itemText => {
                                const listItem = document.createElement("li");
                                listItem.innerHTML = itemText.replace(/\n/g, '<br>');
                                listElement.appendChild(listItem);
                            });
                            sectionDiv.appendChild(listElement);
                        } else {
                            const paragraphElement = document.createElement("p");
                            paragraphElement.innerHTML = contentText.replace(/\n/g, '<br>') || '<i>Indisponibil</i>';
                            sectionDiv.appendChild(paragraphElement);
                        }
                    } else {
                        const unavailableText = document.createElement("p");
                        unavailableText.style.fontStyle = "italic";
                        unavailableText.textContent = "Indisponibil";
                        sectionDiv.appendChild(unavailableText);
                    }
                    itemContainer.appendChild(sectionDiv);
                });
                containerElement.appendChild(itemContainer);
            });
        } else {
            // Nu afișăm "Niciun feedback" dacă containerul e gol inițial,
            // doar dacă feedbackHistory e un array gol explicit după o încercare.
            // Dacă `feedbackHistory` e undefined, nu afișăm nimic aici (card nou, fără istoric încă).
        }
    }

   function adaugaCard(rowData) {
      const cardViewContainer = document.getElementById("cardViewContainer");
      // Verifică dacă un card cu acest ID există deja pentru a evita duplicate la reîncărcări
      const existingCard = cardViewContainer.querySelector(`.response-card[data-id="${rowData.id}"]`);
      if (existingCard) {
           // Opțional: actualizează istoricul cardului existent dacă e cazul,
           // deși acest flux ar trebui să creeze cardul o singură dată la început
           // sau la adăugarea unui nou răspuns.
           console.log("Cardul există deja, se actualizează istoricul AI:", rowData.id);
           const historyContainer = existingCard.querySelector('.ai-feedback-history-container');
           if (historyContainer) {
                afiseazaIstoricFeedback(historyContainer, rowData.feedback_history);
           }
           return; // Nu recreăm tot cardul
      }


      const card = document.createElement("div");
      card.className = "response-card";
      card.setAttribute("data-id", rowData.id);
      card.innerHTML = `
        <div class="card-header"> Data: ${rowData.date || ''} - Situația: ${rowData.situatie.substring(0,50) || ''}...</div>
        <div class="card-content">
          <h4>Explorarea situației și a nevoilor</h4>
          <p><strong>Care este situația?</strong> ${rowData.situatie || ''}</p>
          <p><strong>Ce îmi trece prin minte?</strong> ${rowData.ganduri || ''}</p>
          <p><strong>Cum mă face acel gând să mă simt?</strong> ${rowData.emotii || ''}</p>
          <p><strong>Ce mod este activ?</strong> ${rowData.mod_activ || ''}</p>
          <p><strong>Ce comportament simți că adopți?</strong> ${rowData.comportament || ''}</p>
          <p><strong>Care sunt nevoile tale mai profunde?</strong> ${rowData.nevoi_profunde || ''}</p>
          <p><strong>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</strong> ${rowData.ajutor_comportament || ''}</p>
          <p><strong>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</strong> ${rowData.adult_sanatos || ''}</p>

          <h4>Analiza gândurilor și a percepțiilor</h4>
          <p><strong>Ce mă face să cred că gândul automat este adevărat?</strong> ${rowData.dovezi_adevar || ''}</p>
          <p><strong>Ce mă face să cred că nu este adevărat?</strong> ${rowData.dovezi_fals || ''}</p>
          <p><strong>Există o explicație alternativă?</strong> ${rowData.explicatie_alternativa || ''}</p>
          <p><strong>Care este cel mai rău lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_negativ || ''}</p>
          <p><strong>Care este cel mai bun lucru care s-ar putea întâmpla?</strong> ${rowData.scenariu_optimist || ''}</p>
          <p><strong>Care este cel mai realist rezultat?</strong> ${rowData.rezultat_realist || ''}</p>
          <p><strong>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</strong> ${rowData.schimbare_gandire || ''}</p>
          <p><strong>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</strong> ${rowData.sfat_prieten || ''}</p>

          <h4>Întrebări pentru claritate și reflecție suplimentară</h4>
          <p><strong>Văd doar partea rea a lucrurilor?</strong> ${rowData.partea_rea || ''}</p>
          <p><strong>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</strong> ${rowData.responsabilitate || ''}</p>
          <p><strong>Mă condamn în baza unui singur eveniment?</strong> ${rowData.condamnare || ''}</p>
          <p><strong>Privesc situația în termeni extremi?</strong> ${rowData.termeni_extremi || ''}</p>
          <p><strong>Exagerez situația?</strong> ${rowData.exagerare || ''}</p>
          <p><strong>Există și alți factori responsabili?</strong> ${rowData.factori_responsabili || ''}</p>
          <p><strong>Am sărit direct la concluzii?</strong> ${rowData.concluzii || ''}</p>
          <p><strong>Îmi pun întrebări fără răspuns?</strong> ${rowData.intrebari_fara_raspuns || ''}</p>
          <p><strong>Mă concentrez doar asupra slăbiciunilor mele?</strong> ${rowData.slabiciuni || ''}</p>
          <p><strong>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</strong> ${rowData.cum_ar_trebui || ''}</p>
          <p><strong>Mă aștept să fiu perfect?</strong> ${rowData.perfectiune || ''}</p>
          
          <div class="card-actions">
              <button class="generate-ai-feedback-button">Regenerează Feedback AI</button>
              <button class="delete-button">Șterge Înregistrarea</button>
          </div>
          <div class="ai-feedback-history-container">
              <!-- Istoricul AI va fi adăugat aici -->
          </div>
        </div>
      `;

      card.querySelector('.card-header').addEventListener('click', () => {
        card.classList.toggle('open');
      });

      card.querySelector('.delete-button').addEventListener('click', (event) => {
        event.stopPropagation();
        stergeCard(rowData.id, card);
      });

      const generateManualButton = card.querySelector('.generate-ai-feedback-button');
      if (generateManualButton) {
            generateManualButton.addEventListener('click', async (event) => {
                event.stopPropagation(); // Nu propaga click-ul la header-ul cardului
                const button = event.target;
                const originalButtonText = button.textContent;
                button.textContent = 'Se generează...';
                button.disabled = true;
                
                try {
                    console.log(`Regenerare manuală feedback AI pentru card: ${rowData.id}`);
                    const docSnapshot = await getDoc(doc(db, "raspunsuri", rowData.id)); // Ia ultimele date
                    let currentCardData;
                    if (docSnapshot.exists()) {
                        currentCardData = { id: docSnapshot.id, ...docSnapshot.data() };
                    } else {
                        console.warn("Documentul nu a fost găsit. Folosim datele locale pentru regenerare.");
                        currentCardData = rowData;
                    }

                    await genereazaSiProceseazaFeedbackAI(currentCardData, currentCardData.id);
                    
                    const updatedDoc = await getDoc(doc(db, "raspunsuri", currentCardData.id));
                    if (updatedDoc.exists()) {
                       afiseazaIstoricFeedback(card.querySelector('.ai-feedback-history-container'), updatedDoc.data().feedback_history);
                    }
                } catch (error) {
                    console.error("Eroare la regenerarea manuală a feedback-ului AI:", error);
                    alert("A apărut o eroare la regenerarea feedback-ului AI.");
                } finally {
                    button.textContent = originalButtonText;
                    button.disabled = false;
                }
            });
        }
    
      afiseazaIstoricFeedback(card.querySelector('.ai-feedback-history-container'), rowData.feedback_history);

      if (cardViewContainer.firstChild) {
          cardViewContainer.insertBefore(card, cardViewContainer.firstChild);
      } else {
          cardViewContainer.appendChild(card);
      }
    }

    async function loadTableData(userId, collabIdForLoad = null, ownerIdForCollab = null) {
        if (collabIdForLoad && dataAlreadyLoaded) { // Specific pentru colaborator
            console.log("Datele colaboratorului deja încărcate în carduri.");
            return;
        }
        
        const cardViewContainer = document.getElementById("cardViewContainer");
        if (cardViewContainer.innerHTML !== '' && !collabIdForLoad && dataAlreadyLoaded) {
            // Pentru utilizatorul normal, dacă datele sunt deja încărcate, nu le reîncărca la fiecare schimbare de stare auth minoră
            console.log("Cardurile pentru utilizator sunt deja încărcate.");
            // return; // Comentează return dacă vrei să reîmprospătezi la fiecare onAuthStateChanged (poate fi util)
        }
        
        console.log("Încărcare date din Firestore pentru carduri...");
        cardViewContainer.innerHTML = ''; // Golește înainte de a repopula

        try {
            let q;
            if (collabIdForLoad && ownerIdForCollab) {
                console.log(`Încărcare date pentru colaborare, owner ID: ${ownerIdForCollab}`);
                q = query(collection(db, "raspunsuri"), where("ownerUid", "==", ownerIdForCollab));
            } else if (userId) {
                console.log(`Încărcare date pentru utilizatorul: ${userId}`);
                q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId));
            } else {
                console.warn("Niciun userId sau ownerIdForCollab furnizat pentru loadTableData. Nu se încarcă date.");
                return; // Nu încărca nimic dacă nu e clar pentru cine
            }

            const querySnapshot = await getDocs(q);
            const documents = [];
            querySnapshot.forEach((doc) => {
                documents.push({ id: doc.id, ...doc.data() });
            });

            documents.sort((a, b) => {
                const dateA = a.date ? new Date(a.date.split('.').reverse().join('-') + "T" + (a.timestamp ? new Date(a.timestamp).toTimeString().split(" ")[0] : "00:00:00")) : new Date(0);
                const dateB = b.date ? new Date(b.date.split('.').reverse().join('-') + "T" + (b.timestamp ? new Date(b.timestamp).toTimeString().split(" ")[0] : "00:00:00")) : new Date(0);
                // Pentru o sortare mai robustă dacă ai timestamp complet în Firestore (de la Date())
                // const timeA = a.firestoreTimestamp ? a.firestoreTimestamp.toDate() : dateA;
                // const timeB = b.firestoreTimestamp ? b.firestoreTimestamp.toDate() : dateB;
                // return timeB - timeA;
                return dateB - dateA; // Sortare descrescătoare
            });
            
            documents.forEach(docData => {
                adaugaCard(docData);
            });

            if (collabIdForLoad) dataAlreadyLoaded = true; // Specific pentru scenariul de colaborare
            // Pentru utilizatorul normal, dataAlreadyLoaded este gestionat în onAuthStateChanged

        } catch (error) {
            console.error("Eroare la încărcarea cardurilor din Firestore:", error.message, error.stack);
        }
    }

    async function populateTableData(userId) { // Doar pentru utilizatorul curent, nu pentru colaborare
        // Consideră eliminarea completă a acestei funcții dacă tabelul nu mai este necesar
        // sau integreaz-o mai bine cu `loadTableData` pentru a evita dubla interogare.
        // Pentru moment, o las cu filtrare, dar este redundantă dacă cardurile sunt afișate.
        const urlParams = new URLSearchParams(window.location.search);
        const collabIdFromUrl = urlParams.get('collabId');
        if (collabIdFromUrl) { // Tabelul nu e pentru colaboratori
            console.log("Tabelul nu se populează pentru vizualizarea de colaborator.");
            return;
        }

        const tableBody = document.getElementById("tableBody");
        if (!tableBody || !userId) return;
        tableBody.innerHTML = "";

        try {
            const q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId));
            const querySnapshot = await getDocs(q);
            const docsData = [];
            querySnapshot.forEach(doc => docsData.push({id: doc.id, ...doc.data()}));

            // ... restul logicii de sortare și populare tabel (dacă este încă necesară) ...
            console.log("Tabelul a fost populat (dacă este vizibil).");

        } catch (error) {
            console.error("Eroare la încărcarea în tabel din Firestore:", error.message);
        }
    }

    window.toggleDetails = function(id) { /* ... cod neschimbat ... */ }

    async function stergeCard(id, cardElement) {
        if (confirm("Sunteți sigur că doriți să ștergeți această înregistrare și tot feedback-ul asociat? Această acțiune este ireversibilă.")) {
            try {
                await deleteDoc(doc(db, "raspunsuri", id));
                cardElement.remove();
                console.log(`Înregistrarea ${id} a fost ștearsă.`);
                // Reîmprospătează și tabelul dacă este vizibil și relevant
                // populateTableData(auth.currentUser?.uid); // Depinde dacă vrei asta
            } catch (error) {
                console.error("Eroare la ștergerea din Firestore:", error);
                alert("Eroare la ștergerea înregistrării.");
            }
        }
    }

    async function generateCollaborationLink() { /* ... cod neschimbat (asigură-te că salvezi `ownerUid`) ... */ }

    window.addEventListener('DOMContentLoaded', async () => {
        console.log("DOMContentLoaded - verifică vizualizarea colaboratorului.");
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (collabId) {
            console.log("Mod colaborare detectat. ID Colaborare:", collabId);
            dataAlreadyLoaded = false; // Resetează pentru colaborator
            // Ascunde elementele care nu sunt pentru colaborator
            ['exercitiuForm', 'generateLinkButton', '.form-container', '.table-container'].forEach(sel => {
                const el = document.querySelector(sel) || document.getElementById(sel);
                if (el) el.style.display = 'none';
            });
            
            const pin = prompt("Introduceți codul PIN pentru a accesa această fișă de colaborare:");
            if (!pin) {
                alert("Cod PIN necesar pentru vizualizare.");
                window.location.href = "login.html"; // Sau o pagină de eroare
                return;
            }

            try {
                const collabDocRef = doc(db, "collaborations", collabId);
                const collabSnapshot = await getDoc(collabDocRef);

                if (collabSnapshot.exists()) {
                    const collabData = collabSnapshot.data();
                    if (collabData.pin === pin) {
                        console.log("PIN corect. Se încarcă datele pentru owner:", collabData.owner);
                        // Afișează un mesaj sau un header specific pentru colaborator
                        const collabHeader = document.createElement('h2');
                        collabHeader.textContent = "Vizualizare Fișă Colaborare";
                        collabHeader.style.textAlign = "center";
                        collabHeader.style.marginTop = "20px";
                        document.body.insertBefore(collabHeader, document.querySelector('.card-view')); // Adaugă înainte de carduri

                        loadTableData(null, collabId, collabData.owner); // Încarcă cardurile pentru owner-ul specificat
                    } else {
                        alert("PIN incorect.");
                        window.location.href = "login.html";
                    }
                } else {
                    alert("Link de colaborare invalid sau expirat.");
                    window.location.href = "login.html";
                }
            } catch (error) {
                console.error("Eroare la accesarea datelor de colaborare:", error);
                alert("A apărut o eroare la accesarea fișei. Vă rugăm încercați mai târziu.");
                window.location.href = "login.html";
            }
        }
        // Logica pentru utilizatorul normal (non-collab) este gestionată în onAuthStateChanged
    });
    </script>
    <style>
        /* ... STILURILE TALE EXISTENTE (INCLUSIV .feedback-section, etc.) ... */
        body {
            font-family: 'Roboto', 'Montserrat', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(to right, #ece9e6, #ffffff);
            color: #333;
            box-sizing: border-box;
        }
        .form-container {
            max-width: 900px;
            margin: 20px auto;
            background: #fff;
            padding: 30px;
            box-shadow: 0 16px 24px rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            border: 3px solid #87CEFA;
            transition: transform 0.3s ease;
        }
        .form-container:hover {
            transform: scale(1.01);
        }
        .progress-bar {
            width: 100%;
            background-color: #f3f3f3;
            border-radius: 25px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .progress {
            height: 20px;
            width: 0;
            background-color: #87CEFA;
            transition: width 0.4s ease;
        }
        .question-card {
            margin-bottom: 20px;
            padding: 20px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }
        .question-card:hover {
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }
        .question-card h3 {
            font-weight: 700;
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .question-card p {
            font-weight: 300;
            font-size: 0.95em;
            margin-bottom: 15px;
            color: #555;
            line-height: 1.6;
        }
        textarea {
            width: calc(100% - 22px);
            padding: 10px;
            font-size: 16px;
            border-radius: 8px;
            border: 1px solid #ccc;
            resize: vertical;
            min-height: 60px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: border-color 0.3s;
        }
        textarea:focus {
            border-color: #87CEFA;
            box-shadow: 0 2px 8px rgba(135, 206, 250, 0.5);
            outline: none;
        }
        input[type="submit"], button {
            margin-top: 20px;
            padding: 12px 25px;
            font-size: 18px;
            font-weight: 500;
            background: linear-gradient(to right, #87CEFA, #6bb9e7);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }
        input[type="submit"]:hover, button:hover {
            background: linear-gradient(to right, #6bb9e7, #4A90E2);
            transform: translateY(-2px);
        }
        .form-step { display: none; }
        .form-step-active { display: block; animation: fadeIn 0.7s ease-in-out; }
        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(10px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .step-navigation { text-align: center; margin-top: 20px; }
        .step-navigation button { margin: 0 10px; }
        .table-container { /* ... stiluri tabel dacă e folosit ... */ }
        .card-view { display: flex; flex-direction: column; gap: 20px; max-width: 900px; margin: 30px auto; }
        .response-card { background: #f9f9ff; padding: 0; border-radius: 15px; box-shadow: 0 8px 16px rgba(0,0,0,0.12); transition: box-shadow 0.3s ease; position: relative; overflow: hidden; }
        .response-card:hover { box-shadow: 0 10px 20px rgba(0,0,0,0.18); }
        .response-card .card-header { font-weight: 700; font-size: 1.1em; cursor: pointer; background: #87CEFA; padding: 12px 20px; color: #fff; text-align: left; position: relative; display: flex; justify-content: space-between; align-items: center; }
        .response-card .card-header::after { content: '▼'; font-size: 0.8em; transition: transform 0.3s ease; }
        .response-card.open .card-header::after { transform: rotate(180deg); }
        .response-card .card-content { max-height: 0; margin-top: 0; padding: 0 20px; background: #fff; line-height: 1.6; overflow: auto; transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, padding-bottom 0.4s ease-out; }
        .response-card.open .card-content { max-height: 1500px; /* Mărit pentru mai mult conținut */ padding-top: 15px; padding-bottom: 15px; }
        .response-card .card-content p { margin-bottom: 12px; border-left: 3px solid #87CEFA; padding-left: 10px; }
        .response-card .card-content p strong { color: #333; }
        .response-card h4 { text-align: left; color: #4A90E2; font-weight: bold; margin-top: 20px; margin-bottom: 10px; font-size: 1.05em; }
        .response-card h4:first-child { margin-top: 0; }
        .card-actions { text-align: center; margin-top: 20px; padding-bottom: 10px; border-top: 1px solid #eee; padding-top: 15px; }
        .card-actions button { padding: 8px 15px; font-size: 0.9em; margin: 5px; }
        .generate-ai-feedback-button { background: #5cb85c; }
        .generate-ai-feedback-button:hover { background: #4cae4c; }
        .delete-button { background-color: #f44336 !important; }
        .delete-button:hover { background-color: #d32f2f !important; }
        #confirmationMessage { display: none; text-align: center; padding: 15px; background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; border-radius: 5px; margin-top: 20px; animation: fadeIn 0.5s; }
        .collaboration-section { text-align: center; margin-top: 30px; padding-bottom: 20px; }
        .collaboration-section button { background-color: #f0ad4e; }
        .collaboration-section button:hover { background-color: #ec971f; }

        /* Stiluri pentru cardul de feedback istoric */
        .feedback-entry-card {
            background: #eef6ff;
            padding: 15px;
            border-left: 4px solid #4A90E2;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.95em;
            line-height: 1.6;
        }
        .feedback-timestamp {
            color: #555;
            font-size: 0.9em;
            margin-bottom: 12px;
        }
        .feedback-section {
            margin-bottom: 12px;
        }
        .feedback-section h5 {
            font-size: 1em;
            font-weight: bold;
            color: #2c5282; /* O nuanță de albastru-gri închis */
            margin-top: 0;
            margin-bottom: 6px;
        }
        .feedback-section p,
        .feedback-section ul {
            margin-top: 0;
            margin-bottom: 8px;
            color: #1e293b;
        }
        .feedback-section ul {
            padding-left: 25px;
            list-style-position: outside;
            list-style-type: disc;
        }
        .feedback-section li {
            margin-bottom: 4px;
        }

        /* Responsive adjustments */
        /* ... Include aici TOATE regulile tale @media ... */
        @media (max-width: 768px) { /* Exemplu, copiază toate stilurile tale responsive */
            body { padding: 10px; }
            .form-container, .card-view { padding: 15px; margin-left: 10px; margin-right: 10px; max-width: calc(100% - 20px);  }
            /* ... continuă cu restul ... */
        }

    </style>
</head>
<body>

    <div class="form-container">
        <h2>Fișă Monitorizare</h2>
        <p>Completează fiecare întrebare pentru a înțelege mai bine situațiile tale...</p>
    
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    
        <form id="exercitiuForm" novalidate> <!-- Adăugat novalidate pentru a controla validarea prin JS dacă e cazul -->
            <!-- Pasul 1: Explorarea situației și a nevoilor -->
            <div class="question-card form-step form-step-active" id="step-1">
                <h3>Care este situația?</h3>
                <p>Descrie contextul care a declanșat emoțiile sau comportamentul...</p>
                <textarea name="situatie" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-2">
                <h3>Ce îmi trece prin minte?</h3>
                <p>Identifică gândurile automate...</p>
                <textarea name="ganduri" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-3">
                <h3>Cum mă face acel gând să mă simt?</h3>
                <p>Notează emoțiile pe care le simți...</p>
                <textarea name="emotii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-4">
                <h3>Ce mod este activ?</h3>
                <p>Identifică modul în care te afli...</p>
                <textarea name="mod_activ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-5">
                <h3>Ce comportament simți că adopți?</h3>
                <p>Descrie comportamentul pe care îl manifești...</p>
                <textarea name="comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-6">
                <h3>Care sunt nevoile tale mai profunde?</h3>
                <p>Ce nevoi stau la baza acestor emoții și comportamente? ...</p>
                <textarea name="nevoi_profunde" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-7">
                <h3>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</h3>
                <p>Reflectează dacă felul în care reacționezi te ajută...</p>
                <textarea name="ajutor_comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-8">
                <h3>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</h3>
                <p>Gândește-te la cum ar reacționa partea ta Adultă Sănătoasă...</p>
                <textarea name="adult_sanatos" rows="3" required></textarea>
            </div>

            <!-- Pasul 2: Analiza gândurilor și a percepțiilor -->
             <div class="question-card form-step" id="step-9">
                <h3>Ce mă face să cred că gândul automat este adevărat?</h3>
                <p>Explorează motivele pentru care crezi că acest gând este adevărat...</p>
                <textarea name="dovezi_adevar" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-10">
                <h3>Ce mă face să cred că nu este adevărat?</h3>
                <p>Acum, să ne uităm la dovezile împotriva gândului tău...</p>
                <textarea name="dovezi_fals" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-11">
                <h3>Există o explicație alternativă?</h3>
                <p>Uneori, există mai multe explicații pentru ceea ce se întâmplă...</p>
                <textarea name="explicatie_alternativa" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-12">
                <h3>Care este cel mai rău lucru care s-ar putea întâmpla?</h3>
                <p>Ce este cel mai rău care ar putea avea loc în această situație?...</p>
                <textarea name="scenariu_negativ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-13">
                <h3>Care este cel mai bun lucru care s-ar putea întâmpla?</h3>
                <p>Pe de altă parte, care ar fi cel mai pozitiv scenariu?...</p>
                <textarea name="scenariu_optimist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-14">
                <h3>Care este cel mai realist rezultat?</h3>
                <p>După ce am explorat extremele, ce crezi că este cel mai probabil să se întâmple?...</p>
                <textarea name="rezultat_realist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-15">
                <h3>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</h3>
                <p>Întreabă-te cum ar fi dacă ai aborda situația cu un alt tip de gândire...</p>
                <textarea name="schimbare_gandire" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-16">
                <h3>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</h3>
                <p>Gândește-te la cum ai reacționa dacă un prieten drag ar avea aceleași gânduri...</p>
                <textarea name="sfat_prieten" rows="3" required></textarea>
            </div>

            <!-- Pasul 3: Întrebări pentru claritate și reflecție suplimentară -->
            <div class="question-card form-step" id="step-17">
                <h3>Văd doar partea rea a lucrurilor?</h3>
                <p>Este posibil să fii prins într-un tipar negativ de gândire...</p>
                <textarea name="partea_rea" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-18">
                <h3>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</h3>
                <p>Reflectează dacă îți asumi responsabilitatea pentru situații...</p>
                <textarea name="responsabilitate" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-19">
                <h3>Mă condamn în baza unui singur eveniment?</h3>
                <p>Îți evaluezi valoarea personală bazându-te pe un singur eveniment negativ?...</p>
                <textarea name="condamnare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-20">
                <h3>Privesc situația în termeni extremi?</h3>
                <p>Verifică dacă vezi situația doar în alb sau negru...</p>
                <textarea name="termeni_extremi" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-21">
                <h3>Exagerez situația?</h3>
                <p>Îți amplifici reacțiile față de o situație?...</p>
                <textarea name="exagerare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-22">
                <h3>Există și alți factori responsabili?</h3>
                <p>Există alți factori care contribuie la această situație...</p>
                <textarea name="factori_responsabili" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-23">
                <h3>Am sărit direct la concluzii?</h3>
                <p>Te-ai grăbit să ajungi la o concluzie fără suficiente dovezi?...</p>
                <textarea name="concluzii" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-24">
                <h3>Îmi pun întrebări fără răspuns?</h3>
                <p>Te frământă întrebări care nu au un răspuns clar sau realist?...</p>
                <textarea name="intrebari_fara_raspuns" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-25">
                <h3>Mă concentrez doar asupra slăbiciunilor mele?</h3>
                <p>Ai tendința să te focalizezi doar pe slăbiciuni...</p>
                <textarea name="slabiciuni" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-26">
                <h3>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</h3>
                <p>Ai tendința să te gândești mereu la cum ar trebui să fie lucrurile...</p>
                <textarea name="cum_ar_trebui" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-27">
                <h3>Mă aștept să fiu perfect?</h3>
                <p>Îți setezi standarde foarte înalte, imposibil de atins?...</p>
                <textarea name="perfectiune" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-28">
                <h3>Completare finalizată!</h3>
                <p>Felicitări pentru parcurgerea acestui exercițiu de auto-reflecție! Nu uita să salvezi datele apăsând butonul de mai jos.</p>
                <p>Feedback-ul AI te poate ajuta să obții noi perspective. Dacă întâmpini probleme cu generarea feedback-ului (ex: erori de limită), poți încerca din nou mai târziu.</p>
            </div>

            <div class="step-navigation">
                <button type="button" id="prevButton">Înapoi</button>
                <button type="button" id="nextButton">Înainte</button>
            </div>
            <button type="button" id="addButton">Salvează și Generează Feedback AI</button>
        </form>

        <div id="confirmationMessage">
            <!-- Mesajul va fi setat de JavaScript -->
        </div>

        <div class="collaboration-section">
            <button type="button" id="generateLinkButton">Generează Link de Colaborare</button>
        </div>
    </div>
    
    <h3 style="text-align: center; margin-top: 40px; margin-bottom: 10px; color: #333; font-weight: 500;">Răspunsurile Tale și Istoricul Feedback-ului AI:</h3>
    
    <div class="card-view" id="cardViewContainer">
        <!-- Cardurile cu răspunsuri și feedback AI vor fi adăugate aici de JavaScript -->
    </div>
    
    <div class="table-container" style="display: none;"> <!-- Ascuns implicit, îl poți activa dacă e necesar -->
        <table>
            <thead>
                <tr>
                    <th>Data</th><th>Situația</th><th>Gânduri</th><th>Emoții</th><th>Mod activ</th>
                    <th>Comportament</th><th>Nevoile</th><th>Ajutor comport.</th><th>Adult Sănătos</th><th>Detalii</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <br/>
    
</body>
</html>