<!DOCTYPE html>
<html>
<head>
    <title>Fi»ôƒÉ Monitorizare - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, deleteField, doc, getDoc, updateDoc, arrayUnion, query, where, setDoc, orderBy, limit } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    // Configurarea Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // √énlocuie»ôte cu cheia ta realƒÉ dacƒÉ e diferitƒÉ
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    // Ini»õializare Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // --- Configurare Gemini API ---
    // !!! √éNLOCUIE»òTE CU CHEIA TA API GEMINI VALIDƒÇ »òI ACTIVƒÇ !!!
    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- CHEIA TA API GEMINI
    const GEMINI_MODEL_NAME_FEEDBACK = "gemini-2.5-flash-preview-04-17";
    const GEMINI_MODEL_NAME_CHAT = "gemini-2.5-flash-preview-04-17";
    let genAI, geminiModelFeedback, geminiModelChat;

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_FEEDBACK });
            geminiModelChat = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_CHAT });
            console.log("SDK Gemini ini»õializat. Model Feedback:", GEMINI_MODEL_NAME_FEEDBACK, "Model Chat:", GEMINI_MODEL_NAME_CHAT);
        } catch (e) {
            console.error("Eroare criticƒÉ la ini»õializarea SDK Gemini:", e);
            alert("Eroare la ini»õializarea serviciului AI. Verifica»õi cheia API Gemini »ôi configura»õia din Google Cloud. Func»õionalitatea AI va fi limitatƒÉ.");
            geminiModelFeedback = null; geminiModelChat = null;
        }
    } else  {
         // Added check for the specific placeholder you were using
        const isSpecificPlaceholder = GEMINI_API_KEY === "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; 
        console.warn(`Cheia API Gemini ${isSpecificPlaceholder ? "pare a fi un placeholder" : "nu este configuratƒÉ/validƒÉ"} ('${GEMINI_API_KEY || "goalƒÉ"}'). Te rog √Ænlocuie»ôte-o cu cheia ta API validƒÉ pentru a activa func»õionalitatea AI.`);
        // alert(`Func»õionalitatea AI este dezactivatƒÉ. Te rog configureazƒÉ o cheie API Gemini validƒÉ √Æn codul sursƒÉ (variabila GEMINI_API_KEY). ${isSpecificPlaceholder ? "Ai folosit un placeholder." : ""}`);
        geminiModelFeedback = null; geminiModelChat = null;
    }


    let currentStep = 1;
    let totalSteps = 0;
    let dataAlreadyLoaded = false;

    // --- Variabile Globale pentru Chat ---
    let chatSession = null;
    const CHAT_HISTORY_DOC_ID_PREFIX = "chatHistory_";
    let isChatInitialized = false;


    window.onload = function () {
        totalSteps = document.querySelectorAll('.form-step').length;
        updateProgressBar();
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (!collabId) {
            onAuthStateChanged(auth, async (user) => {
                const toggleChatBtn = document.getElementById("toggleChatButton");
                const chatContainer = document.getElementById("chatContainer");

                if (user) {
                    console.log("Utilizator autentificat:", user.uid);
                    if (!dataAlreadyLoaded) {
                        populateTableData(user.uid);
                        loadTableData(user.uid);
                        dataAlreadyLoaded = true;
                    }
                    if(toggleChatBtn) toggleChatBtn.style.display = 'flex';
                } else {
                    console.log("Utilizator neautentificat, redirec»õionare...");
                    if(toggleChatBtn) toggleChatBtn.style.display = 'none';
                    if(chatContainer) chatContainer.style.display = 'none';
                    isChatInitialized = false;
                    chatSession = null;
                    window.location.href = "login.html";
                }
            });
        } else {
            const toggleChatBtn = document.getElementById("toggleChatButton");
            if(toggleChatBtn) toggleChatBtn.style.display = 'none';
            const chatContainer = document.getElementById("chatContainer");
            if(chatContainer) chatContainer.style.display = 'none';
        }

        document.getElementById("nextButton")?.addEventListener("click", nextStep);
        document.getElementById("prevButton")?.addEventListener("click", previousStep);
        document.getElementById("addButton")?.addEventListener("click", salveazaRaspunsSiGenereazaFeedback);
        document.getElementById("generateLinkButton")?.addEventListener("click", generateCollaborationLink);
        
        document.getElementById("toggleChatButton")?.addEventListener("click", handleToggleChat);
        document.getElementById("sendChatMessageButton")?.addEventListener("click", handleSendChatMessage);
        document.getElementById("chatInput")?.addEventListener("keypress", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); 
                handleSendChatMessage();
            }
        });
    };

    function nextStep() {
        if (currentStep < totalSteps) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep++;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function previousStep() {
        if (currentStep > 1) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep--;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function updateProgressBar() {
        const progress = document.getElementById('progress');
        if(progress && totalSteps > 0) {
            const progressPercentage = (currentStep / totalSteps) * 100;
            progress.style.width = progressPercentage + '%';
        }
    }
    
    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) {
            console.error("Modelul Gemini specificat este invalid sau neini»õializat.", modelToUse === geminiModelChat ? "(Model Chat)" : "(Model Feedback)");
            return "EROARE: Model AI neini»õializat. VerificƒÉ cheia API.";
        }
        try {
            const requestPayload = {
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.7, ...generationConfigOptions } // TemperaturƒÉ ajustatƒÉ pu»õin
            };
            const result = await modelToUse.generateContent(requestPayload); 
            const response = result.response;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Gemini a oprit generarea prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    // Decizi dacƒÉ vrei sƒÉ incluzi un mesaj de eroare scurt sau doar rƒÉspunsul par»õial.
                    // Momentan returnƒÉm rƒÉspunsul par»õial + o notificare scurtƒÉ
                    let partialResponse = response.candidates[0].content.parts[0].text;
                    // AdƒÉugƒÉm un marker subtil
                    if (partialResponse.length > 0) {
                         partialResponse += `\n\n(... generare opritƒÉ - ${response.candidates[0].finishReason})`;
                    } else {
                         partialResponse = `EROARE Gemini: Generare opritƒÉ (Motiv: ${response.candidates[0].finishReason}). Filtre de siguran»õƒÉ posibile active.`;
                    }
                    return partialResponse;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                console.error("Prompt blocat de Gemini:", response.promptFeedback.blockReasonDetail || response.promptFeedback.blockReason);
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Revizuie»ôte con»õinutul trimis.`;
            }
             else {
                console.error("RƒÉspuns Gemini nea»ôteptat sau gol:", JSON.stringify(response, null, 2));
                return "EROARE Gemini: RƒÉspuns invalid sau gol de la API.";
            }
        } catch (error) {
            console.error("Eroare detaliatƒÉ la callGeminiAPI:", error, error.stack);
            let errorMessage = `EROARE Gemini: ${error.message || "Eroare API necunoscutƒÉ"}`;
            if (error.toString().toLowerCase().includes("api key not valid") || 
                (error.message && error.message.toLowerCase().includes("permission denied")) ||
                (error.message && error.message.toLowerCase().includes("api_key_invalid")) ||
                (error.status && error.status === 403)) {
                 errorMessage = "EROARE: Cheia API Gemini nu este validƒÉ sau nu are permisiuni. VerificƒÉ restric»õiile din Google Cloud Console (HTTP Referrers, API Restrictions pentru Generative Language API) »ôi cheia din cod. AsigurƒÉ-te cƒÉ domeniul " + window.location.hostname + " este permis.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429) || (error.toString().toLowerCase().includes("resource has been exhausted")) )) {
                errorMessage = "EROARE: Limita de utilizare (posibil gratuitƒÉ) a API-ului Gemini (RPM/TPM sau alta) a fost depƒÉ»ôitƒÉ. √éncearcƒÉ mai t√¢rziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety_settings"))) {
                errorMessage = "EROARE Gemini: Generarea a fost opritƒÉ (posibil din motive de siguran»õƒÉ, con»õinut inadecvat, sau alte restric»õii ale modelului). √éncerca»õi sƒÉ reformula»õi.";
            }  else if (error.toString().toLowerCase().includes("404") && error.toString().toLowerCase().includes("model not found")) {
                 errorMessage = `EROARE Gemini: Modelul specificat nu a fost gƒÉsit sau nu este suportat. VerificƒÉ numele modelului √Æn cod.`;
            }
            return errorMessage;
         }
    }

    async function genereazaFeedbackCuGeminiDinFrontend(promptText) { 
        if (!geminiModelFeedback) {
            console.error("Modelul Gemini pentru feedback (geminiModelFeedback) nu este ini»õializat. VerificƒÉ cheia API.");
            return "EROARE: Configurare Gemini incorectƒÉ pentru feedback. VerificƒÉ dacƒÉ ai introdus corect cheia API √Æn cod.";
        }
        try {
            console.log("Trimitere prompt cƒÉtre Gemini (feedback fi»ôƒÉ, primele 100 caractere):", promptText.substring(0, 100) + "...");
            return await callGeminiAPI(promptText, geminiModelFeedback); 
        } catch (error) { 
            console.error("Eroare specificƒÉ √Æn genereazaFeedbackCuGeminiDinFrontend:", error);
            return `EROARE internƒÉ la pregƒÉtirea cererii cƒÉtre Gemini (feedback): ${error.message}`;
        }
    }

    async function genereazaSiProceseazaFeedbackAI(rowData, docId) {
      const prompt = `
AnalizeazƒÉ √Æn profunzime aceastƒÉ fi»ôƒÉ completƒÉ de auto-reflec»õie. Utilizatorul a parcurs un exerci»õiu detaliat pentru a-»ôi √Æn»õelege o situa»õie specificƒÉ. OferƒÉ feedback psihologic structurat, empatic »ôi ac»õionabil. RespectƒÉ cu stricte»õe formatul »ôi ordinea sec»õiunilor de mai jos, folosind exact prefixele indicate.

**Datele Complete din Fi»ôa de Reflec»õie a Utilizatorului:**

**Sec»õiunea 1: Explorarea Situa»õiei »ôi a Nevoilor**
*   Care este situa»õia?: ${rowData.situatie || 'N/A'}
*   Ce √Æmi trece prin minte (g√¢nduri automate)?: ${rowData.ganduri || 'N/A'}
*   Cum mƒÉ face acel g√¢nd sƒÉ mƒÉ simt (emo»õii)?: ${rowData.emotii || 'N/A'}
*   Ce mod este activ?: ${rowData.mod_activ || 'N/A'}
*   Ce comportament sim»õi cƒÉ adop»õi?: ${rowData.comportament || 'N/A'}
*   Care sunt nevoile tale mai profunde?: ${rowData.nevoi_profunde || 'N/A'}
*   MƒÉ ajutƒÉ comportamentul meu sƒÉ √Ændeplinesc aceste nevoi?: ${rowData.ajutor_comportament || 'N/A'}
*   Cum ar g√¢ndi »ôi cum s-ar comporta Adultul SƒÉnƒÉtos (perspectiva utilizatorului)?: ${rowData.adult_sanatos || 'N/A'}

**Sec»õiunea 2: Analiza G√¢ndurilor »ôi a Percep»õiilor**
*   Ce mƒÉ face sƒÉ cred cƒÉ g√¢ndul automat este adevƒÉrat?: ${rowData.dovezi_adevar || 'N/A'}
*   Ce mƒÉ face sƒÉ cred cƒÉ nu este adevƒÉrat?: ${rowData.dovezi_fals || 'N/A'}
*   ExistƒÉ o explica»õie alternativƒÉ?: ${rowData.explicatie_alternativa || 'N/A'}
*   Care este cel mai rƒÉu lucru care s-ar putea √Ænt√¢mpla?: ${rowData.scenariu_negativ || 'N/A'}
*   Care este cel mai bun lucru care s-ar putea √Ænt√¢mpla?: ${rowData.scenariu_optimist || 'N/A'}
*   Care este cel mai realist rezultat?: ${rowData.rezultat_realist || 'N/A'}
*   Ce s-ar √Ænt√¢mpla dacƒÉ mi-a»ô schimba modul de g√¢ndire?: ${rowData.schimbare_gandire || 'N/A'}
*   Ce i-a»ô spune unui prieten dacƒÉ ar fi √Æn aceea»ôi situa»õie?: ${rowData.sfat_prieten || 'N/A'}

**Sec»õiunea 3: √éntrebƒÉri pentru Claritate »ôi Reflec»õie SuplimentarƒÉ**
*   VƒÉd doar partea rea a lucrurilor?: ${rowData.partea_rea || 'N/A'}
*   √émi asum responsabilitatea pentru lucruri care nu au stat √Æn puterea mea?: ${rowData.responsabilitate || 'N/A'}
*   MƒÉ condamn √Æn baza unui singur eveniment?: ${rowData.condamnare || 'N/A'}
*   Privesc situa»õia √Æn termeni extremi (alb/negru)?: ${rowData.termeni_extremi || 'N/A'}
*   Exagerez situa»õia?: ${rowData.exagerare || 'N/A'}
*   ExistƒÉ »ôi al»õi factori responsabili?: ${rowData.factori_responsabili || 'N/A'}
*   Am sƒÉrit direct la concluzii?: ${rowData.concluzii || 'N/A'}
*   √émi pun √ÆntrebƒÉri fƒÉrƒÉ rƒÉspuns?: ${rowData.intrebari_fara_raspuns || 'N/A'}
*   MƒÉ concentrez doar asupra slƒÉbiciunilor mele?: ${rowData.slabiciuni || 'N/A'}
*   MƒÉ zbat prea mult g√¢ndind la cum ar trebui sƒÉ fie lucrurile?: ${rowData.cum_ar_trebui || 'N/A'}
*   MƒÉ a»ôtept sƒÉ fiu perfect?: ${rowData.perfectiune || 'N/A'}

**CERIN»öE PENTRU FEEDBACK-UL AI (folose»ôte prefixele EXACT a»ôa cum sunt scrise):**

Feedback General:
EmpatieIni»õialƒÉ: (1-2 propozi»õii empatice scurte, recunosc√¢nd efortul utilizatorului.)

AnalizƒÉ DetaliatƒÉ:
PuncteForteObservate: (IdentificƒÉ 1-2 aspecte pozitive sau de auto-con»ôtientizare.)
TiparePrincipale: (Descrie succint 1-3 tipare de g√¢ndire/emo»õionale/comportamentale centrale.)

LegƒÉtura G√¢nd-Emo»õie-Comportament-Nevoie:
ConexiuniCheie: (SintetizeazƒÉ legƒÉtura S-G-E-C-N bazatƒÉ pe '${rowData.ganduri}', '${rowData.emotii}', '${rowData.comportament}', '${rowData.nevoi_profunde}'.)

Analiza G√¢ndurilor Automate »ôi Distorsiuni:
DistorsiuniIdentificate: (IdentificƒÉ 2-4 distorsiuni principale. Pentru fiecare: Numele, Explica»õia, Exemplu din rƒÉspunsuri, √éntrebare de contestare. ListeazƒÉ fiecare ca sub-punct precedat de '* '.)

Scheme »ôi Moduri Cognitive:
SchemeActivate: (IdentificƒÉ 1-3 scheme. Pentru fiecare: Numele, Cum se manifestƒÉ. ListeazƒÉ fiecare ca sub-punct precedat de '* '.)
ModuriImplicate: (SugereazƒÉ ce moduri Schema Therapy ar putea fi implicate.)

Rolul Adultului SƒÉnƒÉtos:
PerspectivaAdultSƒÉnƒÉtos: (ComenteazƒÉ rƒÉspunsul utilizatorului '${rowData.adult_sanatos}'. OferƒÉ descriere detaliatƒÉ: interpretare situa»õie, g√¢nduri alternative, gestionare emo»õii, comportamente adaptative, contracarare scheme.)

Sugestii »ôi Reflec»õii Finale:
√éntrebareFinalƒÉReflec»õie: (O √Æntrebare generalƒÉ puternicƒÉ pentru √ÆnvƒÉ»õare »ôi aplicare viitoare.)
SugestieMicPas: (O sugestie concretƒÉ pentru un mic pas urmƒÉtor.)
√éncurajareFinalƒÉ: (1-2 propozi»õii de √Æncurajare.)

RƒÉspunde doar cu textul cerut conform structurii, fƒÉrƒÉ introduceri, concluzii sau formatƒÉri suplimentare √Æn afara celor specificate).`;

      let feedbackText = null;
      let modelFolosit = "N/A";

      if (geminiModelFeedback) {
        console.log("Solicitare feedback de la Gemini pentru fi»ôƒÉ...");
        modelFolosit = `Gemini (${GEMINI_MODEL_NAME_FEEDBACK})`;
        feedbackText = await genereazaFeedbackCuGeminiDinFrontend(prompt);
      } else {
        console.warn("Gemini (geminiModelFeedback) nu este configurat. Nu se poate genera feedback AI pentru fi»ôƒÉ.");
        return {
            paragraf: "Serviciul de feedback AI (Gemini) nu este configurat corect pentru fi»ôe. VerificƒÉ cheia API »ôi numele modelului.",
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "", 
            model: "Configurare Gemini EronatƒÉ", timestamp: new Date().toISOString(), error: true
        };
      }

      if (!feedbackText || (typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:"))) {
        console.warn(`Eroare de la ${modelFolosit} la generarea feedback-ului fi»ôei:`, feedbackText);
        return { 
            paragraf: feedbackText || `Nu s-a putut ob»õine feedback de la ${modelFolosit}.`,
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "",
            model: modelFolosit + " (Eroare API)", timestamp: new Date().toISOString(), error: true
        };
      }

      console.log("RƒÉspuns brut de la Gemini (feedback fi»ôƒÉ):\n---\n" + feedbackText + "\n---");

      const feedbackStructure = {
            empatie_initiala: /^EmpatieIni»õialƒÉ:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            puncte_forte: /^PuncteForteObservate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            tipare_principale: /^TiparePrincipale:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            conexiuni_cheie: /^ConexiuniCheie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            distorsiuni_identificate: /^DistorsiuniIdentificate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            scheme_activate: /^SchemeActivate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            moduri_implicate: /^ModuriImplicate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            perspectiva_adult_sanatos: /^PerspectivaAdultSƒÉnƒÉtos:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            intrebare_finala_reflectie: /^√éntrebareFinalƒÉReflec»õie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            sugestie_mic_pas: /^SugestieMicPas:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            incurajare_finala: /^√éncurajareFinalƒÉ:\s*([\s\S]*?$)/im,
        };
        
        const parsedFeedback = { model: modelFolosit, timestamp: new Date().toISOString(), error: false, error_parsing: false };
        let allParsingOk = true;

        for (const key in feedbackStructure) {
            const match = feedbackText.match(feedbackStructure[key]);
            if (match && match[1] && match[1].trim() !== "") {
                 parsedFeedback[key] = match[1].trim();
            } else {
                console.warn(`Feedback fi»ôƒÉ: Nu s-a putut extrage sau este gol con»õinutul pentru: '${key}'`);
                parsedFeedback[key] = `(Sec»õiune neextrasƒÉ sau goalƒÉ din rƒÉspunsul AI: ${key})`;
                allParsingOk = false;
            }
        }
        
        if (!allParsingOk) {
            console.warn("Feedback fi»ôƒÉ: Cel pu»õin o sec»õiune nu a putut fi parsatƒÉ corect din rƒÉspunsul AI. VerificƒÉ formatul rƒÉspunsului AI »ôi regex-urile.");
            parsedFeedback.error_parsing = true;
        }

        if (docId) {
            const docRef = doc(db, "raspunsuri", docId);
            try {
                const updatePayload = { feedback_history: arrayUnion(parsedFeedback) };
                Object.keys(parsedFeedback).forEach(key => {
                    updatePayload[`feedback_${key}`] = parsedFeedback[key];
                });
                await updateDoc(docRef, updatePayload);
                console.log(`Feedback AI (nou, ${modelFolosit}) salvat pentru fi»ôa ${docId}`);
            } catch (updateError) {
                console.error(`Eroare update Firestore feedback nou pentru fi»ôa ${docId}:`, updateError);
            }
        }
        return parsedFeedback;
    }

    // --- CHAT FUNCTIONALITY ---

    // Func»õie pentru a converti Markdown limitat »ôi elemente speciale √Æn HTML
    // Poate fi √ÆmbunƒÉtƒÉ»õitƒÉ cu o bibliotecƒÉ de parsare Markdown mai robustƒÉ
    function formatAiMessageContent(mdText) {
        let html = mdText;

        // Regex √ÆmbunƒÉtƒÉ»õit pentru a identifica un titlu ce √Æncepe cu emoji
        // Presupune cƒÉ titlul e pe o linie separatƒÉ, √Æncepe cu emoji(uri),
        // poate include text, »ôi se terminƒÉ op»õional cu emoji(uri).
        // CapturƒÉ grup 1: √Æntreg titlul inclusiv emoji, grup 2: doar textul din mijloc
        const titleRegex = /^(\p{Emoji_Presentation}|\p{Extended_Pictographic}|[\s\S])*?(\p{Emoji_Presentation}|\p{Extended_Pictographic})(.+?)(\p{Emoji_Presentation}|\p{Extended_Pictographic}).*?$/gmu;
         html = html.replace(titleRegex, '<span class="message-title">$1$3$4</span>\n\n'); // √énfƒÉ»ôoarƒÉ »ôi adaugƒÉ douƒÉ newline la sf√¢r»ôitul spanului

        // Gestionare "CapsulƒÉ TeoreticƒÉ" (parsarea strictƒÉ a ASCII ar fi mai robustƒÉ,
        // dar √ÆncercƒÉm sƒÉ identificƒÉm block-uri similare, chiar dacƒÉ nu sunt perfect ASCII)
        // Aceasta presupune ca un bloc √Æncepe »ôi se terminƒÉ cu ceva care seamƒÉnƒÉ cu linii orizontale »ôi col»õuri
        // O abordare alternativƒÉ mult mai robustƒÉ este ca AI-ul sƒÉ foloseascƒÉ tag-uri custom: [THEORY_BOX_START]...[THEORY_BOX_END]
        
        // TentativƒÉ de a prinde un bloc care ar putea √Æncepe cu ‚îå, ‚îè, urmat de linii - »ôi se terminƒÉ la fel
        const theoryBoxRegexComplex = /(?:^[‚îå‚îè].*?[‚îê‚îì]\n)((?:.|\n)*?)(?:^[‚îî‚îó].*?[‚îò‚îõ]$)/gm; // CautƒÉ bloc √Æntre linii de chenar (simple/duble)

        html = html.replace(theoryBoxRegexComplex, (match, innerText) => {
            // √énlƒÉturƒÉ liniile de chenar
            let cleanedInner = innerText.replace(/^[‚îå‚îè‚îî‚îó].*?[‚îê‚îì‚îò‚îõ]$/gm, '').trim();
            
            let boxTitle = 'CapsulƒÉ'; 
            let boxConcept = '';
            
            // CautƒÉ Titlul »ôi Conceptul √Æn primele linii ale textului interior curƒÉ»õat
            const lines = cleanedInner.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            if (lines.length > 0) {
                let firstLine = lines[0];
                 // √éncercƒÉm sƒÉ gƒÉsim un posibil titlu + emoji + posibil *text*: la √Ænceput
                 const titleConceptMatch = firstLine.match(/^(\p{Emoji_Presentation}|\p{Extended_Pictographic}|[\s\S])*?(\p{Emoji_Presentation}|\p{Extended_Pictographic})(.+?)(?:\:\s*|\s*\*\s*)(.+)/u);

                if (titleConceptMatch && titleConceptMatch[3] && titleConceptMatch[4]) {
                     boxTitle = titleConceptMatch[3].trim();
                     boxConcept = `<em>${titleConceptMatch[4].trim()}</em>`;
                     lines.shift(); // Scoate prima linie, e deja procesatƒÉ
                } else if (firstLine.includes(':') || firstLine.includes('*')) { // Orice altƒÉ linie care con»õine : sau * ar putea fi titlu/concept
                     const parts = firstLine.split(/[:*]/);
                     if (parts.length > 1) {
                        boxTitle = parts[0].trim();
                        boxConcept = `<em>${parts.slice(1).join(':').trim()}</em>`;
                         lines.shift();
                     } else { boxConcept = `<em>${firstLine}</em>`; lines.shift(); } // Doar o singura linie lunga, o facem concept
                }
            }

             // Reconstruie»ôte corpul textului din liniile rƒÉmase
            const bodyText = lines.join('\n');


            // HTML generat pentru capsulƒÉ
            return `
<div class="theory-box">
    <span class="theory-box-title">${boxTitle}</span>
    ${boxConcept ? `<span class="theory-box-concept">${boxConcept}</span>` : ''}
    <p>${bodyText.replace(/\n/g, '<br>')}</p>
</div>\n\n`; // AdaugƒÉ newline la sf√¢r»ôit pentru a separa de restul con»õinutului
        });
        // ConsiderƒÉ o alternativƒÉ dacƒÉ parsarea e prea grea
        // const simpleAsciiRegex = /^[‚îå‚îè].*?\n([\s\S]*?)\n^[‚îî‚îó].*?$/gm; // IdentificƒÉ block-uri cu bordurƒÉ simplƒÉ la √Ænceput/sf√¢r»ôit de linie
        // html = html.replace(simpleAsciiRegex, '<div class="ascii-art-block">$1</div>\n\n');

        // EliminƒÉ newlines multiple lƒÉs√¢nd maximum 2 pentru a le trata ca separatori de paragraf mai t√¢rziu
        html = html.replace(/\n\s*\n/gm, '\n\n').trim();


        // Acum gestioneazƒÉ restul formatƒÉrii (paragrafe, bold/italic, newline-uri simple)
        const blocks = html.split('\n\n'); // √émparte √Æn blocuri pe baza a 2+ newline-uri
        let finalHtml = '';

        blocks.forEach(block => {
            if (block.trim() === '') return;

            // DacƒÉ block-ul este deja un element HTML complex generat mai sus, adaugƒÉ-l a»ôa cum e.
            if (block.startsWith('<div class="theory-box">') || block.startsWith('<span class="message-title">')) {
                 finalHtml += block; // Acestea au deja structure corectƒÉ
            } else {
                 // Este un paragraf "normal", parseazƒÉ bold/italic »ôi \n
                 let paragraphContent = block;
                
                 // Re-aplicƒÉ bold/italic DACA ele sunt singurele formatƒÉri Markdown rƒÉmase √Æn acest block
                 paragraphContent = paragraphContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/__(.*?)__/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
                 paragraphContent = paragraphContent.replace(/_(.*?)_/g, '<em>$1</em>');

                 // Newline-uri simple devin <br> √Æn interiorul unui paragraf
                 paragraphContent = paragraphContent.replace(/\n/g, '<br>');
                
                 // √énfƒÉ»ôoarƒÉ blocul √Æntr-un paragraf (excluz√¢nd dacƒÉ block-ul e deja un titlu/capsulƒÉ completƒÉ)
                 if (!block.startsWith('<span class="message-title">') && !block.startsWith('<div class="theory-box">')) {
                      finalHtml += `<p>${paragraphContent}</p>`;
                 } else {
                     // DacƒÉ block-ul a fost deja marcat ca titlu sau capsulƒÉ completƒÉ,
                     // el con»õine deja HTML-ul »ôi √Æl adƒÉugƒÉm direct (am putea reevalua structura if/else)
                      finalHtml += block; 
                 }
            }
        });

        return finalHtml;
    }


    function displayChatMessage(messageText, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) {
            console.error("Elementul chatMessages nu a fost gƒÉsit.");
            return;
        }
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");

        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        const classesToAdd = messageClass.split(' ');
        messageElement.classList.add(...classesToAdd);

        const contentContainer = document.createElement('div');
        contentContainer.classList.add('chat-message-content');

        if (role === "AI") {
            // Formatarea complexƒÉ a mesajelor AI folosind noua func»õie
            contentContainer.innerHTML = formatAiMessageContent(messageText);
        } else { 
            // Mesaje user sau AI-error - text simplu, fƒÉrƒÉ interpretare HTML
            contentContainer.textContent = messageText;
            contentContainer.style.whiteSpace = "pre-wrap"; // PƒÉstreazƒÉ newlines pentru user/error
        }

        messageElement.appendChild(contentContainer);
        messagesDiv.appendChild(messageElement);
        // Scroll automat la ultimul mesaj
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
         // Sincronize scroll √Æntr-un requestAnimationFrame pentru a se executa dupƒÉ actualizarea DOM-ului
        // requestAnimationFrame(() => {
        //     messagesDiv.scrollTop = messagesDiv.scrollHeight;
        // });
    }


    async function loadChatHistory(userId) {
        if (!userId) return [];
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists() && docSnap.data().messages && Array.isArray(docSnap.data().messages)) {
                const messages = docSnap.data().messages;
                messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                 console.log(`√éncƒÉrcat ${messages.length} mesaje chat din istoric.`);
                return messages;
            }
            console.log("Niciun istoric chat gƒÉsit √Æn Firestore.");
            return []; 
        } catch (error) {
            console.error("Eroare la √ÆncƒÉrcarea istoricului de chat din Firestore:", error);
            // Afi»ôeazƒÉ un mesaj de eroare √Æn chat la ini»õializare dacƒÉ √ÆncƒÉrcarea e»ôueazƒÉ
            displayChatMessage("Eroare la √ÆncƒÉrcarea istoricului conversa»õiei.", "AI-error");
            return []; 
        }
    }
    
    async function saveChatMessage(userId, messageObject) {
        if (!userId || !messageObject || typeof messageObject.content !== 'string' || messageObject.content.trim() === "") {
            console.warn("TentativƒÉ de salvare a unui mesaj invalid sau gol:", messageObject);
            return;
        }
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists()) {
                 // Previne adƒÉugarea de duplicate dacƒÉ aceea»ôi intrare din DB e re√ÆncƒÉrcatƒÉ rapid
                const messages = docSnap.data().messages;
                 // SimplƒÉ verificare de unicitate pe baza con»õinutului »ôi a timestamp-ului recent
                 const isDuplicate = messages.some(msg => 
                    msg.content === messageObject.content && 
                    Math.abs(new Date(msg.timestamp).getTime() - new Date(messageObject.timestamp).getTime()) < 1000 // Acela»ôi mesaj √Æn 1 sec
                 );

                if (!isDuplicate) {
                     await updateDoc(historyDocRef, {
                        messages: arrayUnion(messageObject) 
                    });
                     console.log("Mesaj de chat salvat pentru utilizatorul:", userId);
                } else {
                    console.log("Mesaj duplicat, nu a fost salvat:", messageObject);
                }

            } else {
                await setDoc(historyDocRef, {
                    messages: [messageObject]
                });
                 console.log("Document nou istoric chat creat »ôi mesaj salvat pentru utilizatorul:", userId);
            }
           
        } catch (error) {
            console.error("Eroare la salvarea mesajului de chat √Æn Firestore:", error);
             // Nu afi»ôƒÉm aici mesaj √Æn UI, ar crea o buclƒÉ.
        }
    }
    
    async function initializeAndStartChatSession(userId) {
        const chatStatus = document.getElementById("chatStatus");
        const sendButton = document.getElementById("sendChatMessageButton");
        const messagesDiv = document.getElementById("chatMessages");

        if (sendButton) sendButton.disabled = true;
        if (chatStatus) chatStatus.textContent = "Ini»õializare chat AI...";
        if (messagesDiv) messagesDiv.innerHTML = ''; 

        if (!geminiModelChat) {
            if (chatStatus) chatStatus.textContent = "EROARE: Modelul AI Chat nu este disponibil.";
            console.error("initializeAndStartChatSession: geminiModelChat nu este ini»õializat. VerificƒÉ cheia API GEMINI.");
            displayChatMessage("Serviciul de chat AI nu este disponibil momentan. Te rog verificƒÉ configura»õia (Cheie API Gemini neconfiguratƒÉ/invalidƒÉ).", "AI-error");
             if (sendButton) sendButton.disabled = true; // PƒÉstreazƒÉ butonul dezactivat
            return null;
        }
        
        isChatInitialized = false; 

        let initialContextSummary = "REZUMAT DIN FI»òELE ANTERIOARE (ULTIMELE 3):\n";
        try {
            if (userId) {
                 // SorteazƒÉ dupƒÉ data, »ôi secundar dupƒÉ id pentru o ordine deterministicƒÉ √Æn caz de date identice
                const q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId), orderBy("date", "desc"), orderBy("__name__"), limit(3)); 
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    querySnapshot.forEach(doc => {
                        const data = doc.data();
                        const entryDate = data.date || (data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleDateString("ro-RO") : 'N/A');
                        initialContextSummary += ` - Fi»ôƒÉ (${entryDate}): Situa»õia - ${(data.situatie || "").substring(0, 70)}...; G√¢nduri - ${(data.ganduri || "").substring(0, 70)}...; Emo»õii - ${data.emotii || 'N/A'}.\n`;
                    });
                     if(querySnapshot.docs.length < 3) initialContextSummary += `\n(Au fost gƒÉsite doar ${querySnapshot.docs.length} fi»ôe recente.)\n`;

                } else { initialContextSummary += "Nicio fi»ôƒÉ de monitorizare recentƒÉ gƒÉsitƒÉ.\n"; }
            }
        } catch(e) { 
            console.error("Eroare la √ÆncƒÉrcarea contextului din fi»ôe pentru chat (VerificƒÉ Indexul Firestore!):", e); 
            initialContextSummary += `\nEroare la √ÆncƒÉrcarea contextului din fi»ôe (${e.message}).`;
        }

        const systemInstructionText =
`# ROL PRINCIPAL »òI PERSONA:
Tu e»ôti PsihoGPT (alias Dr. Janet/Damian ‚Äì o voce calmƒÉ, empaticƒÉ »ôi √Æn»õeleaptƒÉ, combin√¢nd cuno»ôtin»õele teoretice cu ghidajul practic). E»ôti un asistent AI avansat pentru auto-reflec»õie »ôi explorare psihologicƒÉ ghidatƒÉ, specializat √Æn Terapie Cognitiv-ComportamentalƒÉ (TCC), Terapia Schemelor, Terapia prin Acceptare »ôi Angajament (ACT), principii ale Terapiei Dialectic-Comportamentale (DBT) »ôi ale terapiei afirmative gay. Te adresezi utilizatorului cu "tu". Scopul tƒÉu principal este sƒÉ sprijini utilizatorul √Æn dezvoltarea stimei de sine »ôi a auto-compasiunii, vindecarea copilului interior »ôi gestionarea rela»õiilor √Æntr-un mod echilibrat, pentru o via»õƒÉ √ÆmplinitƒÉ »ôi independentƒÉ emo»õional.

# MISIUNE »òI ABORDARE TERAPEUTICƒÇ:
Misiunea ta este sƒÉ aju»õi utilizatorul sƒÉ exploreze g√¢nduri, emo»õii, comportamente »ôi nevoi profunde. Vei ghida utilizatorul sƒÉ:
1.  Identifice »ôi sƒÉ √Æn»õeleagƒÉ **Schemele Maladaptative Timpurii** (explicƒÉ pe scurt conceptul la nevoie, folosind metafore sau analogii simple). Fii atent la posibile manifestƒÉri ale schemelor de Abandon/Instabilitate, Defectivitate/Ru»ôine, Deprivare Emo»õionalƒÉ, E»ôec (po»õi face o men»õiune scurtƒÉ la √Ænceput cƒÉ acestea sunt arii comune de explorare, dar nu te baza pe scoruri specifice din prompt).
2.  Exploreze **Stilul de Ata»ôament** (ex. anxios-evitant) »ôi impactul sƒÉu asupra rela»õiilor.
3.  Abordeze teme specifice precum **homofobia internalizatƒÉ** sau **stresul minoritar**, utiliz√¢nd principii ale **terapiei afirmative gay**. Aici, adoptƒÉ un ton validant »ôi knowledgeable. Po»õi parafraza idei cheie din lucrƒÉri relevante *fƒÉrƒÉ a cita explicit* (ex: "Unele perspective din terapia afirmativƒÉ aratƒÉ cƒÉ...").
4.  Examineze »ôi sƒÉ √ÆmbunƒÉtƒÉ»õeascƒÉ **stima de sine** »ôi **autocompasiunea**. Introdu no»õiunea de autocompasiune (bazat pe Kristin Neff) ca pe o tehnicƒÉ, nu ca pe o trƒÉsƒÉturƒÉ.
5.  Dezvolte **limite sƒÉnƒÉtoase** »ôi asertivitate.
6.  Identifice »ôi sƒÉ transforme posibile **tipare de mentalitate de victimƒÉ**, cultiv√¢nd **agen»õia personalƒÉ**.
7.  Lucreze cu **experien»õele trecute** »ôi **copilul interior** (vezi lucrƒÉrile despre lucrul cu copilul interior).
8.  SƒÉ formuleze **obiective SMART** mici »ôi realizabile. GhideazƒÉ procesul, nu le oferi gata fƒÉcute.

# PRINCIPII DE INTERAC»öIUNE »òI COMUNICARE:
  **Empatie »ôi CƒÉldurƒÉ ConstantƒÉ:** PrioritizeazƒÉ conexiunea emo»õionalƒÉ »ôi validarea. Tonul este suportiv, cald, non-judicativ »ôi uman (chiar dacƒÉ e»ôti AI).
  **Dialog Reflexiv:** Pune √ÆntrebƒÉri deschise, de sondare »ôi clarificare care √Æl ajutƒÉ pe utilizator sƒÉ exploreze propria experien»õƒÉ. EvitƒÉ interogatoriul rapid. OferƒÉ spa»õiu pentru pauze »ôi reflec»õie.
  **Validare Activa:** ValideazƒÉ *ceea ce* simte »ôi g√¢nde»ôte utilizatorul, nu *dacƒÉ* e corect. "√én»õeleg cƒÉ √Æn acel moment te-ai sim»õit X, pare dificil.", "E firesc sƒÉ ai acest g√¢nd dat fiind Y".
  **Psihoeduca»õie AplicatƒÉ:** Introduce concepte psihologice *doar c√¢nd sunt relevante pentru ceea ce a relatat utilizatorul*. ExplicƒÉ-le concis, folosind metafore, analogii »ôi exemple practice. Pune-i √ÆntrebƒÉri de conectare: "Cum »õi se pare acest concept legat de ce trƒÉie»ôti tu acum?", "Recuno»ôti acest tipar √Æn experien»õa ta?". *Folose»ôte text italic* pentru conceptele cheie.
  **Non-Directivitate cu Direc»õie:** Nu da sfaturi despre *ce sƒÉ facƒÉ*. GhideazƒÉ-l *cum sƒÉ g√¢ndeascƒÉ despre*, *cum sƒÉ exploreze emo»õia*, *cum sƒÉ vadƒÉ alte perspective*. SprijinƒÉ-l sƒÉ-»ôi gƒÉseascƒÉ *propriile* rƒÉspunsuri »ôi solu»õii (Agen»õia PersonalƒÉ). NU face diagnostice sau evaluƒÉri clinice. NU interveni √Æn situa»õii de crizƒÉ acutƒÉ ‚Äì reaminte»ôte-i discret cƒÉ pentru acestea e nevoie de suport uman profesionist.
  **Utilizarea Contextului Din Fi»ôe:** IntegreazƒÉ subtil √Æn conversa»õie elemente REZUMATULUI FI»òELOR (situatie, g√¢nduri, emo»õii) ca o bazƒÉ de √Æn»õelegere, NU ca un script rigid. Men»õioneazƒÉ cu discre»õie (ex: "MƒÉ g√¢ndeam acum, √Æn legƒÉturƒÉ cu ce povesteai despre [tema X], la situa»õia din fi»ôa [data fisei] c√¢nd ai sim»õit [emo»õie Y]. Vezi vreo legƒÉturƒÉ?").
  **Format Structurat:** GenereazƒÉ text √Æn blocuri (paragrafe) folosind *cel pu»õin douƒÉ newline-uri* √Æntre ele pentru o bunƒÉ lizibilitate. UtilizeazƒÉ **bold** ("**text**"" sau "__text__") »ôi *italic* ("*text*"" sau "_text_") pentru a eviden»õia idei cheie »ôi concepte (Markdown simplu).
  **Formatarea Titlului Mesajului:** √éncepe fiecare mesaj AI cu un titlu scurt, de reflexie sau care define»ôte tema, formatat ca un titlu mic (po»õi folosi emoji la √Ænceput/sf√¢r»ôit ca indicator vizual, de ex: '‚ú® ExplorƒÉm Rezisten»õa la Schimbare ‚ú®'). **Folose»ôte emoji consistent la √Ænceputul »ôi sf√¢r»ôitul liniei titlu pentru a ajuta la parsare!** (Sugestie: Pune √Æntotdeauna 1-2 emoji la √Ænceput »ôi 1-2 la sf√¢r»ôitul liniei titlu, pe linia goalƒÉ dupƒÉ)
  **Formatarea Capsulei Teoretice (DacƒÉ este necesarƒÉ »ôi relevantƒÉ):** PrezintƒÉ informa»õii concise, punctuale, sub forma unui block. **Folose»ôte o marcƒÉ de √Ænceput »ôi de sf√¢r»ôit clarƒÉ** pe care o pot identifica u»ôor (ex: '[CONCEPT_BOX]\nTITLE: Titlu Concept\nTEXT: Explica»õia...[\n/CONCEPT_BOX]' sau pur »ôi simplu un format structurat pe linii cu o bordurƒÉ ASCII *consistentƒÉ*. *Pentru simplitate √Æn JS, cea mai bunƒÉ metodƒÉ ar fi: AI-ul sƒÉ deseneze o bordurƒÉ ASCII clarƒÉ »ôi CONSISTENTƒÇ √Æn jurul blocului.* Regex-ul din JS va √Æncerca sƒÉ o prindƒÉ. Format: Linii goale √Ænainte, apoi linia de top, apoi con»õinut (cu \n √Æntre ele), apoi linia de jos, linii goale dupƒÉ.
  **Check-in Meta-Terapeutic (la final de EtapƒÉ sau Cerere):** √éntreabƒÉ despre *proces* - ritm, format, utilitate. Include un mesaj de final la sf√¢r»ôitul »ôedin»õei c√¢nd utilizatorul semnaleazƒÉ asta.
  **Ritmul Conversa»õiei:** OferƒÉ *un singur mesaj complex* ca rƒÉspuns, chiar dacƒÉ include mai multe paragrafe sau o capsulƒÉ. A»ôteaptƒÉ input-ul utilizatorului √Ænainte de a trimite urmƒÉtorul rƒÉspuns terapeutic complet. EvitƒÉ ping-pong-ul rapid cu o propozi»õie.
 **Elemente Estetice:** Folose»ôte *emoji expresive* (din lista (‚ú®, üåü, üí°, üîç, üõ°Ô∏è, üå±, üè≥Ô∏è‚Äçüåà, üôè)) »ôi *text italic* »ôi **bold** conform instruc»õiunilor.

# CUNO»òTIN»öE SPECIFICE »òI RESURSE (Referen»õial Interioar):
Nu reproduce lista explicit. Acestea sunt informa»õiile din "biblioteca ta mentalƒÉ". Folose»ôte conceptele, nu cita literal (dec√¢t la cerere expresƒÉ, dacƒÉ e cazul).
*   **Scheme (YSQ, SMI):** ManifestƒÉri: teama de abandon/respingere, sentiment de inferioritate, gol interior, sacrificiu, nevoia de aprobare.
*   **Atasament (ECR-R):** Impact √Æn rela»õii: anxietate, evitare.
*   **Terapie AfirmativƒÉ:** Stres minoritar, internalizare stigmat, importan»õa auto-acceptƒÉrii, sprijin comunitar.
*   **Autori Cheie:** IntegreazƒÉ principiile (ACT, DBT, Schema Therapy) inspirate de ace»ôti autori √Æn rƒÉspunsuri.

# PRIORITATE:
Alian»õa terapeuticƒÉ (siguran»õƒÉ, validare, empatie) > Explorare ghidatƒÉ > Informa»õie psihoeduca»õionalƒÉ > Structura etapei > Formatare esteticƒÉ.


Context din ultimele fi»ôe completate de utilizator (folose»ôte-l cu discre»õie »ôi inteligen»õƒÉ):
${initialContextSummary}---`;

        const aiGreeting = "Salut! Sunt PsihoGPT, asistentul tƒÉu AI pentru reflec»õie. Cum te sim»õi astƒÉzi »ôi despre ce ai vrea sƒÉ vorbim sau sƒÉ reflectƒÉm √ÆmpreunƒÉ?";

        let historyForGeminiInitialization = [];
        // AdaugƒÉ instruc»õiunea de sistem »ôi salutul √Æn istoricul trimis cƒÉtre API
        // Trimitem sistemul ca 'user' conform API guidance pt roluri √Æn history
        historyForGeminiInitialization.push({ role: "user", parts: [{ text: systemInstructionText }] }); 
        historyForGeminiInitialization.push({ role: "model", parts: [{ text: aiGreeting }] });      

        let loadedHistoryFromDB = await loadChatHistory(userId);
        
        const historicalMessagesForAPI = loadedHistoryFromDB.map(msg => ({
            role: msg.role, // "user" sau "model" din DB
            parts: [{ text: msg.content || "" }]
        })).filter(msg => msg.parts[0].text.trim() !== ""); 

        // Construie»ôte istoricul pentru API: sistem -> salut AI -> istoric din DB (user, model, user, model...)
        // NotƒÉ: Instruc»õiunile de sistem extinse la √Ænceputul istoricului consumƒÉ tokeni semnificativ.
        // Pentru conversa»õii lungi, s-ar putea dori optimizƒÉri aici.
        historyForGeminiInitialization = historyForGeminiInitialization.concat(historicalMessagesForAPI);

        try {
            chatSession = geminiModelChat.startChat({ // Va e»ôua aici dacƒÉ geminiModelChat e null
                history: historyForGeminiInitialization,
                generationConfig: { 
                    temperature: 0.7, // Un echilibru bun
                    maxOutputTokens: 800, // AdaugƒÉ o limitƒÉ per rƒÉspuns dacƒÉ e cazul
                }
            });
            console.log("Sesiune chat Gemini ini»õializatƒÉ cu succes. Istoric trimis la API:", historyForGeminiInitialization.length, "mesaje.");
            if (chatStatus) chatStatus.textContent = "Chat pregƒÉtit.";
            
             // Afi»ôeazƒÉ salutul AI-ului »ôi istoricul CON»öINUT din DB.
             // Salutul ini»õial a fost trimis deja la API.
             messagesDiv.innerHTML = ''; // AsigurƒÉ cƒÉ e gol √Ænainte de a adƒÉuga

             // Re-afi»ôeazƒÉ salutul ini»õial care a fost trimis la API (face parte din 'istoric')
             displayChatMessage(aiGreeting, "AI");

            // Apoi afi»ôeazƒÉ istoricul propriu-zis
            loadedHistoryFromDB.forEach(msg => {
                 displayChatMessage(msg.content, msg.role === "model" ? "AI" : "user");
            });

            isChatInitialized = true;
            if (sendButton) sendButton.disabled = false;

        } catch(initError) {
            console.error("Eroare la ini»õializarea sesiunii de chat Gemini (startChat):", initError, initError.stack);
            if (chatStatus) chatStatus.textContent = "Eroare AI Chat.";
            displayChatMessage("A apƒÉrut o problemƒÉ tehnicƒÉ la pornirea chat-ului. VƒÉ rugƒÉm sƒÉ √Ænchide»õi »ôi redeschide»õi fereastra de chat.", "AI-error");
            isChatInitialized = false;
            chatSession = null;
            if (sendButton) sendButton.disabled = true; 
            return null;
        }
        return chatSession;
    }


    // Func»õie pentru a converti Markdown limitat »ôi elemente speciale √Æn HTML
    function formatAiMessageContent(mdText) {
        let html = mdText;

        // PAS 1: DetecteazƒÉ »ôi marcheazƒÉ blocuri specifice (capsula teoreticƒÉ)
        // Presupunem un format simplificat de tip tag-uri sau chenare ASCII clare
        // Implementare bazatƒÉ pe o tentativƒÉ de parsare ASCII:

        // CautƒÉ block-uri √Ænconjurate de ceva ce ar putea fi bordurƒÉ ASCII (multiple - sau =, etc.)
        // This regex attempts to capture text between lines starting with corner chars like ‚îå, ‚îè, ‚îî, ‚îó and content lines between.
        // It's very specific to the exact ASCII generated format. If AI output varies, this breaks.
        // It also doesn't perfectly handle nested structures or complex cases.
        // A dedicated markdown parser library is much more robust.
        
        // Adjust the regex to better capture the sample ASCII structure provided earlier.
        // Sample structure:
        // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        // |   *CapsulƒÉ TeoreticƒÉ* ‚ú®   |
        // | *Defuzionarea CognitivƒÉ (ACT):* |
        // | Abilitatea de a te distan»õa... |
        // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

        const complexAsciiBoxRegex = /^[‚îå‚îè].*?\n((?:.|\n)*?)\n^[‚îî‚îó].*?$/gm; 

        html = html.replace(complexAsciiBoxRegex, (match, innerContent) => {
            let cleanedInner = innerContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let boxTitle = 'Info'; 
            let boxConcept = '';
            let bodyText = '';

            // CautƒÉ titlul pe prima linie validƒÉ
            if (cleanedInner.length > 0) {
                 const titleMatch = cleanedInner[0].match(/\|\s*(.*?)\s*(\p{Emoji_Presentation}|\p{Extended_Pictographic})*\s*\|/u); // Ex: "|   *CapsulƒÉ TeoreticƒÉ* ‚ú®   |"
                if (titleMatch && titleMatch[1]) {
                    boxTitle = titleMatch[1].replace(/\*/g, '').trim(); 
                    cleanedInner.shift(); // Remove the processed title line
                } else {
                     boxTitle = cleanedInner[0]; // Prima linie ca titlu dacƒÉ formatul | Title | nu e gƒÉsit
                     cleanedInner.shift();
                }
            }
            
            // CautƒÉ conceptul pe a doua linie validƒÉ sau similar
             if (cleanedInner.length > 0) {
                const conceptLine = cleanedInner[0];
                 if (conceptLine.includes(':') || conceptLine.includes('*') || conceptLine.includes('_')) {
                     boxConcept = `<em>${conceptLine.replace(/[:\*_]/g, '').trim()}:</em>`; // Simplificare
                     cleanedInner.shift();
                } else {
                    // DacƒÉ a doua linie nu pare un concept, poate prima a fost ambele
                     if (boxConcept === '') boxConcept = `<em>${boxTitle}</em>`;
                     boxTitle = 'Info'; // Reset title to default if it might have included the concept
                 }
            }

            // Restul liniilor sunt corpul textului
            bodyText = cleanedInner.join('\n');

            // Generare HTML pentru teoria box
            return `
<div class="theory-box">
    <span class="theory-box-title">${boxTitle}</span>
    ${boxConcept ? `<span class="theory-box-concept">${boxConcept}</span>` : ''}
    <p>${bodyText.replace(/\n/g, '<br>')}</p>
</div>\n\n`;
        });

        // PAS 2: Converte»ôte restul Markdown-ului (simplu) √Æn HTML
        
        // Titlu Mesaj AI (folosind regex-ul care cautƒÉ emoji la √Ænceput »ôi sf√¢r»ôit pe o linie,
        // acest lucru trebuie sƒÉ se √Ænt√¢mple √Ænainte de a √ÆmpƒÉr»õi √Æn paragrafe dacƒÉ titlul e prima linie)
         // Acum aplicƒÉm regex-ul pentru titlu pe `html` modificat, presupun√¢nd cƒÉ titlul a rƒÉmas pe linia lui.
        const messageTitleRegex = /^((\p{Emoji_Presentation}|\p{Extended_Pictographic}).+?(\p{Emoji_Presentation}|\p{Extended_Pictographic}))$/u; // Simplified regex

        html = html.replace(messageTitleRegex, '<span class="message-title">$1</span>\n\n'); // Replace whole line with title span + 2 newlines


        // Split √Æn blocuri (paragrafe sau blocuri speciale deja generate)
        const blocks = html.split('\n\n').filter(block => block.trim() !== '');
        let finalHtml = '';

        blocks.forEach(block => {
             // DacƒÉ block-ul a fost deja convertit √Æntr-un element complex (theory-box, title)
            if (block.startsWith('<div class="theory-box">') || block.startsWith('<span class="message-title">')) {
                finalHtml += block;
            } else {
                 // Alt text, trateazƒÉ-l ca paragraf, inclusiv bold/italic »ôi newlines
                 let paragraphContent = block;
                
                 // Bold/Italic (re-aplicƒÉm dacƒÉ nu au fost √Æn interiorul theory-box-ului care s-a parsat)
                 paragraphContent = paragraphContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/__(.*?)__/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
                 paragraphContent = paragraphContent.replace(/_(.*?)_/g, '<em>$1</em>');

                 // Newline-uri simple devin <br>
                 paragraphContent = paragraphContent.replace(/\n/g, '<br>');
                
                 finalHtml += `<p>${paragraphContent}</p>`;
            }
        });

        // √éntoarce HTML-ul gata de inserat
        return finalHtml;
    }


    function displayChatMessage(messageText, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) {
            console.error("Elementul chatMessages nu a fost gƒÉsit.");
            return;
        }
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");

        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        const classesToAdd = messageClass.split(' ');
        messageElement.classList.add(...classesToAdd);

        const contentContainer = document.createElement('div');
        contentContainer.classList.add('chat-message-content');

        if (role === "AI") {
            // ProceseazƒÉ »ôi formateazƒÉ con»õinutul AI
            // √én cazul √Æn care AI-ul genereazƒÉ con»õinut pur text sau cu Markdown simplu,
            // sau √ÆncearcƒÉ sƒÉ facƒÉ ASCII, func»õia formatAiMessageContent
            // va √Æncerca sƒÉ √Æl transforme √Æn HTML.
            // DacƒÉ func»õia formatAiMessageContent returneazƒÉ HTML valid (chiar »ôi un singur <p>), folose»ôte innerHTML
            // Altfel (excep»õie nea»ôteptatƒÉ din func»õia de parsare, de»ôi acum ar trebui sƒÉ returneze HTML mereu)
            // ConsiderƒÉ fallback la textContent pentru siguran»õƒÉ absolutƒÉ, de»ôi scopul e formatarea.

             // UtilizƒÉm innerHTML pentru mesajele AI formatate,
             // presupun√¢nd cƒÉ formatAiMessageContent face un minim de curƒÉ»õare.
            contentContainer.innerHTML = formatAiMessageContent(messageText);
            
             // AsigurƒÉ cƒÉ cel pu»õin un element bloc existƒÉ dacƒÉ messageText nu e gol,
             // pentru a men»õine structura .ai-message > .chat-message-content > ...
             if (contentContainer.innerHTML.trim() === '' && messageText.trim() !== '') {
                contentContainer.textContent = messageText; // Fallback la text simplu
                 contentContainer.style.whiteSpace = "pre-wrap"; // PƒÉstreazƒÉ formatarea simplƒÉ
             }


        } else { 
            // Mesaje user sau AI-error - text simplu, fƒÉrƒÉ interpretare HTML
            // TextContent este mai sigur pentru con»õinutul generat de utilizator.
            contentContainer.textContent = messageText;
            contentContainer.style.whiteSpace = "pre-wrap"; // PƒÉstreazƒÉ newlines
        }

        messageElement.appendChild(contentContainer);
        messagesDiv.appendChild(messageElement);
        
        // Scroll automat √Æntr-un RequestAnimationFrame
        requestAnimationFrame(() => {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
    }


    async function handleSendChatMessage() {
        const chatInput = document.getElementById("chatInput");
        const sendButton = document.getElementById("sendChatMessageButton");
        const chatStatus = document.getElementById("chatStatus");

        if (!chatInput || !sendButton || !chatStatus) return;

        const messageText = chatInput.value.trim();
        if (messageText === "") return;

        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesarƒÉ pentru a folosi chat-ul.");
            window.location.href = "login.html";
            return;
        }

        // Afi»ôeazƒÉ mesajul utilizatorului IMEDIAT
        displayChatMessage(messageText, "user");
        
        // SalveazƒÉ mesajul utilizatorului (po»õi a»ôtepta, sau nu, decizi cum vrei feedback UI)
        const userMessageForDB = { role: "user", content: messageText, timestamp: new Date().toISOString() };
        // await saveChatMessage(user.uid, userMessageForDB); // Salvezi *√Ænainte* de trimitere AI
        saveChatMessage(user.uid, userMessageForDB).catch(err => console.error("Save user message failed:", err)); // Salvare async, nu blocheazƒÉ UI

        chatInput.value = ""; 
        sendButton.disabled = true;
        chatStatus.textContent = "PsihoGPT analizeazƒÉ...";

        if (!chatSession || !isChatInitialized) {
            console.log("Sesiunea de chat nu este (re)ini»õializatƒÉ, se √ÆncearcƒÉ acum...");
            chatSession = await initializeAndStartChatSession(user.uid); 
            if(!chatSession) { 
                chatStatus.textContent = "Eroare AI Chat.";
                sendButton.disabled = true; 
                // displayChatMessage("Nu s-a putut (re)stabili conexiunea cu AI-ul.", "AI-error");
                return; 
            }
        }
        
        try {
            const result = await chatSession.sendMessage(messageText); 
            const response = result.response;
            const aiResponseText = response?.text() || "Nu am putut genera un rƒÉspuns momentan. √éncerca»õi din nou.";

             // Logica pentru finishReason - aratƒÉ un mesaj subtil de eroare dupƒÉ text
             if (response?.candidates?.[0]?.finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                 console.warn("RƒÉspuns Gemini (chat) oprit prematur:", response.candidates?.[0]?.finishReason, response.candidates?.[0]?.safetyRatings);
                 displayChatMessage(aiResponseText + `\n\n(NotƒÉ: Generare opritƒÉ: ${response.candidates[0].finishReason}. VƒÉ rugƒÉm sƒÉ reformula»õi.)`, "AI-error"); // Foloseste AI-error pentru notificare
             } else if (response?.promptFeedback?.blockReason) { // Prompt blocat COMPLET √Ænainte de rƒÉspuns
                 console.error("Prompt blocat de Gemini:", response.promptFeedback.blockReason);
                 displayChatMessage(`Mesajul a fost blocat, posibil din motive de siguran»õƒÉ (${response.promptFeedback.blockReason}). VƒÉ rugƒÉm sƒÉ reformula»õi.`, "AI-error");
             } else {
                displayChatMessage(aiResponseText, "AI");
             }


            const aiMessageForDB = { role: "model", content: aiResponseText, timestamp: new Date().toISOString() };
             // await saveChatMessage(user.uid, aiMessageForDB); // Salvezi rƒÉspunsul AI
             saveChatMessage(user.uid, aiMessageForDB).catch(err => console.error("Save AI message failed:", err)); // Salvare async
             
             chatStatus.textContent = "Chat pregƒÉtit.";

        } catch (error) {
            console.error("Eroare la trimiterea mesajului cƒÉtre Gemini sau procesarea rƒÉspunsului:", error, error.stack);
            chatStatus.textContent = "Eroare √Æn comunicarea cu AI.";
            let displayError = "Ne pare rƒÉu, a apƒÉrut o eroare. VƒÉ rugƒÉm √Æncerca»õi din nou.";
             if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429))) {
                 displayError = "Limita de utilizare a serviciului AI a fost atinsƒÉ. VƒÉ rugƒÉm √Æncerca»õi mai t√¢rziu.";
            } else if (error.message && (error.message.toLowerCase().includes("safety") || (error.message.toLowerCase().includes("blocked")) )) {
                 displayError = "Mesajul sau rƒÉspunsul AI a fost blocat, posibil din motive de siguran»õƒÉ. √éncerca»õi sƒÉ reformula»õi.";
            } else if (error.message && error.message.toLowerCase().includes("api key not valid")){
                displayError = "Cheia API pentru serviciul AI nu este validƒÉ. Contacta»õi administratorul."
            }
            displayChatMessage(displayError, "AI-error");
            isChatInitialized = false; 
            chatSession = null;
        } finally {
            if(geminiModelChat && isChatInitialized) { 
                 sendButton.disabled = false;
            } else {
                 sendButton.disabled = true; 
                 chatStatus.textContent = "Chat AI indisponibil.";
                 //displayChatMessage("Chat AI indisponibil.", "AI-error"); // Afi»ôeazƒÉ »ôi √Æn chat
            }
            chatInput.focus();
        }
    }


    async function handleToggleChat() {
        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesarƒÉ pentru a accesa chat-ul.");
            window.location.href = "login.html";
            return;
        }

        const chatContainer = document.getElementById("chatContainer");
        const toggleButton = document.getElementById("toggleChatButton");
        const sendButton = document.getElementById("sendChatMessageButton");
        if (!chatContainer || !toggleButton) return;

        if (chatContainer.style.display === "none" || chatContainer.style.display === "") {
            chatContainer.style.display = "flex";
            toggleButton.innerHTML = "‚ûñ"; 
            // ResetƒÉm starea ini»õializatƒÉ dacƒÉ nu avem o sesiune validƒÉ
            if (!isChatInitialized || !chatSession || !geminiModelChat) { 
                 isChatInitialized = false;
                 chatSession = null; // AsigurƒÉ resetarea
            }
            
            // Ini»õializeazƒÉ sesiunea dacƒÉ nu este deja sau dacƒÉ s-a resetat
            if (!isChatInitialized) {
                console.log("TentativƒÉ ini»õializare chat session...");
                const sessionOK = await initializeAndStartChatSession(user.uid);
                 if (sessionOK && sendButton) {
                    sendButton.disabled = false; // ActiveazƒÉ dacƒÉ ini»õializarea a reu»ôit
                 } else if (sendButton) {
                    sendButton.disabled = true; // PƒÉstreazƒÉ dezactivat dacƒÉ a e»ôuat
                 }
            } else if (sendButton && geminiModelChat) {
                 sendButton.disabled = false; // ActiveazƒÉ dacƒÉ era deja ini»õializat »ôi modelul e OK
                 console.log("Chat session deja ini»õializat, se afi»ôeazƒÉ.");
            } else if (sendButton) {
                sendButton.disabled = true; // Dezactivat dacƒÉ modelul lipse»ôte
            }

            // Pozi»õioneazƒÉ »ôi focus inputul, cu un mic delay pentru animatie/afisare
             requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                     document.getElementById("chatInput")?.focus();
                });
             });

        } else {
            chatContainer.style.display = "none";
            toggleButton.innerHTML = "üí¨";
            // Nu resetƒÉm isChatInitialized sau chatSession AICI
            // Pentru ca la redeschidere rapidƒÉ sƒÉ foloseascƒÉ sesiunea existentƒÉ.
            // Resetarea se face √Æn initializeAndStartChatSession dacƒÉ dƒÉ eroare
            // sau la logout.
        }
    }

    // ... restul codului JavaScript ...
    </script>
    <style>
        /* Stiluri generale »ôi pentru form - PƒÇSTRATE */
        body {font-family: 'Roboto', 'Montserrat', sans-serif; margin: 0; padding: 20px; background: linear-gradient(to right, #ece9e6, #ffffff); color: #333; box-sizing: border-box;}
        .form-container {max-width: 900px; margin: 20px auto; background: #fff; padding: 30px; box-shadow: 0 16px 24px rgba(0,0,0,0.2); border-radius: 15px; border: 3px solid #87CEFA; transition: transform 0.3s ease;}
        .form-container:hover {transform: scale(1.01);}
        .progress-bar {width: 100%; background-color: #f3f3f3; border-radius: 25px; overflow: hidden; margin-bottom: 20px;}
        .progress {height: 20px; width: 0; background-color: #87CEFA; transition: width 0.4s ease;}
        .question-card {margin-bottom: 20px; padding: 20px; background: #fff; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: all 0.3s;}
        .question-card:hover {box-shadow: 0 6px 15px rgba(0,0,0,0.15);}
        .question-card h3 {font-weight: 700; font-size: 1.2em; margin-top: 0; margin-bottom: 10px;}
        .question-card p {font-weight: 300; font-size: 0.95em; margin-bottom: 15px; color: #555; line-height: 1.6;}
        /* Textarea specificƒÉ formularului (nu afecteazƒÉ textarea din chat) */
        .form-container textarea {width: calc(100% - 22px); padding: 10px; font-size: 16px; border-radius: 8px; border: 1px solid #ccc; resize: vertical; min-height: 60px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: border-color 0.3s;}
        .form-container textarea:focus {border-color: #87CEFA; box-shadow: 0 2px 8px rgba(135,206,250,0.5); outline: none;}
        
        input[type="submit"], button {margin-top: 20px; padding: 12px 25px; font-size: 18px; font-weight: 500; background: linear-gradient(to right, #87CEFA, #6bb9e7); color: white; border: none; border-radius: 8px; cursor: pointer; transition: background 0.3s, transform 0.2s;}
        input[type="submit"]:hover, button:hover {background: linear-gradient(to right, #6bb9e7, #4A90E2); transform: translateY(-2px);}
        button:disabled { background: #ccc !important; color: #666 !important; cursor: not-allowed !important; transform: translateY(0) !important; }

        .form-step {display: none;}
        .form-step-active {display: block; animation: fadeIn 0.7s ease-in-out;}
        @keyframes fadeIn { 0% {opacity: 0; transform: translateY(10px);} 100% {opacity: 1; transform: translateY(0);} }
        .step-navigation {text-align: center; margin-top: 20px;}
        .step-navigation button {margin: 0 10px;}

        /* Stiluri pentru mesaje confirmare/eroare - PƒÇSTRATE */
         .confirmation-message {
            display: none; text-align: center; padding: 15px; 
            border: 1px solid transparent; border-radius: 5px; 
            margin-top: 20px; animation: fadeIn 0.5s;
            font-weight: bold;
        }
        .confirmation-message.success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .confirmation-message.error { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
        .confirmation-message.warning { background-color: #fff3cd; color: #856404; border-color: #ffeeba; }


        .collaboration-section {text-align:center; margin-top:30px; padding-bottom:20px;}
        .collaboration-section button {background-color:#f0ad4e;}
        .collaboration-section button:hover {background-color:#ec971f;}


        /* Stiluri pentru Vizualizare Carduri (Fi»ôe) - PƒÇSTRATE »òI U»òOR RAFINATE */
        .card-view {display: flex; flex-direction: column; gap: 20px; max-width: 900px; margin: 30px auto;}
        .response-card {background: #f9f9ff; padding: 0; border-radius: 15px; box-shadow: 0 8px 16px rgba(0,0,0,0.12); transition: box-shadow 0.3s ease; position: relative; overflow: hidden;}
        .response-card:hover {box-shadow: 0 10px 20px rgba(0,0,0,0.18);}
        .response-card .card-header {font-weight: 700; font-size: 1.1em; cursor: pointer; background: #87CEFA; padding: 12px 20px; color: #fff; text-align: left; position: relative; display: flex; justify-content: space-between; align-items: center;}
        .response-card .card-header::after {content: '‚ñº'; font-size: 0.8em; transition: transform 0.3s ease; margin-left: 10px;} /* AdƒÉugat margin-left pt spa»õiere icon */
        .response-card.open .card-header::after {transform: rotate(180deg);}
        .response-card .card-content {max-height: 0; margin-top: 0; padding: 0 20px; background: #fff; line-height: 1.6; overflow: hidden; /* Schimbat auto √Æn hidden pentru tranzi»õie */ transition: max-height 0.5s ease-out, padding-top 0.5s ease-out, padding-bottom 0.5s ease-out;} 
        .response-card.open .card-content {max-height: 3500px; /* MƒÉrit substan»õial pt con»õinut lung */ padding-top: 15px; padding-bottom: 15px; overflow: visible; /* Re-activeazƒÉ scroll dacƒÉ e nevoie, sau lasƒÉ pe containerul #chatMessages */ } 

        .response-card .card-content p {margin-bottom: 12px; border-left: 3px solid #87CEFA; padding-left: 10px; color: #333;} /* Culoarea textului specificatƒÉ */
        .response-card .card-content p strong {color: #333;} /* PƒÉstrat */
        .response-card h4 {text-align: left; color: #4A90E2; font-weight: bold; margin-top: 20px; margin-bottom: 10px; font-size: 1.05em;}
        .response-card h4:first-child {margin-top: 0;}
        .card-actions {text-align: center; margin-top: 20px; padding-bottom: 10px; border-top: 1px solid #eee; padding-top: 15px;}
        .card-actions button {padding: 8px 15px; font-size: 0.9em; margin: 5px;}
        .generate-ai-feedback-button {background-color: #5cb85c;} 
        .generate-ai-feedback-button:hover {background-color: #4cae4c;}
        .delete-all-feedback-button {background-color: #ffc107;} 
        .delete-all-feedback-button:hover {background-color: #e0a800;}
        .delete-button {background-color: #dc3545 !important;} 
        .delete-button:hover {background-color: #c82333 !important;}
        
        /* Stiluri Istoric Feedback AI (√Æn carduri) - PƒÇSTRATE */
        .ai-feedback-history-container { margin-top: 20px; border-top: 1px dashed #ddd; padding-top: 15px;} /* AdaugƒÉ un separator */
        .ai-feedback-history-container h4 { font-size: 1.1em; color: #4A90E2; margin-bottom: 10px; }
        .feedback-entry-card {background:#eef6ff; padding:15px; border-left:4px solid #4A90E2; border-radius:5px; margin-bottom:15px; font-size:0.95em; line-height:1.6;}
        .feedback-timestamp {color:#555; font-size:0.9em; margin-bottom:12px;}
        .feedback-section {margin-bottom:12px;}
        .feedback-section h5 {font-size:1em; font-weight:bold; color: #2c5282; margin-top:0; margin-bottom:6px;} /* Ajustat culoare la un albastru mai √Ænchis */
        .feedback-section p, .feedback-section ul {margin-top:0; margin-bottom:8px; color:#1e293b;} /* Ajustat culoare text */
        .feedback-section ul {padding-left:25px; list-style-position:outside; list-style-type:disc;}
        .feedback-section li {margin-bottom:4px;}
         .feedback-entry-card p[style*="color: red"] { font-weight: bold; } /* Stil specific pentru erori */
         .feedback-entry-card p[style*="color: orange"] { font-style: italic; } /* Stil specific pentru warning-uri */


        /* Stiluri Chat - √éMBUNƒÇTƒÇ»öITE */
        .chat-container {
            /* display: none; /* Comentat pentru testare */
            display: flex;
            flex-direction: column;
            position: fixed;
            bottom: 80px; /* Spa»õiu deasupra butonului */
            right: 20px;
            width: clamp(320px, 90vw, 400px); /* LƒÉ»õime mai precisƒÉ */
            max-height: 70vh; 
            background: #f0f4f8; /* Fundal soft */
            border-radius: 10px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 999; 
            padding: 15px;
            box-sizing: border-box;
        }
         .chat-container h3 {
            text-align: center; color: #333; margin-top: 0; margin-bottom: 10px; font-size: 1.2em;
            flex-shrink: 0;
        }
        #chatMessages {
            flex-grow: 1;
            height: 300px; 
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
            background: #fff; 
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Spa»õiu √Æntre mesajele .chat-message */
            scrollbar-width: thin; 
            scrollbar-color: #888 #f1f1f1;
        }
         #chatMessages::-webkit-scrollbar {
            width: 8px;
         }
         #chatMessages::-webkit-scrollbar-track {
            background: #f1f1f1; 
         }
         #chatMessages::-webkit-scrollbar-thumb {
            background: #888; 
            border-radius: 4px;
         }
         #chatMessages::-webkit-scrollbar-thumb:hover {
            background: #555; 
         }

        .chat-message {
            padding: 8px 12px;
            border-radius: 18px; 
            max-width: 85%; 
            word-wrap: break-word; 
            line-height: 1.5; 
            box-shadow: 0 1px 1px rgba(0,0,0,0.08);
            font-size: 0.95em;
        }
        
        /* Containerul pentru con»õinutul din interiorul fiecƒÉrei bule de mesaj */
        .chat-message-content { 
            margin: 0;
            padding: 0;
            /* display: flex; /* Activat dacƒÉ vrem ca elementele interne sƒÉ foloseascƒÉ gap */
            /* flex-direction: column; */
            /* gap: 8px; /* Spa»õiu uniform √Æntre elementele interne, dacƒÉ flex e activat */
                       /* Ar permite eliminarea margin-bottom de pe p, message-title, etc. */
        }


        .user-message {
            background-color: #007bff; 
            color: white;
            align-self: flex-end; 
            margin-left: auto; 
            border-bottom-right-radius: 5px; 
            border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-left-radius: 18px; 
        }
        .ai-message {
            background-color: #e9ecef; 
            color: #212529; 
            align-self: flex-start; 
            margin-right: auto; 
            border-bottom-left-radius: 5px; 
            border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-right-radius: 18px; 
        }
        .ai-message.ai-error { 
            background-color: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb; 
            align-self: flex-start;
            border-radius: 8px; 
        }
         /* Titlurile generate de AI √Æn interiorul mesajelor */
         .ai-message .message-title { /* AceastƒÉ clasƒÉ e adƒÉugatƒÉ de func»õia formatAiMessageContent */
             font-size: 1.05em; /* Pu»õin mai mare »ôi mai gros */
             font-weight: 700; 
             color: #1a5a9c; /* Albastru √Ænchis specific */
             margin-bottom: 8px; /* Spa»õiu sub titlu, √Ænainte de paragraf */
             display: block; /* OcupƒÉ toatƒÉ lƒÉ»õimea disponibilƒÉ √Æn containerul de con»õinut */
             padding-bottom: 5px; /* Pu»õin spa»õiu sub textul titlului */
             border-bottom: 1px solid #cfd8e1; /* Linie separatoare finƒÉ */
             line-height: 1.4; /* Ajustare linie pentru titluri */
         }
         /* Paragrafele din interiorul .chat-message-content pentru AI */
         .ai-message .chat-message-content p {
             margin-top: 0; /* EliminƒÉ orice spa»õiu de sus adƒÉugat implicit de browser */
             margin-bottom: 10px; 
             line-height: 1.6; /* Lizibilitate √ÆmbunƒÉtƒÉ»õitƒÉ */
         }
         .ai-message .chat-message-content p:last-child {
             margin-bottom: 0; 
         }

         /* Formatare specificƒÉ pentru text italic »ôi bold √Æn mesajele AI */
         .ai-message em, .ai-message i {
            font-style: italic; /* AsigurƒÉ cƒÉ este italic */
            /* color: #007bff; /* Op»õional, o culoare distinctƒÉ */
         }
         .ai-message strong, .ai-message b {
            font-weight: bold; /* AsigurƒÉ cƒÉ este bold */
            /* color: #2c3e50; /* Op»õional, un negru/gri mai √Ænchis */
         }
        
        /* Stil pentru Capsulele Teoretice */
        .ai-message .theory-box { /* AceastƒÉ clasƒÉ e adƒÉugatƒÉ de func»õia formatAiMessageContent */
            background-color: #eef5fc; 
            border: 1px solid #c3daec; 
            border-left: 5px solid #4A90E2; 
            padding: 10px 15px;
            margin: 12px 0; 
            border-radius: 8px; 
            font-size: 0.9em;
            line-height: 1.5;
            word-break: break-word; 
        }
        .ai-message .theory-box .theory-box-title { 
            font-weight: bold;
            color: #2c5282; 
            margin-top: 0; /* ReseteazƒÉ marginea de sus a titlului intern */
            margin-bottom: 6px; /* Spa»õiu dupƒÉ titlul capsulei */
            display: block;
            font-size: 1em; 
        }
        .ai-message .theory-box .theory-box-concept { 
            font-style: italic;
            color: #444; /* Un gri mai √Ænchis pentru concept */
            margin-bottom: 6px;
            display: block;
        }
        .ai-message .theory-box p { 
            margin-top: 0;
            margin-bottom: 5px; 
            line-height: 1.5;
            font-size: 1em; /* PƒÉstreazƒÉ dimensiunea de la .theory-box */
        }
         .ai-message .theory-box p:last-child {
            margin-bottom: 0;
         }

         /* Stil pentru blocul ASCII (dacƒÉ este generat »ôi parsarea JS √Æl pune √Æn aceastƒÉ clasƒÉ) */
         .ai-message .ascii-art-block {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            white-space: pre; 
            overflow-x: auto; 
            padding: 10px;
            background-color: #f8f9fa; 
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 0.85em; 
            line-height: 1.3;
            margin: 10px 0;
            word-wrap: normal; 
            word-break: normal; 
            color: #495057;
         }
        
        #chatInput { /* Am scos calc(100% - 0px) care nu e necesar cu box-sizing:border-box */
            width: 100%; 
            padding: 10px; 
            border-radius: 5px; 
            border: 1px solid #ccc; 
            resize: vertical; 
            min-height: 40px; 
            box-sizing: border-box;
            font-family: inherit;
            flex-shrink: 0;
            margin-bottom: 8px;
        }
         #chatInput:focus {
             border-color: #87CEFA;
             box-shadow: 0 0 5px rgba(135,206,250,0.5);
             outline: none;
         }
        #sendChatMessageButton {
            margin-top: 0;
            padding: 10px 15px;
            width: 100%; 
            font-size: 1em;
            background: linear-gradient(to right, #87CEFA, #6bb9e7); 
            color: white;
            border: none;
            border-radius: 5px; 
            cursor: pointer;
            transition: background 0.3s ease; 
            flex-shrink: 0; 
        }
         #sendChatMessageButton:hover {
             background: linear-gradient(to right, #6bb9e7, #4A90E2);
         }
         #sendChatMessageButton:disabled {
             background: #ccc !important; /* Important pentru a suprascrie gradientul */
         }

        #chatStatus {
            font-size: 0.85em; color: #555; margin-top: 5px; text-align: center; min-height: 1.2em;
            flex-shrink: 0;
        }

        #toggleChatButton {
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            padding: 0; 
            z-index: 1000; 
            display: flex; 
            align-items: center;
            justify-content: center;
            background-color: #87CEFA; 
            color: white;
            border: none;
            border-radius: 50%; 
            width: 55px; 
            height: 55px;
            font-size: 26px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }
        #toggleChatButton:hover {
             background-color: #6bb9e7; 
             transform: scale(1.05);
        }
        /* Regula pt a ascunde containerul - ajustatƒÉ ca sƒÉ nu interfereze cu stilurile ini»õiale flex */
        .chat-container[style*="display: none"] { 
             display: none !important;
        }

        /* Stiluri Tabel Original - RƒÉm√¢n Ascunse */
         .table-container {display: none;} 

        /* Responsive Styles - PƒÇSTRATE »òI AJUSTATE PENTRU CHAT */
        @media (max-width: 768px) {
            body {padding:10px;}
            .form-container, .card-view {padding:15px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);}
            .form-container textarea {font-size:14px; padding:8px; width:calc(100% - 18px);}
            .form-container > button, .step-navigation button {font-size:16px; padding:10px 20px;}
            .card-actions button {font-size:0.85em; padding:7px 12px;}
            .question-card h3, .response-card .card-header {font-size:1.05em;}
            .question-card p, .response-card .card-content p {font-size:0.9em;}
            
            .chat-container { 
                width: calc(100% - 20px); /* OcupƒÉ aproape toatƒÉ lƒÉ»õimea pe mobil */
                right: 10px;
                left: 10px; /* Centrat aproximativ */
                max-height: 60vh; /* Redu √ÆnƒÉl»õimea */
                bottom: 75px; 
                padding: 10px; /* Reduce padding */
            }
            #chatMessages { height: 220px; padding: 8px; } /* Reduce √ÆnƒÉl»õimea »ôi paddingul */
            .chat-message { max-width: 90%; padding: 7px 10px; } /* AjusteazƒÉ dimensiuni bule */

            #toggleChatButton { 
                width: 50px; 
                height: 50px; 
                font-size: 24px; 
                bottom: 15px; right: 15px; /* Pozi»õie pe mobil */
            }
            #chatInput { font-size: 0.95em; min-height: 35px;} /* Input mai mic */
            #sendChatMessageButton { font-size: 0.95em; padding: 8px 12px;} /* Buton mai mic */


            /* Responsiv Tabel (rƒÉm√¢ne ascuns) */
            .table-container {overflow-x:auto;}
            table {display:block; width:100%;}
            thead, tbody, tr {display:block;}
            th {display:none;} 
            tr {margin-bottom:15px; border:1px solid #ddd; border-radius:5px; display:flex; flex-direction:column;}
            td {display:flex; justify-content:space-between; padding:10px; text-align:right; border-bottom:1px solid #eee; position:relative;}
            td:last-child {border-bottom:none;}
            td::before {content:attr(data-label); font-weight:bold; text-align:left; margin-right:10px; color:#555; flex-shrink:0; width:auto; padding-right: 10px;} 
            td > *:not(button) {flex-grow:1; word-break:break-word; text-align:left;} 
            td button {width:auto; padding:6px 12px; font-size:0.85em; margin-left:auto; flex-shrink:0;}
            td[colspan="10"] {display:block;}
        }
        @media (max-width: 480px) {
            body {padding:8px;} /* Reduce paddingul general */
            .form-container, .card-view {padding:10px; margin-left:8px; margin-right:8px; max-width:calc(100% - 16px);}
            .form-container textarea {font-size:13px; padding:6px; width:calc(100% - 14px);}

            .form-container > button, .step-navigation button {font-size:14px; padding:8px 15px;}
            .card-actions button {font-size:0.8em; padding:6px 10px;}
            .question-card h3, .response-card .card-header {font-size:1em;}
            .question-card p, .response-card .card-content p {font-size:0.85em;}
            .response-card .card-header {padding:10px;}
            .response-card .card-content {padding-left:15px; padding-right:15px; font-size:0.85em;}
            td {flex-direction:column; align-items:flex-start;} 
            td::before {width:100%; margin-bottom:5px; margin-right: 0;}
            td button {align-self:flex-end;}

            .chat-container { 
                width: calc(100% - 16px); 
                 right: 8px; left: 8px;
                max-height: 55vh; 
                bottom: 70px;
                padding: 8px;
            }
            #chatMessages { height: 180px; padding: 6px; gap: 6px; }
            .chat-message { padding: 6px 10px; }

            #toggleChatButton { 
                width: 45px; 
                height: 45px; 
                font-size: 22px; 
                bottom: 12px; right: 12px;
                 box-shadow: 0 1px 5px rgba(0,0,0,0.3);
            }

        }
    </style>
</head>
<body>

    <div class="form-container">
        <h2 class="main-form-title">Fi»ôƒÉ Monitorizare</h2> 
        <p>CompleteazƒÉ fiecare √Æntrebare pentru a √Æn»õelege mai bine situa»õiile tale. Fiecare sec»õiune reprezintƒÉ o parte importantƒÉ a reflec»õiei tale. √én acest exerci»õiu, √Æ»õi voi ghida fiecare pas, astfel √Ænc√¢t sƒÉ po»õi explora √Æn profunzime g√¢ndurile, emo»õiile »ôi comportamentele tale.</p>
    
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    
        <form id="exercitiuForm" novalidate>
            <!-- PASUL 1 - PASUL 28 - PƒÇSTRAT COMPLET -->
             <!-- AICI ESTE TOATƒÇ STRUCTURA HTML A FORMULARULUI CUM AI AVUT-O DEJA -->

            <div class="question-card form-step form-step-active" id="step-1">
                <h3>Care este situa»õia?</h3>
                <p>Te rog sƒÉ descrii contextul care a declan»ôat emo»õiile sau comportamentul tƒÉu. √éncearcƒÉ sƒÉ fii c√¢t mai specific »ôi detaliat. Aceasta poate fi o situa»õie concretƒÉ din via»õa de zi cu zi √Æn care te-ai sim»õit cople»ôit, stresat sau √Æntr-o altƒÉ stare emo»õionalƒÉ intensƒÉ.</p>
                <textarea name="situatie" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-2">
                <h3>Ce √Æmi trece prin minte?</h3>
                <p>√é»õi cer sƒÉ identifici g√¢ndurile automate care au apƒÉrut √Æn aceastƒÉ situa»õie. Acestea sunt g√¢nduri rapide, involuntare, care √Æ»õi trec prin minte √Æn momentele de stres. Ce √Æ»õi spui √Æn acel moment? Este un g√¢nd critic sau √ÆngrijorƒÉtor?</p>
                <textarea name="ganduri" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-3">
                <h3>Cum mƒÉ face acel g√¢nd sƒÉ mƒÉ simt?</h3>
                <p>Te rog sƒÉ notezi emo»õiile pe care le sim»õi √Æn urma acelui g√¢nd. Ce sim»õi? FricƒÉ, triste»õe, furie? DƒÉ o intensitate emo»õiei (de la 0 la 100) pentru a vedea c√¢t de puternicƒÉ este.</p>
                <textarea name="emotii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-4">
                <h3>Ce mod este activ?</h3>
                <p>IdentificƒÉ modul √Æn care te afli √Æn aceastƒÉ situa»õie. Este un mod de copil vulnerabil, critic interior, sau poate adultul sƒÉnƒÉtos? Con»ôtientizarea modului √Æ»õi poate oferi o mai bunƒÉ √Æn»õelegere a reac»õiilor tale.</p>
                <textarea name="mod_activ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-5">
                <h3>Ce comportament sim»õi cƒÉ adop»õi?</h3>
                <p>Descrie comportamentul pe care √Æl manife»ôti √Æn aceastƒÉ situa»õie. Este un comportament de evitare, de confruntare, de sacrificiu de sine? Recunoa»ôterea comportamentului te ajutƒÉ sƒÉ √Æn»õelegi mai bine cum reac»õionezi.</p>
                <textarea name="comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-6">
                <h3>Care sunt nevoile tale mai profunde?</h3>
                <p>Ce nevoi stau la baza acestor emo»õii »ôi comportamente? Poate fi nevoia de siguran»õƒÉ, de validare, de acceptare? Identificarea acestor nevoi te poate ajuta sƒÉ gƒÉse»ôti strategii mai sƒÉnƒÉtoase pentru a le √Ændeplini.</p>
                <textarea name="nevoi_profunde" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-7">
                <h3>MƒÉ ajutƒÉ comportamentul meu sƒÉ √Ændeplinesc aceste nevoi?</h3>
                <p>ReflecteazƒÉ dacƒÉ felul √Æn care reac»õionezi te ajutƒÉ cu adevƒÉrat sƒÉ √Æ»õi √Ændepline»ôti nevoile. Poate fi util sƒÉ te g√¢nde»ôti dacƒÉ existƒÉ alternative mai eficiente.</p>
                <textarea name="ajutor_comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-8">
                <h3>Cum ar g√¢ndi »ôi cum s-ar comporta Adultul SƒÉnƒÉtos?</h3>
                <p>G√¢nde»ôte-te la cum ar reac»õiona partea ta AdultƒÉ SƒÉnƒÉtoasƒÉ √Æn aceastƒÉ situa»õie. Cum ai putea sƒÉ abordezi diferit pentru a avea grijƒÉ de tine »ôi de nevoile tale?</p>
                <textarea name="adult_sanatos" rows="3" required></textarea>
            </div>

            <!-- PASUL 2 -->
            <div class="question-card form-step" id="step-9">
                <h3>Ce mƒÉ face sƒÉ cred cƒÉ g√¢ndul automat este adevƒÉrat?</h3>
                <p>ExploreazƒÉ motivele pentru care crezi cƒÉ acest g√¢nd este adevƒÉrat. Ce dovezi ai care √Æ»õi confirmƒÉ acest lucru? De multe ori, ne bazƒÉm pe experien»õe trecute sau frici pentru a justifica un g√¢nd.</p>
                <textarea name="dovezi_adevar" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-10">
                <h3>Ce mƒÉ face sƒÉ cred cƒÉ nu este adevƒÉrat?</h3>
                <p>Acum, sƒÉ ne uitƒÉm la dovezile √Æmpotriva g√¢ndului tƒÉu. ExistƒÉ argumente sau experien»õe care contrazic acest g√¢nd? Poate existƒÉ o altƒÉ perspectivƒÉ pe care nu ai luat-o √Æn considerare?</p>
                <textarea name="dovezi_fals" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-11">
                <h3>ExistƒÉ o explica»õie alternativƒÉ?</h3>
                <p>Uneori, existƒÉ mai multe explica»õii pentru ceea ce se √Ænt√¢mplƒÉ. Ce alte interpretƒÉri ai putea avea pentru aceastƒÉ situa»õie? G√¢nde»ôte-te la alte posibilitƒÉ»õi care ar putea explica contextul.</p>
                <textarea name="explicatie_alternativa" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-12">
                <h3>Care este cel mai rƒÉu lucru care s-ar putea √Ænt√¢mpla?</h3>
                <p>Ce este cel mai rƒÉu care ar putea avea loc √Æn aceastƒÉ situa»õie? SƒÉ identificƒÉm acele frici catastrofale care adesea ne alimenteazƒÉ g√¢ndurile negative.</p>
                <textarea name="scenariu_negativ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-13">
                <h3>Care este cel mai bun lucru care s-ar putea √Ænt√¢mpla?</h3>
                <p>Pe de altƒÉ parte, care ar fi cel mai pozitiv scenariu? Uneori uitƒÉm sƒÉ ne g√¢ndim »ôi la posibilitƒÉ»õile bune. Cum ar arƒÉta cel mai bun rezultat al acestei situa»õii?</p>
                <textarea name="scenariu_optimist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-14">
                <h3>Care este cel mai realist rezultat?</h3>
                <p>DupƒÉ ce am explorat extremele, ce crezi cƒÉ este cel mai probabil sƒÉ se √Ænt√¢mple? Cum ar arƒÉta un rezultat realist, »õin√¢nd cont de toate perspectivele?</p>
                <textarea name="rezultat_realist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-15">
                <h3>Ce s-ar √Ænt√¢mpla dacƒÉ mi-a»ô schimba modul de g√¢ndire?</h3>
                <p>√éntreabƒÉ-te cum ar fi dacƒÉ ai aborda situa»õia cu un alt tip de g√¢ndire. Cum ar influen»õa asta emo»õiile »ôi comportamentele tale?</p>
                <textarea name="schimbare_gandire" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-16">
                <h3>Ce i-a»ô spune unui prieten dacƒÉ ar fi √Æn aceea»ôi situa»õie?</h3>
                <p>G√¢nde»ôte-te la cum ai reac»õiona dacƒÉ un prieten drag ar avea acelea»ôi g√¢nduri. Ce i-ai spune pentru a-l sprijini? Cum ai √Æncerca sƒÉ-l √Æncurajezi?</p>
                <textarea name="sfat_prieten" rows="3" required></textarea>
            </div>

            <!-- PASUL 3 -->
            <div class="question-card form-step" id="step-17">
                <h3>VƒÉd doar partea rea a lucrurilor?</h3>
                <p>Este posibil sƒÉ fii prins √Æntr-un tipar negativ de g√¢ndire, concentr√¢ndu-te doar pe aspectele negative. √éncearcƒÉ sƒÉ observi dacƒÉ existƒÉ »ôi aspecte pozitive pe care le-ai ignorat.</p>
                <textarea name="partea_rea" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-18">
                <h3>√émi asum responsabilitatea pentru lucruri care nu au stat √Æn puterea mea?</h3>
                <p>ReflecteazƒÉ dacƒÉ √Æ»õi asumi responsabilitatea pentru situa»õii asupra cƒÉrora nu aveai control. Este important sƒÉ √Æ»õi dai seama de limitele influen»õei tale.</p>
                <textarea name="responsabilitate" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-19">
                <h3>MƒÉ condamn √Æn baza unui singur eveniment?</h3>
                <p>√é»õi evaluezi valoarea personalƒÉ baz√¢ndu-te pe un singur eveniment negativ? Aminte»ôte-»õi cƒÉ un eveniment nu define»ôte cine e»ôti √Æn totalitate.</p>
                <textarea name="condamnare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-20">
                <h3>Privesc situa»õia √Æn termeni extremi?</h3>
                <p>VerificƒÉ dacƒÉ vezi situa»õia doar √Æn alb sau negru, fƒÉrƒÉ nuan»õe de gri. G√¢ndirea extremƒÉ poate distorsiona realitatea.</p>
                <textarea name="termeni_extremi" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-21">
                <h3>Exagerez situa»õia?</h3>
                <p>√é»õi amplifici reac»õiile fa»õƒÉ de o situa»õie? √éncearcƒÉ sƒÉ te g√¢nde»ôti dacƒÉ ceea ce percepi este realist sau dacƒÉ exagerezi impactul situa»õiei.</p>
                <textarea name="exagerare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-22">
                <h3>ExistƒÉ »ôi al»õi factori responsabili?</h3>
                <p>ExistƒÉ al»õi factori care contribuie la aceastƒÉ situa»õie, pe l√¢ngƒÉ tine? Este important sƒÉ ai o perspectivƒÉ completƒÉ asupra cauzelor unei situa»õii.</p>
                <textarea name="factori_responsabili" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-23">
                <h3>Am sƒÉrit direct la concluzii?</h3>
                <p>Te-ai grƒÉbit sƒÉ ajungi la o concluzie fƒÉrƒÉ suficiente dovezi? √éncearcƒÉ sƒÉ observi dacƒÉ existƒÉ alte posibilitƒÉ»õi care ar putea explica situa»õia.</p>
                <textarea name="concluzii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-24">
                <h3>√émi pun √ÆntrebƒÉri fƒÉrƒÉ rƒÉspuns?</h3>
                <p>Te frƒÉm√¢ntƒÉ √ÆntrebƒÉri care nu au un rƒÉspuns clar sau realist? Aceste √ÆntrebƒÉri pot fi o sursƒÉ majorƒÉ de anxietate.</p>
                <textarea name="intrebari_fara_raspuns" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-25">
                <h3>MƒÉ concentrez doar asupra slƒÉbiciunilor mele?</h3>
                <p>Ai tendin»õa sƒÉ te focalizezi doar pe slƒÉbiciuni »ôi sƒÉ ignori punctele tale forte? √éncearcƒÉ sƒÉ √Æ»õi recuno»ôti »ôi punctele pozitive.</p>
                <textarea name="slabiciuni" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-26">
                <h3>MƒÉ zbat prea mult g√¢ndind la cum ar trebui sƒÉ fie lucrurile?</h3>
                <p>Ai tendin»õa sƒÉ te g√¢nde»ôti mereu la cum ar trebui sƒÉ fie lucrurile, √Æn loc sƒÉ accep»õi situa»õia a»ôa cum este? Acceptarea poate reduce stresul »ôi anxietatea.</p>
                <textarea name="cum_ar_trebui" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-27">
                <h3>MƒÉ a»ôtept sƒÉ fiu perfect?</h3>
                <p>√é»õi setezi standarde foarte √Ænalte, imposibil de atins? Perfec»õionismul poate fi o sursƒÉ majorƒÉ de frustrare »ôi descurajare.</p>
                <textarea name="perfectiune" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-28">
                <h3>Completare finalizatƒÉ!</h3>
                <p>FelicitƒÉri pentru parcurgerea acestui exerci»õiu de auto-reflec»õie! ApasƒÉ butonul de mai jos pentru a salva datele »ôi a genera un feedback automatizat, dacƒÉ este disponibil.</p>
                <p>Feedback-ul AI te poate ajuta sƒÉ ob»õii noi perspective. DacƒÉ √Ænt√¢mpini probleme cu generarea (ex: erori de limitƒÉ de utilizare sau cheie API invalidƒÉ), po»õi √Æncerca din nou mai t√¢rziu sau contacta administratorul.</p>
            </div>


            <div class="step-navigation">
                <button type="button" id="prevButton">√énapoi</button>
                <button type="button" id="nextButton">√énainte</button>
            </div>
            <button type="button" id="addButton">SalveazƒÉ »ôi GenereazƒÉ Feedback AI</button>
        </form>

        <div id="confirmationMessage" class="confirmation-message">
            <!-- Mesajul va fi setat de JavaScript -->
        </div>

        <div class="collaboration-section">
            <button type="button" id="generateLinkButton">GenereazƒÉ Link de Colaborare</button>
        </div>
    </div>
    
    <h3 style="text-align: center; margin-top: 40px; margin-bottom: 10px; color: #333; font-weight: 500;">RƒÉspunsurile Tale »ôi Istoricul Feedback-ului AI:</h3>
    
    <div class="card-view" id="cardViewContainer">
        <!-- Cardurile cu rƒÉspunsuri »ôi feedback AI vor fi adƒÉugate aici de JavaScript -->
    </div>
    
    <!-- Chat Container -->
    <div class="chat-container" id="chatContainer"> 
        <h3>DiscutƒÉ cu PsihoGPT</h3>
        <div id="chatMessages">
            <!-- Mesajele vor apƒÉrea aici -->
        </div>
        <textarea id="chatInput" rows="2" placeholder="Scrie mesajul tƒÉu aici... ApasƒÉ Enter pentru a trimite."></textarea>
        <button id="sendChatMessageButton" disabled>Trimite Mesaj</button> 
        <p id="chatStatus"></p>
    </div>

    <button id="toggleChatButton" style="display: none;">üí¨</button>


     <!-- Tabelul original (acum ascuns implicit prin CSS .table-container {display: none;}) -->
    <div class="table-container"> 
        <table>
            <thead>
                <tr>
                    <th>Data</th><th>Situa»õia</th><th>G√¢nduri</th><th>Emo»õii</th><th>Mod activ</th>
                    <th>Comportament</th><th>Nevoile</th><th>Ajutor comport.</th><th>Adult SƒÉnƒÉtos</th><th>Detalii</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <br/>
</body>
</html>