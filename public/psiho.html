<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // Înlocuiește cu cheia ta reală
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÎNLOCUIEȘTE AICI !!!
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17"; // Sau "gemini-1.5-flash-latest"
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configurată:", "'" + GEMINI_API_KEY + "'");

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "" && GEMINI_API_KEY !== "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini inițializat. Model:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare SDK Gemini:", e);
            alert("Eroare inițializare AI. Verifică cheia API. AI limitat.");
            geminiModelJournalFeedback = null;
        }
    } else {
        console.warn("Jurnal Terapeutic: Cheia API Gemini lipsește sau e placeholder. AI dezactivat.");
        // Nu mai afișăm alert aici ca să nu fie enervant la fiecare refresh dacă e voit neconfigurat
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
    };

    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [
            { label: "Explorează o emoție", text: "Astăzi vreau să explorez emoția de [NUMEȘTE EMOȚIA].\n\nCum se simte în corpul meu? [DESCRIE SENZAȚIILE]\nCe gânduri sunt asociate? [NOTEAZĂ GÂNDURILE]\nÎn ce context a apărut? [DESCRIE SITUAȚIA]\nCe nevoie ar putea semnala? [REFLECTEAZĂ]\nCum aș putea oferi compasiune? [ACȚIUNE COMPASIONALĂ]\n" },
            { label: "Analizează o situație", text: "Situația care mă preocupă este: [DESCRIE SITUAȚIA]\n\nCe s-a întâmplat exact? (Fapte)\nInterpretarea mea inițială: [GÂNDURI AUTOMATE]\nEmoțiile principale: [LISTEAZĂ EMOȚIILE]\nO altă perspectivă: [REFRAMING]\nCe am învățat/pot învăța? [LECȚII]\n" },
            { label: "Dialog Voce Critică", text: "Vocea mea critică îmi spune: \"[MESAJUL CRITIC]\"\n\nMă face să mă simt: [EMOȚII GENERATE]\nDin perspectiva Adultului Sănătos, aș răspunde: \"[RĂSPUNS COMPASIONAL]\"\nO nevoie ascunsă: [NEVOIA SUBIACENTĂ]\n" },
            { label: "Recunoștință & Resurse", text: "Astăzi sunt recunoscător/oare pentru:\n1. \n2. \n3. \n\nO resursă interioară pe care mă pot baza: \nUn gest de auto-îngrijire: \n" }
        ];
        promptsContainerEl.innerHTML = ''; // Clear previous
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "Inserează acest ghid în jurnal";
            button.onclick = () => {
                if (journalTextarea.value.trim() !== "" && !confirm("Vrei să înlocuiești textul curent cu acest ghid? OK pentru a înlocui, Anulare pentru a adăuga la sfârșit.")) {
                    journalTextarea.value += "\n\n---\n" + prompt.text;
                } else {
                    journalTextarea.value = prompt.text;
                }
                journalTextarea.focus();
                journalTextarea.scrollTop = journalTextarea.scrollHeight;
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) return "EROARE: Model AI neinițializat (jurnal).";
        try {
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.72, ...generationConfigOptions }
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare oprită (Motiv: ${response.candidates[0].finishReason}).`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}).`;
            }
            return "EROARE Gemini: Răspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            return `EROARE Gemini: ${error.message || "Eroare API."}`;
        }
    }

    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: Funcționalitatea AI pentru jurnal nu este disponibilă.";
        
        const promptJurnal = `
Rolul meu personalizat pentru PsihoGPT Jurnal (pentru uz personal, sunt în terapie):
"Ești PsihoGPT, asistentul meu personal AI pentru scriere terapeutică și auto-reflecție. Te consider un 'partener de dialog' informat de diverse școli psihoterapeutice (TCC, Scheme, ACT, IFS, Psihodinamică, Centrată pe Emoții). Scopul tău este să mă ajuți să adâncesc înțelegerea propriei mele experiențe, să identific tipare, să explorez perspective și să facilitez procesul de integrare emoțională. Abordarea ta este una de curiositate empatică, provocare blândă și rezonanță cu conceptele terapeutice. Am suport terapeutic uman, deci poți fi mai direct în reflecții și poți folosi termeni tehnici relevanți, atâta timp cât menții un ton suportiv și cald."

Intrarea mea de jurnal este:
Titlu: ${entryData.titlu}
Conținut:
---
${entryData.continut}
---

Te rog să-mi oferi un feedback structurat după cum urmează, adaptat pentru mine:
1.  **Sumar Empatic Concis:** (1-2 propoziții, validând esența emoțională sau tema principală.)
2.  **Observații Cheie și Tipare Identificate:** (2-4 puncte relevante, potențiale tipare de gândire, emoționale, sau comportamentale observate. Poți fi direct.)
3.  **Conexiuni Conceptuale (Opțional, unde e cazul):** (Menționează 1-2 concepte/modele psihoterapeutice care par a ilumina ce am scris. Ex: cum se manifestă o schemă, un mecanism de coping, o distorsiune cognitivă, o nevoie neîndeplinită, principii ACT etc.)
4.  **Întrebări Specifice pentru Aprofundare:** (2-3 întrebări deschise, tăioase dar constructive, care să mă invite la o reflecție mai profundă asupra celor scrise, bazate pe conținutul meu și pe conceptele identificate.)
5.  **Sugestie de Focalizare (pentru auto-lucru):** (O scurtă sugestie despre un aspect pe care l-aș putea explora mai departe în următoarea intrare, sau un micro-exercițiu de reflecție bazat pe discuția noastră. Ex: "Pentru următoarea intrare, ai putea explora [tema] din perspectiva [model terapeutic]".)

Folosește un limbaj clar, profesionist, dar empatic. Nu ezita să folosești termeni tehnici pe care i-am putea discuta în terapie. Mulțumesc!`;
        console.log("Trimitere prompt către Gemini (jurnal):", promptJurnal.substring(0, 100) + "...");
        const feedbackText = await callGeminiAPI(promptJurnal, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId);
    }
    
    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId) {
        const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva în jurnal."); return; }

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salvează..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se generează AI...";
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id);
            
            const docSnapshot = await getDoc(docRef);
            if (docSnapshot.exists()) afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            
            journalTextarea.value = ""; if (journalTitleInput) journalTitleInput.value = "";
            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvată. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvată și feedback AI generat!';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 9000);
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau generare feedback.';
            confirmationMsg.className = 'confirmation-message error';
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
        } finally {
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se generează..."; btn.disabled = true; }

        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { alert("Intrarea nu există."); return; }
            await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId);
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); // Re-fetch
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
            }
            alert("Feedback AI regenerat!");
        } catch (e) { console.error("Eroare regenerare:", e); alert("Eroare la regenerare feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        if (!confirm("Ștergi ultimul feedback AI pentru această intrare?")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se șterge..."; btn.disabled = true; }

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                alert("Nu există feedback de șters."); return;
            }
            const history = entrySnap.data().feedbackAI_history;
            const lastFeedback = history.pop(); // Scoate ultimul și îl avem în `lastFeedback`

            await updateDoc(entryDocRef, {
                feedbackAI_history: history, // Salvează istoricul fără ultimul element
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            alert("Ultimul feedback AI șters.");
        } catch (e) { console.error("Eroare ștergere ultim feedback:", e); alert("Eroare la ștergere feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, history) {
        containerEl.innerHTML = ''; 
        if (!history?.length) {
            containerEl.innerHTML = "<p style='font-style:italic;text-align:center;'>Niciun feedback AI generat.</p>"; return;
        }
        history.slice().reverse().forEach((entry, index) => { 
            const itemDiv = document.createElement("div");
            itemDiv.className = "feedback-entry-card";
            itemDiv.innerHTML = `
                <p class="feedback-timestamp"><strong>Feedback #${history.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO")} - ${entry.model || 'N/A'})</p>
                <p style="white-space: pre-wrap; ${entry.error ? 'color:red;font-weight:bold;' : ''}">${(entry.rawText || 'Conținut indisponibil.').replace(/\n/g, '<br>')}</p>
            `;
            containerEl.appendChild(itemDiv);
        });
    }

    function afiseazaCardJurnal(entryData) {
        const container = document.getElementById("journalEntriesContainer");
        let card = container.querySelector(`.journal-card[data-id="${entryData.id}"]`);
        const cardExists = !!card;

        const entryDate = entryData.dataIntrare || (entryData.timestampCreare?.toDate ? new Date(entryData.timestampCreare.toDate()).toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }) : 'Dată necunoscută');
        const entryTitle = entryData.titlu || `Intrare din ${entryDate}`;

        if (!card) {
            card = document.createElement("div");
            card.className = "response-card journal-card"; 
            card.setAttribute("data-id", entryData.id);
            card.innerHTML = `
                <div class="card-header">${entryTitle}</div>
                <div class="card-content">
                    <p><strong>Data intrării:</strong> ${entryDate}</p>
                    <p><strong>Conținut Jurnal:</strong></p>
                    <p class="journal-entry-content">${entryData.continut.replace(/\n/g, '<br>')}</p>
                    <h4>Feedback AI PsihoGPT</h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                         <button class="regenerate-feedback-button" title="Regenerează Feedback AI">Regenerează</button>
                         <button class="delete-last-feedback-button" title="Șterge Ultimul Feedback AI">Șterge Ultimul</button>
                         <button class="delete-journal-entry-button" title="Șterge Intrarea și Tot Feedback-ul">Șterge Intrarea</button>
                    </div>
                </div>`;
            card.querySelector('.card-header').addEventListener('click', () => card.classList.toggle('open'));
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); regenereazaFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); stergeUltimulFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeIntrareJurnal(entryData.id, card); });

            if (container.firstChild && container.firstChild.nodeName !== 'P') { // Adaugă înaintea primului card, dacă există și nu e mesajul "nici o intrare"
                container.insertBefore(card, container.firstChild);
            } else { // Altfel, dacă e gol sau are mesajul "nici o intrare", curăță și adaugă
                if (container.firstChild && container.firstChild.nodeName === 'P') container.innerHTML = '';
                container.appendChild(card);
            }
        } else { // Update existing card's content (important for UI consistency after regeneration)
             card.querySelector('.journal-entry-content').innerHTML = entryData.continut.replace(/\n/g, '<br>');
             card.querySelector('.card-header').textContent = entryTitle; // Update title too if it changed
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, entryData.feedbackAI_history || []);
    }

    async function stergeIntrareJurnal(id, cardElement) {
        if (!confirm("Ștergi această intrare din jurnal și tot feedback-ul asociat?")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card')) { // Verifică dacă mai sunt carduri
                container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare în jurnal găsită.</p>`;
            }
        } catch (error) { console.error("Eroare ștergere intrare:", error); alert("Eroare la ștergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        const loadingP = container.querySelector("p");
        if (!loadingP || !loadingP.textContent.includes("Se încarcă")) { // Adaugă loadingP doar dacă nu există deja și nu sunt carduri
             if(!container.querySelector('.journal-card')) {
                container.innerHTML = '<p style="text-align:center; margin-top:20px;">Se încarcă intrările...</p>';
             }
        }


        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            const currentCards = {}; // Map for existing cards to avoid full re-render
            container.querySelectorAll('.journal-card').forEach(card => {
                currentCards[card.dataset.id] = card;
            });

            let hasNewData = false;
            const newDocs = [];

            querySnapshot.forEach((docSnap) => {
                newDocs.push({ id: docSnap.id, ...docSnap.data() });
                if (!currentCards[docSnap.id]) {
                    hasNewData = true;
                }
                delete currentCards[docSnap.id]; // Remove from map, remaining ones will be deleted
            });

            // Remove old cards that are no longer in Firestore
            Object.values(currentCards).forEach(oldCard => oldCard.remove());
            
            if (querySnapshot.empty) {
                if(!container.querySelector('.journal-card')) container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare. Începe prin a scrie una!</p>`;
            } else {
                 if (container.querySelector("p") && container.firstChild.nodeName === 'P') container.innerHTML = ''; // Clear "Se încarcă..." sau "Nicio intrare..."
                 newDocs.forEach(docData => afiseazaCardJurnal(docData)); // Will update or add
            }

        } catch (error) {
            console.error("Eroare încărcare jurnal:", error);
            if(!container.querySelector('.journal-card')) container.innerHTML = '<p style="text-align:center; color:red;">Eroare încărcare jurnal.</p>';
        }
    }
    </script>
    <style>
    /* Reset și Stiluri Generale */
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f4f7f9; /* Un gri mai deschis și modern */
        color: #333a40; /* Text mai închis pentru contrast */
        line-height: 1.6; font-size: 16px; /* O bază bună */
    }
    .journal-form-container {
        max-width: 760px; margin: 30px auto; background: #fff; padding: 30px 35px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.07); border-radius: 10px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.8em; margin-bottom: 10px; }
    h3 { font-size: 1.5em; margin-top: 40px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    /* Formular */
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d5dde5;
        transition: border-color 0.2s, box-shadow 0.2s;
    }
    textarea#journalContent { min-height: 200px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3px rgba(92, 133, 214, 0.15); outline: none;
    }
    
    /* Butoane Prompt Reflecție */
    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 12px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 10px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 8px; }
    button.prompt-button {
        background-color: #e7f0ff; color: #4a69bd; border: 1px solid #cddcff;
        padding: 6px 12px; font-size: 0.8em; font-weight: 500; border-radius: 16px;
        cursor: pointer; transition: all 0.2s; margin-top: 0; box-shadow: none;
    }
    button.prompt-button:hover { background-color: #d6e4ff; color: #3a539b; transform: translateY(-1px); }

    /* Buton Principal Salvare */
    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 15px; padding: 12px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 2px 5px rgba(92, 133, 214, 0.2);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); box-shadow: 0 3px 7px rgba(92, 133, 214, 0.25); }
    button#saveJournalEntryButton:disabled { background: #aebfD4 !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    /* Mesaj Confirmare */
    .confirmation-message { display: none; text-align: center; padding: 12px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e6f4ea; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdebea; color: #b32d21; border-color: #f8c6c1; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    /* Vizualizare Carduri */
    .card-view {display: flex; flex-direction: column; gap: 20px; max-width: 760px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.06); overflow: hidden; }
    .response-card .card-header {
        font-weight: 500; font-size: 1.05em; cursor: pointer; background: #fdfdfe;
        padding: 12px 20px; color: #3a4550; border-bottom: 1px solid #eaeff3;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header::after {content: '▼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: auto; transition: all 0.4s ease-in-out; } 
    .response-card.open .card-content { max-height: 5000px; padding: 18px 20px; }
    .response-card .card-content p {margin-bottom: 10px; color: #455058;}
    .response-card .card-content p.journal-entry-content { white-space: pre-wrap; font-size: 1em; line-height: 1.65;}
    .response-card .card-content p strong {font-weight: 600; color: #2c3840;}
    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 12px; font-size: 1em;
        border-bottom: 1px solid #e6eaee; padding-bottom: 6px;
    }
    .response-card h4:first-child {margin-top: 0;}
     .ai-feedback-history-container { margin-top: 8px; }
    .feedback-entry-card { background:#f8f9fc; padding:12px; border-left:3px solid #5c85d6; border-radius:6px; margin-bottom:12px; font-size:0.9em; line-height:1.55; }
    .feedback-timestamp { color:#606f7b; font-size:0.8em; margin-bottom:8px; font-style: italic; }
    .card-actions { text-align: right; margin-top: 18px; padding-top: 12px; border-top: 1px solid #eaeff3; display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }
    .card-actions button {
        padding: 7px 14px; font-size: 0.8em; font-weight:500; border-radius: 5px;
        transition: all 0.2s; margin-top: 0; /* Suprascrie margin-top general */
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border: 1px solid #f1c0ba;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; border-color: #c0392b;}
    button.regenerate-feedback-button { background-color:transparent; color: #228b22; border: 1px solid #b3d9b3;}
    button.regenerate-feedback-button:hover { background-color: #228b22; color: white; border-color: #228b22;}
    button.delete-last-feedback-button { background-color:transparent; color: #d39e00; border: 1px solid #ffe180;}
    button.delete-last-feedback-button:hover { background-color: #d39e00; color: white; border-color: #d39e00;}
    
    /* Responsive */
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto;}
        h2 {font-size: 1.6em;} h3 {font-size: 1.3em;}
        .card-actions {justify-content: center;}
        .card-actions button { flex-basis: calc(50% - 4px); /* Două pe rând, cu gap */}
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.4em;} h3 {font-size: 1.2em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 6px;}
        button.prompt-button {padding: 5px 10px; font-size: 0.75em;}
        button#saveJournalEntryButton {padding: 10px 18px; font-size: 1em;}
        .card-actions button { flex-basis: 100%; margin-left: 0;}
    }

    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -10px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            Spațiul tău pentru reflecție și integrare.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (Opțional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: Reflecții despre ziua de azi...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflecție (click pentru a insera):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <label for="journalContent" style="margin-top: 20px;">Intrarea ta în jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="12" placeholder="Scrie liber aici... sau alege un ghid de mai sus."></textarea>
            
            <button type="button" id="saveJournalEntryButton">Salvează și Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul Intrărilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Carduri -->
    </div>
    
</body>
</html>