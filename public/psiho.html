<!DOCTYPE html>
<html>
<head>
    <title>Fișă Monitorizare - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, deleteField, doc, getDoc, updateDoc, arrayUnion, query, where, setDoc, orderBy, limit } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    // Configurarea Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // Înlocuiește cu cheia ta reală dacă e diferită
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    // Inițializare Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // --- Configurare Gemini API ---
    // !!! ÎNLOCUIEȘTE CU CHEIA TA API GEMINI VALIDĂ ȘI ACTIVĂ !!!
    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- CHEIA TA API GEMINI
    const GEMINI_MODEL_NAME_FEEDBACK = "gemini-2.5-flash-preview-04-17";
    const GEMINI_MODEL_NAME_CHAT = "gemini-2.5-flash-preview-04-17";
    let genAI, geminiModelFeedback, geminiModelChat;

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") {
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_FEEDBACK });
            geminiModelChat = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_CHAT });
            console.log("SDK Gemini inițializat. Model Feedback:", GEMINI_MODEL_NAME_FEEDBACK, "Model Chat:", GEMINI_MODEL_NAME_CHAT);
        } catch (e) {
            console.error("Eroare critică la inițializarea SDK Gemini:", e);
            alert("Eroare la inițializarea serviciului AI. Verificați cheia API Gemini și configurația din Google Cloud. Funcționalitatea AI va fi limitată.");
            geminiModelFeedback = null; geminiModelChat = null;
        }
    } else  {
         // Added check for the specific placeholder you were using
        const isSpecificPlaceholder = GEMINI_API_KEY === "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; 
        console.warn(`Cheia API Gemini ${isSpecificPlaceholder ? "pare a fi un placeholder" : "nu este configurată/validă"} ('${GEMINI_API_KEY || "goală"}'). Te rog înlocuiește-o cu cheia ta API validă pentru a activa funcționalitatea AI.`);
        // alert(`Funcționalitatea AI este dezactivată. Te rog configurează o cheie API Gemini validă în codul sursă (variabila GEMINI_API_KEY). ${isSpecificPlaceholder ? "Ai folosit un placeholder." : ""}`);
        geminiModelFeedback = null; geminiModelChat = null;
    }


    let currentStep = 1;
    let totalSteps = 0;
    let dataAlreadyLoaded = false;

    // --- Variabile Globale pentru Chat ---
    let chatSession = null;
    const CHAT_HISTORY_DOC_ID_PREFIX = "chatHistory_";
    let isChatInitialized = false;


    window.onload = function () {
        totalSteps = document.querySelectorAll('.form-step').length;
        updateProgressBar();
        const urlParams = new URLSearchParams(window.location.search);
        const collabId = urlParams.get('collabId');

        if (!collabId) {
            onAuthStateChanged(auth, async (user) => {
                const toggleChatBtn = document.getElementById("toggleChatButton");
                const chatContainer = document.getElementById("chatContainer");

                if (user) {
                    console.log("Utilizator autentificat:", user.uid);
                    if (!dataAlreadyLoaded) {
                        populateTableData(user.uid);
                        loadTableData(user.uid);
                        dataAlreadyLoaded = true;
                    }
                    if(toggleChatBtn) toggleChatBtn.style.display = 'flex';
                } else {
                    console.log("Utilizator neautentificat, redirecționare...");
                    if(toggleChatBtn) toggleChatBtn.style.display = 'none';
                    if(chatContainer) chatContainer.style.display = 'none';
                    isChatInitialized = false;
                    chatSession = null;
                    window.location.href = "login.html";
                }
            });
        } else {
            const toggleChatBtn = document.getElementById("toggleChatButton");
            if(toggleChatBtn) toggleChatBtn.style.display = 'none';
            const chatContainer = document.getElementById("chatContainer");
            if(chatContainer) chatContainer.style.display = 'none';
        }

        document.getElementById("nextButton")?.addEventListener("click", nextStep);
        document.getElementById("prevButton")?.addEventListener("click", previousStep);
        document.getElementById("addButton")?.addEventListener("click", salveazaRaspunsSiGenereazaFeedback);
        document.getElementById("generateLinkButton")?.addEventListener("click", generateCollaborationLink);
        
        document.getElementById("toggleChatButton")?.addEventListener("click", handleToggleChat);
        document.getElementById("sendChatMessageButton")?.addEventListener("click", handleSendChatMessage);
        document.getElementById("chatInput")?.addEventListener("keypress", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); 
                handleSendChatMessage();
            }
        });
    };

    function nextStep() {
        if (currentStep < totalSteps) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep++;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function previousStep() {
        if (currentStep > 1) {
            document.getElementById(`step-${currentStep}`).classList.remove('form-step-active');
            currentStep--;
            document.getElementById(`step-${currentStep}`).classList.add('form-step-active');
            updateProgressBar();
        }
    }

    function updateProgressBar() {
        const progress = document.getElementById('progress');
        if(progress && totalSteps > 0) {
            const progressPercentage = (currentStep / totalSteps) * 100;
            progress.style.width = progressPercentage + '%';
        }
    }
    
    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) {
            console.error("Modelul Gemini specificat este invalid sau neinițializat.", modelToUse === geminiModelChat ? "(Model Chat)" : "(Model Feedback)");
            return "EROARE: Model AI neinițializat. Verifică cheia API.";
        }
        try {
            const requestPayload = {
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.7, ...generationConfigOptions } // Temperatură ajustată puțin
            };
            const result = await modelToUse.generateContent(requestPayload); 
            const response = result.response;

            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    console.warn("Gemini a oprit generarea prematur:", response.candidates[0].finishReason, response.candidates[0].safetyRatings);
                    // Decizi dacă vrei să incluzi un mesaj de eroare scurt sau doar răspunsul parțial.
                    // Momentan returnăm răspunsul parțial + o notificare scurtă
                    let partialResponse = response.candidates[0].content.parts[0].text;
                    // Adăugăm un marker subtil
                    if (partialResponse.length > 0) {
                         partialResponse += `\n\n(... generare oprită - ${response.candidates[0].finishReason})`;
                    } else {
                         partialResponse = `EROARE Gemini: Generare oprită (Motiv: ${response.candidates[0].finishReason}). Filtre de siguranță posibile active.`;
                    }
                    return partialResponse;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                console.error("Prompt blocat de Gemini:", response.promptFeedback.blockReasonDetail || response.promptFeedback.blockReason);
                 return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}). Revizuiește conținutul trimis.`;
            }
             else {
                console.error("Răspuns Gemini neașteptat sau gol:", JSON.stringify(response, null, 2));
                return "EROARE Gemini: Răspuns invalid sau gol de la API.";
            }
        } catch (error) {
            console.error("Eroare detaliată la callGeminiAPI:", error, error.stack);
            let errorMessage = `EROARE Gemini: ${error.message || "Eroare API necunoscută"}`;
            if (error.toString().toLowerCase().includes("api key not valid") || 
                (error.message && error.message.toLowerCase().includes("permission denied")) ||
                (error.message && error.message.toLowerCase().includes("api_key_invalid")) ||
                (error.status && error.status === 403)) {
                 errorMessage = "EROARE: Cheia API Gemini nu este validă sau nu are permisiuni. Verifică restricțiile din Google Cloud Console (HTTP Referrers, API Restrictions pentru Generative Language API) și cheia din cod. Asigură-te că domeniul " + window.location.hostname + " este permis.";
            } else if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429) || (error.toString().toLowerCase().includes("resource has been exhausted")) )) {
                errorMessage = "EROARE: Limita de utilizare (posibil gratuită) a API-ului Gemini (RPM/TPM sau alta) a fost depășită. Încearcă mai târziu.";
            } else if (error.message && (error.message.toLowerCase().includes("candidate.finish_reason") || error.message.toLowerCase().includes("safety_settings"))) {
                errorMessage = "EROARE Gemini: Generarea a fost oprită (posibil din motive de siguranță, conținut inadecvat, sau alte restricții ale modelului). Încercați să reformulați.";
            }  else if (error.toString().toLowerCase().includes("404") && error.toString().toLowerCase().includes("model not found")) {
                 errorMessage = `EROARE Gemini: Modelul specificat nu a fost găsit sau nu este suportat. Verifică numele modelului în cod.`;
            }
            return errorMessage;
         }
    }

    async function genereazaFeedbackCuGeminiDinFrontend(promptText) { 
        if (!geminiModelFeedback) {
            console.error("Modelul Gemini pentru feedback (geminiModelFeedback) nu este inițializat. Verifică cheia API.");
            return "EROARE: Configurare Gemini incorectă pentru feedback. Verifică dacă ai introdus corect cheia API în cod.";
        }
        try {
            console.log("Trimitere prompt către Gemini (feedback fișă, primele 100 caractere):", promptText.substring(0, 100) + "...");
            return await callGeminiAPI(promptText, geminiModelFeedback); 
        } catch (error) { 
            console.error("Eroare specifică în genereazaFeedbackCuGeminiDinFrontend:", error);
            return `EROARE internă la pregătirea cererii către Gemini (feedback): ${error.message}`;
        }
    }

    async function genereazaSiProceseazaFeedbackAI(rowData, docId) {
      const prompt = `
Analizează în profunzime această fișă completă de auto-reflecție. Utilizatorul a parcurs un exercițiu detaliat pentru a-și înțelege o situație specifică. Oferă feedback psihologic structurat, empatic și acționabil. Respectă cu strictețe formatul și ordinea secțiunilor de mai jos, folosind exact prefixele indicate.

**Datele Complete din Fișa de Reflecție a Utilizatorului:**

**Secțiunea 1: Explorarea Situației și a Nevoilor**
*   Care este situația?: ${rowData.situatie || 'N/A'}
*   Ce îmi trece prin minte (gânduri automate)?: ${rowData.ganduri || 'N/A'}
*   Cum mă face acel gând să mă simt (emoții)?: ${rowData.emotii || 'N/A'}
*   Ce mod este activ?: ${rowData.mod_activ || 'N/A'}
*   Ce comportament simți că adopți?: ${rowData.comportament || 'N/A'}
*   Care sunt nevoile tale mai profunde?: ${rowData.nevoi_profunde || 'N/A'}
*   Mă ajută comportamentul meu să îndeplinesc aceste nevoi?: ${rowData.ajutor_comportament || 'N/A'}
*   Cum ar gândi și cum s-ar comporta Adultul Sănătos (perspectiva utilizatorului)?: ${rowData.adult_sanatos || 'N/A'}

**Secțiunea 2: Analiza Gândurilor și a Percepțiilor**
*   Ce mă face să cred că gândul automat este adevărat?: ${rowData.dovezi_adevar || 'N/A'}
*   Ce mă face să cred că nu este adevărat?: ${rowData.dovezi_fals || 'N/A'}
*   Există o explicație alternativă?: ${rowData.explicatie_alternativa || 'N/A'}
*   Care este cel mai rău lucru care s-ar putea întâmpla?: ${rowData.scenariu_negativ || 'N/A'}
*   Care este cel mai bun lucru care s-ar putea întâmpla?: ${rowData.scenariu_optimist || 'N/A'}
*   Care este cel mai realist rezultat?: ${rowData.rezultat_realist || 'N/A'}
*   Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?: ${rowData.schimbare_gandire || 'N/A'}
*   Ce i-aș spune unui prieten dacă ar fi în aceeași situație?: ${rowData.sfat_prieten || 'N/A'}

**Secțiunea 3: Întrebări pentru Claritate și Reflecție Suplimentară**
*   Văd doar partea rea a lucrurilor?: ${rowData.partea_rea || 'N/A'}
*   Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?: ${rowData.responsabilitate || 'N/A'}
*   Mă condamn în baza unui singur eveniment?: ${rowData.condamnare || 'N/A'}
*   Privesc situația în termeni extremi (alb/negru)?: ${rowData.termeni_extremi || 'N/A'}
*   Exagerez situația?: ${rowData.exagerare || 'N/A'}
*   Există și alți factori responsabili?: ${rowData.factori_responsabili || 'N/A'}
*   Am sărit direct la concluzii?: ${rowData.concluzii || 'N/A'}
*   Îmi pun întrebări fără răspuns?: ${rowData.intrebari_fara_raspuns || 'N/A'}
*   Mă concentrez doar asupra slăbiciunilor mele?: ${rowData.slabiciuni || 'N/A'}
*   Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?: ${rowData.cum_ar_trebui || 'N/A'}
*   Mă aștept să fiu perfect?: ${rowData.perfectiune || 'N/A'}

**CERINȚE PENTRU FEEDBACK-UL AI (folosește prefixele EXACT așa cum sunt scrise):**

Feedback General:
EmpatieInițială: (1-2 propoziții empatice scurte, recunoscând efortul utilizatorului.)

Analiză Detaliată:
PuncteForteObservate: (Identifică 1-2 aspecte pozitive sau de auto-conștientizare.)
TiparePrincipale: (Descrie succint 1-3 tipare de gândire/emoționale/comportamentale centrale.)

Legătura Gând-Emoție-Comportament-Nevoie:
ConexiuniCheie: (Sintetizează legătura S-G-E-C-N bazată pe '${rowData.ganduri}', '${rowData.emotii}', '${rowData.comportament}', '${rowData.nevoi_profunde}'.)

Analiza Gândurilor Automate și Distorsiuni:
DistorsiuniIdentificate: (Identifică 2-4 distorsiuni principale. Pentru fiecare: Numele, Explicația, Exemplu din răspunsuri, Întrebare de contestare. Listează fiecare ca sub-punct precedat de '* '.)

Scheme și Moduri Cognitive:
SchemeActivate: (Identifică 1-3 scheme. Pentru fiecare: Numele, Cum se manifestă. Listează fiecare ca sub-punct precedat de '* '.)
ModuriImplicate: (Sugerează ce moduri Schema Therapy ar putea fi implicate.)

Rolul Adultului Sănătos:
PerspectivaAdultSănătos: (Comentează răspunsul utilizatorului '${rowData.adult_sanatos}'. Oferă descriere detaliată: interpretare situație, gânduri alternative, gestionare emoții, comportamente adaptative, contracarare scheme.)

Sugestii și Reflecții Finale:
ÎntrebareFinalăReflecție: (O întrebare generală puternică pentru învățare și aplicare viitoare.)
SugestieMicPas: (O sugestie concretă pentru un mic pas următor.)
ÎncurajareFinală: (1-2 propoziții de încurajare.)

Răspunde doar cu textul cerut conform structurii, fără introduceri, concluzii sau formatări suplimentare în afara celor specificate).`;

      let feedbackText = null;
      let modelFolosit = "N/A";

      if (geminiModelFeedback) {
        console.log("Solicitare feedback de la Gemini pentru fișă...");
        modelFolosit = `Gemini (${GEMINI_MODEL_NAME_FEEDBACK})`;
        feedbackText = await genereazaFeedbackCuGeminiDinFrontend(prompt);
      } else {
        console.warn("Gemini (geminiModelFeedback) nu este configurat. Nu se poate genera feedback AI pentru fișă.");
        return {
            paragraf: "Serviciul de feedback AI (Gemini) nu este configurat corect pentru fișe. Verifică cheia API și numele modelului.",
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "", 
            model: "Configurare Gemini Eronată", timestamp: new Date().toISOString(), error: true
        };
      }

      if (!feedbackText || (typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:"))) {
        console.warn(`Eroare de la ${modelFolosit} la generarea feedback-ului fișei:`, feedbackText);
        return { 
            paragraf: feedbackText || `Nu s-a putut obține feedback de la ${modelFolosit}.`,
            intrebare: "", recomandare: "", distorsiuni: "", scheme: "", adult_sanatos_eval: "",
            model: modelFolosit + " (Eroare API)", timestamp: new Date().toISOString(), error: true
        };
      }

      console.log("Răspuns brut de la Gemini (feedback fișă):\n---\n" + feedbackText + "\n---");

      const feedbackStructure = {
            empatie_initiala: /^EmpatieInițială:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            puncte_forte: /^PuncteForteObservate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            tipare_principale: /^TiparePrincipale:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            conexiuni_cheie: /^ConexiuniCheie:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            distorsiuni_identificate: /^DistorsiuniIdentificate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            scheme_activate: /^SchemeActivate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            moduri_implicate: /^ModuriImplicate:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            perspectiva_adult_sanatos: /^PerspectivaAdultSănătos:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            intrebare_finala_reflectie: /^ÎntrebareFinalăReflecție:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            sugestie_mic_pas: /^SugestieMicPas:\s*([\s\S]*?)(?=\n\S*?:|$)/im,
            incurajare_finala: /^ÎncurajareFinală:\s*([\s\S]*?$)/im,
        };
        
        const parsedFeedback = { model: modelFolosit, timestamp: new Date().toISOString(), error: false, error_parsing: false };
        let allParsingOk = true;

        for (const key in feedbackStructure) {
            const match = feedbackText.match(feedbackStructure[key]);
            if (match && match[1] && match[1].trim() !== "") {
                 parsedFeedback[key] = match[1].trim();
            } else {
                console.warn(`Feedback fișă: Nu s-a putut extrage sau este gol conținutul pentru: '${key}'`);
                parsedFeedback[key] = `(Secțiune neextrasă sau goală din răspunsul AI: ${key})`;
                allParsingOk = false;
            }
        }
        
        if (!allParsingOk) {
            console.warn("Feedback fișă: Cel puțin o secțiune nu a putut fi parsată corect din răspunsul AI. Verifică formatul răspunsului AI și regex-urile.");
            parsedFeedback.error_parsing = true;
        }

        if (docId) {
            const docRef = doc(db, "raspunsuri", docId);
            try {
                const updatePayload = { feedback_history: arrayUnion(parsedFeedback) };
                Object.keys(parsedFeedback).forEach(key => {
                    updatePayload[`feedback_${key}`] = parsedFeedback[key];
                });
                await updateDoc(docRef, updatePayload);
                console.log(`Feedback AI (nou, ${modelFolosit}) salvat pentru fișa ${docId}`);
            } catch (updateError) {
                console.error(`Eroare update Firestore feedback nou pentru fișa ${docId}:`, updateError);
            }
        }
        return parsedFeedback;
    }

    // --- CHAT FUNCTIONALITY ---

    // Funcție pentru a converti Markdown limitat și elemente speciale în HTML
    // Poate fi îmbunătățită cu o bibliotecă de parsare Markdown mai robustă
    function formatAiMessageContent(mdText) {
        let html = mdText;

        // Regex îmbunătățit pentru a identifica un titlu ce începe cu emoji
        // Presupune că titlul e pe o linie separată, începe cu emoji(uri),
        // poate include text, și se termină opțional cu emoji(uri).
        // Captură grup 1: întreg titlul inclusiv emoji, grup 2: doar textul din mijloc
        const titleRegex = /^(\p{Emoji_Presentation}|\p{Extended_Pictographic}|[\s\S])*?(\p{Emoji_Presentation}|\p{Extended_Pictographic})(.+?)(\p{Emoji_Presentation}|\p{Extended_Pictographic}).*?$/gmu;
         html = html.replace(titleRegex, '<span class="message-title">$1$3$4</span>\n\n'); // Înfășoară și adaugă două newline la sfârșitul spanului

        // Gestionare "Capsulă Teoretică" (parsarea strictă a ASCII ar fi mai robustă,
        // dar încercăm să identificăm block-uri similare, chiar dacă nu sunt perfect ASCII)
        // Aceasta presupune ca un bloc începe și se termină cu ceva care seamănă cu linii orizontale și colțuri
        // O abordare alternativă mult mai robustă este ca AI-ul să folosească tag-uri custom: [THEORY_BOX_START]...[THEORY_BOX_END]
        
        // Tentativă de a prinde un bloc care ar putea începe cu ┌, ┏, urmat de linii - și se termină la fel
        const theoryBoxRegexComplex = /(?:^[┌┏].*?[┐┓]\n)((?:.|\n)*?)(?:^[└┗].*?[┘┛]$)/gm; // Caută bloc între linii de chenar (simple/duble)

        html = html.replace(theoryBoxRegexComplex, (match, innerText) => {
            // Înlătură liniile de chenar
            let cleanedInner = innerText.replace(/^[┌┏└┗].*?[┐┓┘┛]$/gm, '').trim();
            
            let boxTitle = 'Capsulă'; 
            let boxConcept = '';
            
            // Caută Titlul și Conceptul în primele linii ale textului interior curățat
            const lines = cleanedInner.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            if (lines.length > 0) {
                let firstLine = lines[0];
                 // Încercăm să găsim un posibil titlu + emoji + posibil *text*: la început
                 const titleConceptMatch = firstLine.match(/^(\p{Emoji_Presentation}|\p{Extended_Pictographic}|[\s\S])*?(\p{Emoji_Presentation}|\p{Extended_Pictographic})(.+?)(?:\:\s*|\s*\*\s*)(.+)/u);

                if (titleConceptMatch && titleConceptMatch[3] && titleConceptMatch[4]) {
                     boxTitle = titleConceptMatch[3].trim();
                     boxConcept = `<em>${titleConceptMatch[4].trim()}</em>`;
                     lines.shift(); // Scoate prima linie, e deja procesată
                } else if (firstLine.includes(':') || firstLine.includes('*')) { // Orice altă linie care conține : sau * ar putea fi titlu/concept
                     const parts = firstLine.split(/[:*]/);
                     if (parts.length > 1) {
                        boxTitle = parts[0].trim();
                        boxConcept = `<em>${parts.slice(1).join(':').trim()}</em>`;
                         lines.shift();
                     } else { boxConcept = `<em>${firstLine}</em>`; lines.shift(); } // Doar o singura linie lunga, o facem concept
                }
            }

             // Reconstruiește corpul textului din liniile rămase
            const bodyText = lines.join('\n');


            // HTML generat pentru capsulă
            return `
<div class="theory-box">
    <span class="theory-box-title">${boxTitle}</span>
    ${boxConcept ? `<span class="theory-box-concept">${boxConcept}</span>` : ''}
    <p>${bodyText.replace(/\n/g, '<br>')}</p>
</div>\n\n`; // Adaugă newline la sfârșit pentru a separa de restul conținutului
        });
        // Consideră o alternativă dacă parsarea e prea grea
        // const simpleAsciiRegex = /^[┌┏].*?\n([\s\S]*?)\n^[└┗].*?$/gm; // Identifică block-uri cu bordură simplă la început/sfârșit de linie
        // html = html.replace(simpleAsciiRegex, '<div class="ascii-art-block">$1</div>\n\n');

        // Elimină newlines multiple lăsând maximum 2 pentru a le trata ca separatori de paragraf mai târziu
        html = html.replace(/\n\s*\n/gm, '\n\n').trim();


        // Acum gestionează restul formatării (paragrafe, bold/italic, newline-uri simple)
        const blocks = html.split('\n\n'); // Împarte în blocuri pe baza a 2+ newline-uri
        let finalHtml = '';

        blocks.forEach(block => {
            if (block.trim() === '') return;

            // Dacă block-ul este deja un element HTML complex generat mai sus, adaugă-l așa cum e.
            if (block.startsWith('<div class="theory-box">') || block.startsWith('<span class="message-title">')) {
                 finalHtml += block; // Acestea au deja structure corectă
            } else {
                 // Este un paragraf "normal", parsează bold/italic și \n
                 let paragraphContent = block;
                
                 // Re-aplică bold/italic DACA ele sunt singurele formatări Markdown rămase în acest block
                 paragraphContent = paragraphContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/__(.*?)__/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
                 paragraphContent = paragraphContent.replace(/_(.*?)_/g, '<em>$1</em>');

                 // Newline-uri simple devin <br> în interiorul unui paragraf
                 paragraphContent = paragraphContent.replace(/\n/g, '<br>');
                
                 // Înfășoară blocul într-un paragraf (excluzând dacă block-ul e deja un titlu/capsulă completă)
                 if (!block.startsWith('<span class="message-title">') && !block.startsWith('<div class="theory-box">')) {
                      finalHtml += `<p>${paragraphContent}</p>`;
                 } else {
                     // Dacă block-ul a fost deja marcat ca titlu sau capsulă completă,
                     // el conține deja HTML-ul și îl adăugăm direct (am putea reevalua structura if/else)
                      finalHtml += block; 
                 }
            }
        });

        return finalHtml;
    }


    function displayChatMessage(messageText, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) {
            console.error("Elementul chatMessages nu a fost găsit.");
            return;
        }
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");

        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        const classesToAdd = messageClass.split(' ');
        messageElement.classList.add(...classesToAdd);

        const contentContainer = document.createElement('div');
        contentContainer.classList.add('chat-message-content');

        if (role === "AI") {
            // Formatarea complexă a mesajelor AI folosind noua funcție
            contentContainer.innerHTML = formatAiMessageContent(messageText);
        } else { 
            // Mesaje user sau AI-error - text simplu, fără interpretare HTML
            contentContainer.textContent = messageText;
            contentContainer.style.whiteSpace = "pre-wrap"; // Păstrează newlines pentru user/error
        }

        messageElement.appendChild(contentContainer);
        messagesDiv.appendChild(messageElement);
        // Scroll automat la ultimul mesaj
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
         // Sincronize scroll într-un requestAnimationFrame pentru a se executa după actualizarea DOM-ului
        // requestAnimationFrame(() => {
        //     messagesDiv.scrollTop = messagesDiv.scrollHeight;
        // });
    }


    async function loadChatHistory(userId) {
        if (!userId) return [];
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists() && docSnap.data().messages && Array.isArray(docSnap.data().messages)) {
                const messages = docSnap.data().messages;
                messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                 console.log(`Încărcat ${messages.length} mesaje chat din istoric.`);
                return messages;
            }
            console.log("Niciun istoric chat găsit în Firestore.");
            return []; 
        } catch (error) {
            console.error("Eroare la încărcarea istoricului de chat din Firestore:", error);
            // Afișează un mesaj de eroare în chat la inițializare dacă încărcarea eșuează
            displayChatMessage("Eroare la încărcarea istoricului conversației.", "AI-error");
            return []; 
        }
    }
    
    async function saveChatMessage(userId, messageObject) {
        if (!userId || !messageObject || typeof messageObject.content !== 'string' || messageObject.content.trim() === "") {
            console.warn("Tentativă de salvare a unui mesaj invalid sau gol:", messageObject);
            return;
        }
        const historyDocRef = doc(db, "chatHistories", CHAT_HISTORY_DOC_ID_PREFIX + userId);
        try {
            const docSnap = await getDoc(historyDocRef);
            if (docSnap.exists()) {
                 // Previne adăugarea de duplicate dacă aceeași intrare din DB e reîncărcată rapid
                const messages = docSnap.data().messages;
                 // Simplă verificare de unicitate pe baza conținutului și a timestamp-ului recent
                 const isDuplicate = messages.some(msg => 
                    msg.content === messageObject.content && 
                    Math.abs(new Date(msg.timestamp).getTime() - new Date(messageObject.timestamp).getTime()) < 1000 // Același mesaj în 1 sec
                 );

                if (!isDuplicate) {
                     await updateDoc(historyDocRef, {
                        messages: arrayUnion(messageObject) 
                    });
                     console.log("Mesaj de chat salvat pentru utilizatorul:", userId);
                } else {
                    console.log("Mesaj duplicat, nu a fost salvat:", messageObject);
                }

            } else {
                await setDoc(historyDocRef, {
                    messages: [messageObject]
                });
                 console.log("Document nou istoric chat creat și mesaj salvat pentru utilizatorul:", userId);
            }
           
        } catch (error) {
            console.error("Eroare la salvarea mesajului de chat în Firestore:", error);
             // Nu afișăm aici mesaj în UI, ar crea o buclă.
        }
    }
    
    async function initializeAndStartChatSession(userId) {
        const chatStatus = document.getElementById("chatStatus");
        const sendButton = document.getElementById("sendChatMessageButton");
        const messagesDiv = document.getElementById("chatMessages");

        if (sendButton) sendButton.disabled = true;
        if (chatStatus) chatStatus.textContent = "Inițializare chat AI...";
        if (messagesDiv) messagesDiv.innerHTML = ''; 

        if (!geminiModelChat) {
            if (chatStatus) chatStatus.textContent = "EROARE: Modelul AI Chat nu este disponibil.";
            console.error("initializeAndStartChatSession: geminiModelChat nu este inițializat. Verifică cheia API GEMINI.");
            displayChatMessage("Serviciul de chat AI nu este disponibil momentan. Te rog verifică configurația (Cheie API Gemini neconfigurată/invalidă).", "AI-error");
             if (sendButton) sendButton.disabled = true; // Păstrează butonul dezactivat
            return null;
        }
        
        isChatInitialized = false; 

        let initialContextSummary = "REZUMAT DIN FIȘELE ANTERIOARE (ULTIMELE 3):\n";
        try {
            if (userId) {
                 // Sortează după data, și secundar după id pentru o ordine deterministică în caz de date identice
                const q = query(collection(db, "raspunsuri"), where("ownerUid", "==", userId), orderBy("date", "desc"), orderBy("__name__"), limit(3)); 
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    querySnapshot.forEach(doc => {
                        const data = doc.data();
                        const entryDate = data.date || (data.timestamp ? new Date(data.timestamp.seconds * 1000).toLocaleDateString("ro-RO") : 'N/A');
                        initialContextSummary += ` - Fișă (${entryDate}): Situația - ${(data.situatie || "").substring(0, 70)}...; Gânduri - ${(data.ganduri || "").substring(0, 70)}...; Emoții - ${data.emotii || 'N/A'}.\n`;
                    });
                     if(querySnapshot.docs.length < 3) initialContextSummary += `\n(Au fost găsite doar ${querySnapshot.docs.length} fișe recente.)\n`;

                } else { initialContextSummary += "Nicio fișă de monitorizare recentă găsită.\n"; }
            }
        } catch(e) { 
            console.error("Eroare la încărcarea contextului din fișe pentru chat (Verifică Indexul Firestore!):", e); 
            initialContextSummary += `\nEroare la încărcarea contextului din fișe (${e.message}).`;
        }

        const systemInstructionText =
`# ROL PRINCIPAL ȘI PERSONA:
Tu ești PsihoGPT (alias Dr. Janet/Damian – o voce calmă, empatică și înțeleaptă, combinând cunoștințele teoretice cu ghidajul practic). Ești un asistent AI avansat pentru auto-reflecție și explorare psihologică ghidată, specializat în Terapie Cognitiv-Comportamentală (TCC), Terapia Schemelor, Terapia prin Acceptare și Angajament (ACT), principii ale Terapiei Dialectic-Comportamentale (DBT) și ale terapiei afirmative gay. Te adresezi utilizatorului cu "tu". Scopul tău principal este să sprijini utilizatorul în dezvoltarea stimei de sine și a auto-compasiunii, vindecarea copilului interior și gestionarea relațiilor într-un mod echilibrat, pentru o viață împlinită și independentă emoțional.

# MISIUNE ȘI ABORDARE TERAPEUTICĂ:
Misiunea ta este să ajuți utilizatorul să exploreze gânduri, emoții, comportamente și nevoi profunde. Vei ghida utilizatorul să:
1.  Identifice și să înțeleagă **Schemele Maladaptative Timpurii** (explică pe scurt conceptul la nevoie, folosind metafore sau analogii simple). Fii atent la posibile manifestări ale schemelor de Abandon/Instabilitate, Defectivitate/Rușine, Deprivare Emoțională, Eșec (poți face o mențiune scurtă la început că acestea sunt arii comune de explorare, dar nu te baza pe scoruri specifice din prompt).
2.  Exploreze **Stilul de Atașament** (ex. anxios-evitant) și impactul său asupra relațiilor.
3.  Abordeze teme specifice precum **homofobia internalizată** sau **stresul minoritar**, utilizând principii ale **terapiei afirmative gay**. Aici, adoptă un ton validant și knowledgeable. Poți parafraza idei cheie din lucrări relevante *fără a cita explicit* (ex: "Unele perspective din terapia afirmativă arată că...").
4.  Examineze și să îmbunătățească **stima de sine** și **autocompasiunea**. Introdu noțiunea de autocompasiune (bazat pe Kristin Neff) ca pe o tehnică, nu ca pe o trăsătură.
5.  Dezvolte **limite sănătoase** și asertivitate.
6.  Identifice și să transforme posibile **tipare de mentalitate de victimă**, cultivând **agenția personală**.
7.  Lucreze cu **experiențele trecute** și **copilul interior** (vezi lucrările despre lucrul cu copilul interior).
8.  Să formuleze **obiective SMART** mici și realizabile. Ghidează procesul, nu le oferi gata făcute.

# PRINCIPII DE INTERACȚIUNE ȘI COMUNICARE:
  **Empatie și Căldură Constantă:** Prioritizează conexiunea emoțională și validarea. Tonul este suportiv, cald, non-judicativ și uman (chiar dacă ești AI).
  **Dialog Reflexiv:** Pune întrebări deschise, de sondare și clarificare care îl ajută pe utilizator să exploreze propria experiență. Evită interogatoriul rapid. Oferă spațiu pentru pauze și reflecție.
  **Validare Activa:** Validează *ceea ce* simte și gândește utilizatorul, nu *dacă* e corect. "Înțeleg că în acel moment te-ai simțit X, pare dificil.", "E firesc să ai acest gând dat fiind Y".
  **Psihoeducație Aplicată:** Introduce concepte psihologice *doar când sunt relevante pentru ceea ce a relatat utilizatorul*. Explică-le concis, folosind metafore, analogii și exemple practice. Pune-i întrebări de conectare: "Cum ți se pare acest concept legat de ce trăiești tu acum?", "Recunoști acest tipar în experiența ta?". *Folosește text italic* pentru conceptele cheie.
  **Non-Directivitate cu Direcție:** Nu da sfaturi despre *ce să facă*. Ghidează-l *cum să gândească despre*, *cum să exploreze emoția*, *cum să vadă alte perspective*. Sprijină-l să-și găsească *propriile* răspunsuri și soluții (Agenția Personală). NU face diagnostice sau evaluări clinice. NU interveni în situații de criză acută – reamintește-i discret că pentru acestea e nevoie de suport uman profesionist.
  **Utilizarea Contextului Din Fișe:** Integrează subtil în conversație elemente REZUMATULUI FIȘELOR (situatie, gânduri, emoții) ca o bază de înțelegere, NU ca un script rigid. Menționează cu discreție (ex: "Mă gândeam acum, în legătură cu ce povesteai despre [tema X], la situația din fișa [data fisei] când ai simțit [emoție Y]. Vezi vreo legătură?").
  **Format Structurat:** Generează text în blocuri (paragrafe) folosind *cel puțin două newline-uri* între ele pentru o bună lizibilitate. Utilizează **bold** ("**text**"" sau "__text__") și *italic* ("*text*"" sau "_text_") pentru a evidenția idei cheie și concepte (Markdown simplu).
  **Formatarea Titlului Mesajului:** Începe fiecare mesaj AI cu un titlu scurt, de reflexie sau care definește tema, formatat ca un titlu mic (poți folosi emoji la început/sfârșit ca indicator vizual, de ex: '✨ Explorăm Rezistența la Schimbare ✨'). **Folosește emoji consistent la începutul și sfârșitul liniei titlu pentru a ajuta la parsare!** (Sugestie: Pune întotdeauna 1-2 emoji la început și 1-2 la sfârșitul liniei titlu, pe linia goală după)
  **Formatarea Capsulei Teoretice (Dacă este necesară și relevantă):** Prezintă informații concise, punctuale, sub forma unui block. **Folosește o marcă de început și de sfârșit clară** pe care o pot identifica ușor (ex: '[CONCEPT_BOX]\nTITLE: Titlu Concept\nTEXT: Explicația...[\n/CONCEPT_BOX]' sau pur și simplu un format structurat pe linii cu o bordură ASCII *consistentă*. *Pentru simplitate în JS, cea mai bună metodă ar fi: AI-ul să deseneze o bordură ASCII clară și CONSISTENTĂ în jurul blocului.* Regex-ul din JS va încerca să o prindă. Format: Linii goale înainte, apoi linia de top, apoi conținut (cu \n între ele), apoi linia de jos, linii goale după.
  **Check-in Meta-Terapeutic (la final de Etapă sau Cerere):** Întreabă despre *proces* - ritm, format, utilitate. Include un mesaj de final la sfârșitul ședinței când utilizatorul semnalează asta.
  **Ritmul Conversației:** Oferă *un singur mesaj complex* ca răspuns, chiar dacă include mai multe paragrafe sau o capsulă. Așteaptă input-ul utilizatorului înainte de a trimite următorul răspuns terapeutic complet. Evită ping-pong-ul rapid cu o propoziție.
 **Elemente Estetice:** Folosește *emoji expresive* (din lista (✨, 🌟, 💡, 🔍, 🛡️, 🌱, 🏳️‍🌈, 🙏)) și *text italic* și **bold** conform instrucțiunilor.

# CUNOȘTINȚE SPECIFICE ȘI RESURSE (Referențial Interioar):
Nu reproduce lista explicit. Acestea sunt informațiile din "biblioteca ta mentală". Folosește conceptele, nu cita literal (decât la cerere expresă, dacă e cazul).
*   **Scheme (YSQ, SMI):** Manifestări: teama de abandon/respingere, sentiment de inferioritate, gol interior, sacrificiu, nevoia de aprobare.
*   **Atasament (ECR-R):** Impact în relații: anxietate, evitare.
*   **Terapie Afirmativă:** Stres minoritar, internalizare stigmat, importanța auto-acceptării, sprijin comunitar.
*   **Autori Cheie:** Integrează principiile (ACT, DBT, Schema Therapy) inspirate de acești autori în răspunsuri.

# PRIORITATE:
Alianța terapeutică (siguranță, validare, empatie) > Explorare ghidată > Informație psihoeducațională > Structura etapei > Formatare estetică.


Context din ultimele fișe completate de utilizator (folosește-l cu discreție și inteligență):
${initialContextSummary}---`;

        const aiGreeting = "Salut! Sunt PsihoGPT, asistentul tău AI pentru reflecție. Cum te simți astăzi și despre ce ai vrea să vorbim sau să reflectăm împreună?";

        let historyForGeminiInitialization = [];
        // Adaugă instrucțiunea de sistem și salutul în istoricul trimis către API
        // Trimitem sistemul ca 'user' conform API guidance pt roluri în history
        historyForGeminiInitialization.push({ role: "user", parts: [{ text: systemInstructionText }] }); 
        historyForGeminiInitialization.push({ role: "model", parts: [{ text: aiGreeting }] });      

        let loadedHistoryFromDB = await loadChatHistory(userId);
        
        const historicalMessagesForAPI = loadedHistoryFromDB.map(msg => ({
            role: msg.role, // "user" sau "model" din DB
            parts: [{ text: msg.content || "" }]
        })).filter(msg => msg.parts[0].text.trim() !== ""); 

        // Construiește istoricul pentru API: sistem -> salut AI -> istoric din DB (user, model, user, model...)
        // Notă: Instrucțiunile de sistem extinse la începutul istoricului consumă tokeni semnificativ.
        // Pentru conversații lungi, s-ar putea dori optimizări aici.
        historyForGeminiInitialization = historyForGeminiInitialization.concat(historicalMessagesForAPI);

        try {
            chatSession = geminiModelChat.startChat({ // Va eșua aici dacă geminiModelChat e null
                history: historyForGeminiInitialization,
                generationConfig: { 
                    temperature: 0.7, // Un echilibru bun
                    maxOutputTokens: 800, // Adaugă o limită per răspuns dacă e cazul
                }
            });
            console.log("Sesiune chat Gemini inițializată cu succes. Istoric trimis la API:", historyForGeminiInitialization.length, "mesaje.");
            if (chatStatus) chatStatus.textContent = "Chat pregătit.";
            
             // Afișează salutul AI-ului și istoricul CONȚINUT din DB.
             // Salutul inițial a fost trimis deja la API.
             messagesDiv.innerHTML = ''; // Asigură că e gol înainte de a adăuga

             // Re-afișează salutul inițial care a fost trimis la API (face parte din 'istoric')
             displayChatMessage(aiGreeting, "AI");

            // Apoi afișează istoricul propriu-zis
            loadedHistoryFromDB.forEach(msg => {
                 displayChatMessage(msg.content, msg.role === "model" ? "AI" : "user");
            });

            isChatInitialized = true;
            if (sendButton) sendButton.disabled = false;

        } catch(initError) {
            console.error("Eroare la inițializarea sesiunii de chat Gemini (startChat):", initError, initError.stack);
            if (chatStatus) chatStatus.textContent = "Eroare AI Chat.";
            displayChatMessage("A apărut o problemă tehnică la pornirea chat-ului. Vă rugăm să închideți și redeschideți fereastra de chat.", "AI-error");
            isChatInitialized = false;
            chatSession = null;
            if (sendButton) sendButton.disabled = true; 
            return null;
        }
        return chatSession;
    }


    // Funcție pentru a converti Markdown limitat și elemente speciale în HTML
    function formatAiMessageContent(mdText) {
        let html = mdText;

        // PAS 1: Detectează și marchează blocuri specifice (capsula teoretică)
        // Presupunem un format simplificat de tip tag-uri sau chenare ASCII clare
        // Implementare bazată pe o tentativă de parsare ASCII:

        // Caută block-uri înconjurate de ceva ce ar putea fi bordură ASCII (multiple - sau =, etc.)
        // This regex attempts to capture text between lines starting with corner chars like ┌, ┏, └, ┗ and content lines between.
        // It's very specific to the exact ASCII generated format. If AI output varies, this breaks.
        // It also doesn't perfectly handle nested structures or complex cases.
        // A dedicated markdown parser library is much more robust.
        
        // Adjust the regex to better capture the sample ASCII structure provided earlier.
        // Sample structure:
        // ┌───────────────┐
        // |   *Capsulă Teoretică* ✨   |
        // | *Defuzionarea Cognitivă (ACT):* |
        // | Abilitatea de a te distanța... |
        // └───────────────┘

        const complexAsciiBoxRegex = /^[┌┏].*?\n((?:.|\n)*?)\n^[└┗].*?$/gm; 

        html = html.replace(complexAsciiBoxRegex, (match, innerContent) => {
            let cleanedInner = innerContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let boxTitle = 'Info'; 
            let boxConcept = '';
            let bodyText = '';

            // Caută titlul pe prima linie validă
            if (cleanedInner.length > 0) {
                 const titleMatch = cleanedInner[0].match(/\|\s*(.*?)\s*(\p{Emoji_Presentation}|\p{Extended_Pictographic})*\s*\|/u); // Ex: "|   *Capsulă Teoretică* ✨   |"
                if (titleMatch && titleMatch[1]) {
                    boxTitle = titleMatch[1].replace(/\*/g, '').trim(); 
                    cleanedInner.shift(); // Remove the processed title line
                } else {
                     boxTitle = cleanedInner[0]; // Prima linie ca titlu dacă formatul | Title | nu e găsit
                     cleanedInner.shift();
                }
            }
            
            // Caută conceptul pe a doua linie validă sau similar
             if (cleanedInner.length > 0) {
                const conceptLine = cleanedInner[0];
                 if (conceptLine.includes(':') || conceptLine.includes('*') || conceptLine.includes('_')) {
                     boxConcept = `<em>${conceptLine.replace(/[:\*_]/g, '').trim()}:</em>`; // Simplificare
                     cleanedInner.shift();
                } else {
                    // Dacă a doua linie nu pare un concept, poate prima a fost ambele
                     if (boxConcept === '') boxConcept = `<em>${boxTitle}</em>`;
                     boxTitle = 'Info'; // Reset title to default if it might have included the concept
                 }
            }

            // Restul liniilor sunt corpul textului
            bodyText = cleanedInner.join('\n');

            // Generare HTML pentru teoria box
            return `
<div class="theory-box">
    <span class="theory-box-title">${boxTitle}</span>
    ${boxConcept ? `<span class="theory-box-concept">${boxConcept}</span>` : ''}
    <p>${bodyText.replace(/\n/g, '<br>')}</p>
</div>\n\n`;
        });

        // PAS 2: Convertește restul Markdown-ului (simplu) în HTML
        
        // Titlu Mesaj AI (folosind regex-ul care caută emoji la început și sfârșit pe o linie,
        // acest lucru trebuie să se întâmple înainte de a împărți în paragrafe dacă titlul e prima linie)
         // Acum aplicăm regex-ul pentru titlu pe `html` modificat, presupunând că titlul a rămas pe linia lui.
        const messageTitleRegex = /^((\p{Emoji_Presentation}|\p{Extended_Pictographic}).+?(\p{Emoji_Presentation}|\p{Extended_Pictographic}))$/u; // Simplified regex

        html = html.replace(messageTitleRegex, '<span class="message-title">$1</span>\n\n'); // Replace whole line with title span + 2 newlines


        // Split în blocuri (paragrafe sau blocuri speciale deja generate)
        const blocks = html.split('\n\n').filter(block => block.trim() !== '');
        let finalHtml = '';

        blocks.forEach(block => {
             // Dacă block-ul a fost deja convertit într-un element complex (theory-box, title)
            if (block.startsWith('<div class="theory-box">') || block.startsWith('<span class="message-title">')) {
                finalHtml += block;
            } else {
                 // Alt text, tratează-l ca paragraf, inclusiv bold/italic și newlines
                 let paragraphContent = block;
                
                 // Bold/Italic (re-aplicăm dacă nu au fost în interiorul theory-box-ului care s-a parsat)
                 paragraphContent = paragraphContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/__(.*?)__/g, '<strong>$1</strong>');
                 paragraphContent = paragraphContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
                 paragraphContent = paragraphContent.replace(/_(.*?)_/g, '<em>$1</em>');

                 // Newline-uri simple devin <br>
                 paragraphContent = paragraphContent.replace(/\n/g, '<br>');
                
                 finalHtml += `<p>${paragraphContent}</p>`;
            }
        });

        // Întoarce HTML-ul gata de inserat
        return finalHtml;
    }


    function displayChatMessage(messageText, role) {
        const messagesDiv = document.getElementById("chatMessages");
        if (!messagesDiv) {
            console.error("Elementul chatMessages nu a fost găsit.");
            return;
        }
        const messageElement = document.createElement("div");
        messageElement.classList.add("chat-message");

        const messageClass = role === "user" ? "user-message" : (role === "AI-error" ? "ai-message ai-error" : "ai-message");
        const classesToAdd = messageClass.split(' ');
        messageElement.classList.add(...classesToAdd);

        const contentContainer = document.createElement('div');
        contentContainer.classList.add('chat-message-content');

        if (role === "AI") {
            // Procesează și formatează conținutul AI
            // În cazul în care AI-ul generează conținut pur text sau cu Markdown simplu,
            // sau încearcă să facă ASCII, funcția formatAiMessageContent
            // va încerca să îl transforme în HTML.
            // Dacă funcția formatAiMessageContent returnează HTML valid (chiar și un singur <p>), folosește innerHTML
            // Altfel (excepție neașteptată din funcția de parsare, deși acum ar trebui să returneze HTML mereu)
            // Consideră fallback la textContent pentru siguranță absolută, deși scopul e formatarea.

             // Utilizăm innerHTML pentru mesajele AI formatate,
             // presupunând că formatAiMessageContent face un minim de curățare.
            contentContainer.innerHTML = formatAiMessageContent(messageText);
            
             // Asigură că cel puțin un element bloc există dacă messageText nu e gol,
             // pentru a menține structura .ai-message > .chat-message-content > ...
             if (contentContainer.innerHTML.trim() === '' && messageText.trim() !== '') {
                contentContainer.textContent = messageText; // Fallback la text simplu
                 contentContainer.style.whiteSpace = "pre-wrap"; // Păstrează formatarea simplă
             }


        } else { 
            // Mesaje user sau AI-error - text simplu, fără interpretare HTML
            // TextContent este mai sigur pentru conținutul generat de utilizator.
            contentContainer.textContent = messageText;
            contentContainer.style.whiteSpace = "pre-wrap"; // Păstrează newlines
        }

        messageElement.appendChild(contentContainer);
        messagesDiv.appendChild(messageElement);
        
        // Scroll automat într-un RequestAnimationFrame
        requestAnimationFrame(() => {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
    }


    async function handleSendChatMessage() {
        const chatInput = document.getElementById("chatInput");
        const sendButton = document.getElementById("sendChatMessageButton");
        const chatStatus = document.getElementById("chatStatus");

        if (!chatInput || !sendButton || !chatStatus) return;

        const messageText = chatInput.value.trim();
        if (messageText === "") return;

        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesară pentru a folosi chat-ul.");
            window.location.href = "login.html";
            return;
        }

        // Afișează mesajul utilizatorului IMEDIAT
        displayChatMessage(messageText, "user");
        
        // Salvează mesajul utilizatorului (poți aștepta, sau nu, decizi cum vrei feedback UI)
        const userMessageForDB = { role: "user", content: messageText, timestamp: new Date().toISOString() };
        // await saveChatMessage(user.uid, userMessageForDB); // Salvezi *înainte* de trimitere AI
        saveChatMessage(user.uid, userMessageForDB).catch(err => console.error("Save user message failed:", err)); // Salvare async, nu blochează UI

        chatInput.value = ""; 
        sendButton.disabled = true;
        chatStatus.textContent = "PsihoGPT analizează...";

        if (!chatSession || !isChatInitialized) {
            console.log("Sesiunea de chat nu este (re)inițializată, se încearcă acum...");
            chatSession = await initializeAndStartChatSession(user.uid); 
            if(!chatSession) { 
                chatStatus.textContent = "Eroare AI Chat.";
                sendButton.disabled = true; 
                // displayChatMessage("Nu s-a putut (re)stabili conexiunea cu AI-ul.", "AI-error");
                return; 
            }
        }
        
        try {
            const result = await chatSession.sendMessage(messageText); 
            const response = result.response;
            const aiResponseText = response?.text() || "Nu am putut genera un răspuns momentan. Încercați din nou.";

             // Logica pentru finishReason - arată un mesaj subtil de eroare după text
             if (response?.candidates?.[0]?.finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                 console.warn("Răspuns Gemini (chat) oprit prematur:", response.candidates?.[0]?.finishReason, response.candidates?.[0]?.safetyRatings);
                 displayChatMessage(aiResponseText + `\n\n(Notă: Generare oprită: ${response.candidates[0].finishReason}. Vă rugăm să reformulați.)`, "AI-error"); // Foloseste AI-error pentru notificare
             } else if (response?.promptFeedback?.blockReason) { // Prompt blocat COMPLET înainte de răspuns
                 console.error("Prompt blocat de Gemini:", response.promptFeedback.blockReason);
                 displayChatMessage(`Mesajul a fost blocat, posibil din motive de siguranță (${response.promptFeedback.blockReason}). Vă rugăm să reformulați.`, "AI-error");
             } else {
                displayChatMessage(aiResponseText, "AI");
             }


            const aiMessageForDB = { role: "model", content: aiResponseText, timestamp: new Date().toISOString() };
             // await saveChatMessage(user.uid, aiMessageForDB); // Salvezi răspunsul AI
             saveChatMessage(user.uid, aiMessageForDB).catch(err => console.error("Save AI message failed:", err)); // Salvare async
             
             chatStatus.textContent = "Chat pregătit.";

        } catch (error) {
            console.error("Eroare la trimiterea mesajului către Gemini sau procesarea răspunsului:", error, error.stack);
            chatStatus.textContent = "Eroare în comunicarea cu AI.";
            let displayError = "Ne pare rău, a apărut o eroare. Vă rugăm încercați din nou.";
             if (error.message && (error.message.toLowerCase().includes("quota") || (error.status && error.status === 429))) {
                 displayError = "Limita de utilizare a serviciului AI a fost atinsă. Vă rugăm încercați mai târziu.";
            } else if (error.message && (error.message.toLowerCase().includes("safety") || (error.message.toLowerCase().includes("blocked")) )) {
                 displayError = "Mesajul sau răspunsul AI a fost blocat, posibil din motive de siguranță. Încercați să reformulați.";
            } else if (error.message && error.message.toLowerCase().includes("api key not valid")){
                displayError = "Cheia API pentru serviciul AI nu este validă. Contactați administratorul."
            }
            displayChatMessage(displayError, "AI-error");
            isChatInitialized = false; 
            chatSession = null;
        } finally {
            if(geminiModelChat && isChatInitialized) { 
                 sendButton.disabled = false;
            } else {
                 sendButton.disabled = true; 
                 chatStatus.textContent = "Chat AI indisponibil.";
                 //displayChatMessage("Chat AI indisponibil.", "AI-error"); // Afișează și în chat
            }
            chatInput.focus();
        }
    }


    async function handleToggleChat() {
        const user = auth.currentUser;
        if (!user) {
            alert("Autentificarea este necesară pentru a accesa chat-ul.");
            window.location.href = "login.html";
            return;
        }

        const chatContainer = document.getElementById("chatContainer");
        const toggleButton = document.getElementById("toggleChatButton");
        const sendButton = document.getElementById("sendChatMessageButton");
        if (!chatContainer || !toggleButton) return;

        if (chatContainer.style.display === "none" || chatContainer.style.display === "") {
            chatContainer.style.display = "flex";
            toggleButton.innerHTML = "➖"; 
            // Resetăm starea inițializată dacă nu avem o sesiune validă
            if (!isChatInitialized || !chatSession || !geminiModelChat) { 
                 isChatInitialized = false;
                 chatSession = null; // Asigură resetarea
            }
            
            // Inițializează sesiunea dacă nu este deja sau dacă s-a resetat
            if (!isChatInitialized) {
                console.log("Tentativă inițializare chat session...");
                const sessionOK = await initializeAndStartChatSession(user.uid);
                 if (sessionOK && sendButton) {
                    sendButton.disabled = false; // Activează dacă inițializarea a reușit
                 } else if (sendButton) {
                    sendButton.disabled = true; // Păstrează dezactivat dacă a eșuat
                 }
            } else if (sendButton && geminiModelChat) {
                 sendButton.disabled = false; // Activează dacă era deja inițializat și modelul e OK
                 console.log("Chat session deja inițializat, se afișează.");
            } else if (sendButton) {
                sendButton.disabled = true; // Dezactivat dacă modelul lipsește
            }

            // Poziționează și focus inputul, cu un mic delay pentru animatie/afisare
             requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                     document.getElementById("chatInput")?.focus();
                });
             });

        } else {
            chatContainer.style.display = "none";
            toggleButton.innerHTML = "💬";
            // Nu resetăm isChatInitialized sau chatSession AICI
            // Pentru ca la redeschidere rapidă să folosească sesiunea existentă.
            // Resetarea se face în initializeAndStartChatSession dacă dă eroare
            // sau la logout.
        }
    }

    // ... restul codului JavaScript ...
    </script>
    <style>
        /* Stiluri generale și pentru form - PĂSTRATE */
        body {font-family: 'Roboto', 'Montserrat', sans-serif; margin: 0; padding: 20px; background: linear-gradient(to right, #ece9e6, #ffffff); color: #333; box-sizing: border-box;}
        .form-container {max-width: 900px; margin: 20px auto; background: #fff; padding: 30px; box-shadow: 0 16px 24px rgba(0,0,0,0.2); border-radius: 15px; border: 3px solid #87CEFA; transition: transform 0.3s ease;}
        .form-container:hover {transform: scale(1.01);}
        .progress-bar {width: 100%; background-color: #f3f3f3; border-radius: 25px; overflow: hidden; margin-bottom: 20px;}
        .progress {height: 20px; width: 0; background-color: #87CEFA; transition: width 0.4s ease;}
        .question-card {margin-bottom: 20px; padding: 20px; background: #fff; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: all 0.3s;}
        .question-card:hover {box-shadow: 0 6px 15px rgba(0,0,0,0.15);}
        .question-card h3 {font-weight: 700; font-size: 1.2em; margin-top: 0; margin-bottom: 10px;}
        .question-card p {font-weight: 300; font-size: 0.95em; margin-bottom: 15px; color: #555; line-height: 1.6;}
        /* Textarea specifică formularului (nu afectează textarea din chat) */
        .form-container textarea {width: calc(100% - 22px); padding: 10px; font-size: 16px; border-radius: 8px; border: 1px solid #ccc; resize: vertical; min-height: 60px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: border-color 0.3s;}
        .form-container textarea:focus {border-color: #87CEFA; box-shadow: 0 2px 8px rgba(135,206,250,0.5); outline: none;}
        
        input[type="submit"], button {margin-top: 20px; padding: 12px 25px; font-size: 18px; font-weight: 500; background: linear-gradient(to right, #87CEFA, #6bb9e7); color: white; border: none; border-radius: 8px; cursor: pointer; transition: background 0.3s, transform 0.2s;}
        input[type="submit"]:hover, button:hover {background: linear-gradient(to right, #6bb9e7, #4A90E2); transform: translateY(-2px);}
        button:disabled { background: #ccc !important; color: #666 !important; cursor: not-allowed !important; transform: translateY(0) !important; }

        .form-step {display: none;}
        .form-step-active {display: block; animation: fadeIn 0.7s ease-in-out;}
        @keyframes fadeIn { 0% {opacity: 0; transform: translateY(10px);} 100% {opacity: 1; transform: translateY(0);} }
        .step-navigation {text-align: center; margin-top: 20px;}
        .step-navigation button {margin: 0 10px;}

        /* Stiluri pentru mesaje confirmare/eroare - PĂSTRATE */
         .confirmation-message {
            display: none; text-align: center; padding: 15px; 
            border: 1px solid transparent; border-radius: 5px; 
            margin-top: 20px; animation: fadeIn 0.5s;
            font-weight: bold;
        }
        .confirmation-message.success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .confirmation-message.error { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
        .confirmation-message.warning { background-color: #fff3cd; color: #856404; border-color: #ffeeba; }


        .collaboration-section {text-align:center; margin-top:30px; padding-bottom:20px;}
        .collaboration-section button {background-color:#f0ad4e;}
        .collaboration-section button:hover {background-color:#ec971f;}


        /* Stiluri pentru Vizualizare Carduri (Fișe) - PĂSTRATE ȘI UȘOR RAFINATE */
        .card-view {display: flex; flex-direction: column; gap: 20px; max-width: 900px; margin: 30px auto;}
        .response-card {background: #f9f9ff; padding: 0; border-radius: 15px; box-shadow: 0 8px 16px rgba(0,0,0,0.12); transition: box-shadow 0.3s ease; position: relative; overflow: hidden;}
        .response-card:hover {box-shadow: 0 10px 20px rgba(0,0,0,0.18);}
        .response-card .card-header {font-weight: 700; font-size: 1.1em; cursor: pointer; background: #87CEFA; padding: 12px 20px; color: #fff; text-align: left; position: relative; display: flex; justify-content: space-between; align-items: center;}
        .response-card .card-header::after {content: '▼'; font-size: 0.8em; transition: transform 0.3s ease; margin-left: 10px;} /* Adăugat margin-left pt spațiere icon */
        .response-card.open .card-header::after {transform: rotate(180deg);}
        .response-card .card-content {max-height: 0; margin-top: 0; padding: 0 20px; background: #fff; line-height: 1.6; overflow: hidden; /* Schimbat auto în hidden pentru tranziție */ transition: max-height 0.5s ease-out, padding-top 0.5s ease-out, padding-bottom 0.5s ease-out;} 
        .response-card.open .card-content {max-height: 3500px; /* Mărit substanțial pt conținut lung */ padding-top: 15px; padding-bottom: 15px; overflow: visible; /* Re-activează scroll dacă e nevoie, sau lasă pe containerul #chatMessages */ } 

        .response-card .card-content p {margin-bottom: 12px; border-left: 3px solid #87CEFA; padding-left: 10px; color: #333;} /* Culoarea textului specificată */
        .response-card .card-content p strong {color: #333;} /* Păstrat */
        .response-card h4 {text-align: left; color: #4A90E2; font-weight: bold; margin-top: 20px; margin-bottom: 10px; font-size: 1.05em;}
        .response-card h4:first-child {margin-top: 0;}
        .card-actions {text-align: center; margin-top: 20px; padding-bottom: 10px; border-top: 1px solid #eee; padding-top: 15px;}
        .card-actions button {padding: 8px 15px; font-size: 0.9em; margin: 5px;}
        .generate-ai-feedback-button {background-color: #5cb85c;} 
        .generate-ai-feedback-button:hover {background-color: #4cae4c;}
        .delete-all-feedback-button {background-color: #ffc107;} 
        .delete-all-feedback-button:hover {background-color: #e0a800;}
        .delete-button {background-color: #dc3545 !important;} 
        .delete-button:hover {background-color: #c82333 !important;}
        
        /* Stiluri Istoric Feedback AI (în carduri) - PĂSTRATE */
        .ai-feedback-history-container { margin-top: 20px; border-top: 1px dashed #ddd; padding-top: 15px;} /* Adaugă un separator */
        .ai-feedback-history-container h4 { font-size: 1.1em; color: #4A90E2; margin-bottom: 10px; }
        .feedback-entry-card {background:#eef6ff; padding:15px; border-left:4px solid #4A90E2; border-radius:5px; margin-bottom:15px; font-size:0.95em; line-height:1.6;}
        .feedback-timestamp {color:#555; font-size:0.9em; margin-bottom:12px;}
        .feedback-section {margin-bottom:12px;}
        .feedback-section h5 {font-size:1em; font-weight:bold; color: #2c5282; margin-top:0; margin-bottom:6px;} /* Ajustat culoare la un albastru mai închis */
        .feedback-section p, .feedback-section ul {margin-top:0; margin-bottom:8px; color:#1e293b;} /* Ajustat culoare text */
        .feedback-section ul {padding-left:25px; list-style-position:outside; list-style-type:disc;}
        .feedback-section li {margin-bottom:4px;}
         .feedback-entry-card p[style*="color: red"] { font-weight: bold; } /* Stil specific pentru erori */
         .feedback-entry-card p[style*="color: orange"] { font-style: italic; } /* Stil specific pentru warning-uri */


        /* Stiluri Chat - ÎMBUNĂTĂȚITE */
        .chat-container {
            /* display: none; /* Comentat pentru testare */
            display: flex;
            flex-direction: column;
            position: fixed;
            bottom: 80px; /* Spațiu deasupra butonului */
            right: 20px;
            width: clamp(320px, 90vw, 400px); /* Lățime mai precisă */
            max-height: 70vh; 
            background: #f0f4f8; /* Fundal soft */
            border-radius: 10px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 999; 
            padding: 15px;
            box-sizing: border-box;
        }
         .chat-container h3 {
            text-align: center; color: #333; margin-top: 0; margin-bottom: 10px; font-size: 1.2em;
            flex-shrink: 0;
        }
        #chatMessages {
            flex-grow: 1;
            height: 300px; 
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
            background: #fff; 
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Spațiu între mesajele .chat-message */
            scrollbar-width: thin; 
            scrollbar-color: #888 #f1f1f1;
        }
         #chatMessages::-webkit-scrollbar {
            width: 8px;
         }
         #chatMessages::-webkit-scrollbar-track {
            background: #f1f1f1; 
         }
         #chatMessages::-webkit-scrollbar-thumb {
            background: #888; 
            border-radius: 4px;
         }
         #chatMessages::-webkit-scrollbar-thumb:hover {
            background: #555; 
         }

        .chat-message {
            padding: 8px 12px;
            border-radius: 18px; 
            max-width: 85%; 
            word-wrap: break-word; 
            line-height: 1.5; 
            box-shadow: 0 1px 1px rgba(0,0,0,0.08);
            font-size: 0.95em;
        }
        
        /* Containerul pentru conținutul din interiorul fiecărei bule de mesaj */
        .chat-message-content { 
            margin: 0;
            padding: 0;
            /* display: flex; /* Activat dacă vrem ca elementele interne să folosească gap */
            /* flex-direction: column; */
            /* gap: 8px; /* Spațiu uniform între elementele interne, dacă flex e activat */
                       /* Ar permite eliminarea margin-bottom de pe p, message-title, etc. */
        }


        .user-message {
            background-color: #007bff; 
            color: white;
            align-self: flex-end; 
            margin-left: auto; 
            border-bottom-right-radius: 5px; 
            border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-left-radius: 18px; 
        }
        .ai-message {
            background-color: #e9ecef; 
            color: #212529; 
            align-self: flex-start; 
            margin-right: auto; 
            border-bottom-left-radius: 5px; 
            border-top-left-radius: 18px; border-top-right-radius: 18px; border-bottom-right-radius: 18px; 
        }
        .ai-message.ai-error { 
            background-color: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb; 
            align-self: flex-start;
            border-radius: 8px; 
        }
         /* Titlurile generate de AI în interiorul mesajelor */
         .ai-message .message-title { /* Această clasă e adăugată de funcția formatAiMessageContent */
             font-size: 1.05em; /* Puțin mai mare și mai gros */
             font-weight: 700; 
             color: #1a5a9c; /* Albastru închis specific */
             margin-bottom: 8px; /* Spațiu sub titlu, înainte de paragraf */
             display: block; /* Ocupă toată lățimea disponibilă în containerul de conținut */
             padding-bottom: 5px; /* Puțin spațiu sub textul titlului */
             border-bottom: 1px solid #cfd8e1; /* Linie separatoare fină */
             line-height: 1.4; /* Ajustare linie pentru titluri */
         }
         /* Paragrafele din interiorul .chat-message-content pentru AI */
         .ai-message .chat-message-content p {
             margin-top: 0; /* Elimină orice spațiu de sus adăugat implicit de browser */
             margin-bottom: 10px; 
             line-height: 1.6; /* Lizibilitate îmbunătățită */
         }
         .ai-message .chat-message-content p:last-child {
             margin-bottom: 0; 
         }

         /* Formatare specifică pentru text italic și bold în mesajele AI */
         .ai-message em, .ai-message i {
            font-style: italic; /* Asigură că este italic */
            /* color: #007bff; /* Opțional, o culoare distinctă */
         }
         .ai-message strong, .ai-message b {
            font-weight: bold; /* Asigură că este bold */
            /* color: #2c3e50; /* Opțional, un negru/gri mai închis */
         }
        
        /* Stil pentru Capsulele Teoretice */
        .ai-message .theory-box { /* Această clasă e adăugată de funcția formatAiMessageContent */
            background-color: #eef5fc; 
            border: 1px solid #c3daec; 
            border-left: 5px solid #4A90E2; 
            padding: 10px 15px;
            margin: 12px 0; 
            border-radius: 8px; 
            font-size: 0.9em;
            line-height: 1.5;
            word-break: break-word; 
        }
        .ai-message .theory-box .theory-box-title { 
            font-weight: bold;
            color: #2c5282; 
            margin-top: 0; /* Resetează marginea de sus a titlului intern */
            margin-bottom: 6px; /* Spațiu după titlul capsulei */
            display: block;
            font-size: 1em; 
        }
        .ai-message .theory-box .theory-box-concept { 
            font-style: italic;
            color: #444; /* Un gri mai închis pentru concept */
            margin-bottom: 6px;
            display: block;
        }
        .ai-message .theory-box p { 
            margin-top: 0;
            margin-bottom: 5px; 
            line-height: 1.5;
            font-size: 1em; /* Păstrează dimensiunea de la .theory-box */
        }
         .ai-message .theory-box p:last-child {
            margin-bottom: 0;
         }

         /* Stil pentru blocul ASCII (dacă este generat și parsarea JS îl pune în această clasă) */
         .ai-message .ascii-art-block {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            white-space: pre; 
            overflow-x: auto; 
            padding: 10px;
            background-color: #f8f9fa; 
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 0.85em; 
            line-height: 1.3;
            margin: 10px 0;
            word-wrap: normal; 
            word-break: normal; 
            color: #495057;
         }
        
        #chatInput { /* Am scos calc(100% - 0px) care nu e necesar cu box-sizing:border-box */
            width: 100%; 
            padding: 10px; 
            border-radius: 5px; 
            border: 1px solid #ccc; 
            resize: vertical; 
            min-height: 40px; 
            box-sizing: border-box;
            font-family: inherit;
            flex-shrink: 0;
            margin-bottom: 8px;
        }
         #chatInput:focus {
             border-color: #87CEFA;
             box-shadow: 0 0 5px rgba(135,206,250,0.5);
             outline: none;
         }
        #sendChatMessageButton {
            margin-top: 0;
            padding: 10px 15px;
            width: 100%; 
            font-size: 1em;
            background: linear-gradient(to right, #87CEFA, #6bb9e7); 
            color: white;
            border: none;
            border-radius: 5px; 
            cursor: pointer;
            transition: background 0.3s ease; 
            flex-shrink: 0; 
        }
         #sendChatMessageButton:hover {
             background: linear-gradient(to right, #6bb9e7, #4A90E2);
         }
         #sendChatMessageButton:disabled {
             background: #ccc !important; /* Important pentru a suprascrie gradientul */
         }

        #chatStatus {
            font-size: 0.85em; color: #555; margin-top: 5px; text-align: center; min-height: 1.2em;
            flex-shrink: 0;
        }

        #toggleChatButton {
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            padding: 0; 
            z-index: 1000; 
            display: flex; 
            align-items: center;
            justify-content: center;
            background-color: #87CEFA; 
            color: white;
            border: none;
            border-radius: 50%; 
            width: 55px; 
            height: 55px;
            font-size: 26px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }
        #toggleChatButton:hover {
             background-color: #6bb9e7; 
             transform: scale(1.05);
        }
        /* Regula pt a ascunde containerul - ajustată ca să nu interfereze cu stilurile inițiale flex */
        .chat-container[style*="display: none"] { 
             display: none !important;
        }

        /* Stiluri Tabel Original - Rămân Ascunse */
         .table-container {display: none;} 

        /* Responsive Styles - PĂSTRATE ȘI AJUSTATE PENTRU CHAT */
        @media (max-width: 768px) {
            body {padding:10px;}
            .form-container, .card-view {padding:15px; margin-left:10px; margin-right:10px; max-width:calc(100% - 20px);}
            .form-container textarea {font-size:14px; padding:8px; width:calc(100% - 18px);}
            .form-container > button, .step-navigation button {font-size:16px; padding:10px 20px;}
            .card-actions button {font-size:0.85em; padding:7px 12px;}
            .question-card h3, .response-card .card-header {font-size:1.05em;}
            .question-card p, .response-card .card-content p {font-size:0.9em;}
            
            .chat-container { 
                width: calc(100% - 20px); /* Ocupă aproape toată lățimea pe mobil */
                right: 10px;
                left: 10px; /* Centrat aproximativ */
                max-height: 60vh; /* Redu înălțimea */
                bottom: 75px; 
                padding: 10px; /* Reduce padding */
            }
            #chatMessages { height: 220px; padding: 8px; } /* Reduce înălțimea și paddingul */
            .chat-message { max-width: 90%; padding: 7px 10px; } /* Ajustează dimensiuni bule */

            #toggleChatButton { 
                width: 50px; 
                height: 50px; 
                font-size: 24px; 
                bottom: 15px; right: 15px; /* Poziție pe mobil */
            }
            #chatInput { font-size: 0.95em; min-height: 35px;} /* Input mai mic */
            #sendChatMessageButton { font-size: 0.95em; padding: 8px 12px;} /* Buton mai mic */


            /* Responsiv Tabel (rămâne ascuns) */
            .table-container {overflow-x:auto;}
            table {display:block; width:100%;}
            thead, tbody, tr {display:block;}
            th {display:none;} 
            tr {margin-bottom:15px; border:1px solid #ddd; border-radius:5px; display:flex; flex-direction:column;}
            td {display:flex; justify-content:space-between; padding:10px; text-align:right; border-bottom:1px solid #eee; position:relative;}
            td:last-child {border-bottom:none;}
            td::before {content:attr(data-label); font-weight:bold; text-align:left; margin-right:10px; color:#555; flex-shrink:0; width:auto; padding-right: 10px;} 
            td > *:not(button) {flex-grow:1; word-break:break-word; text-align:left;} 
            td button {width:auto; padding:6px 12px; font-size:0.85em; margin-left:auto; flex-shrink:0;}
            td[colspan="10"] {display:block;}
        }
        @media (max-width: 480px) {
            body {padding:8px;} /* Reduce paddingul general */
            .form-container, .card-view {padding:10px; margin-left:8px; margin-right:8px; max-width:calc(100% - 16px);}
            .form-container textarea {font-size:13px; padding:6px; width:calc(100% - 14px);}

            .form-container > button, .step-navigation button {font-size:14px; padding:8px 15px;}
            .card-actions button {font-size:0.8em; padding:6px 10px;}
            .question-card h3, .response-card .card-header {font-size:1em;}
            .question-card p, .response-card .card-content p {font-size:0.85em;}
            .response-card .card-header {padding:10px;}
            .response-card .card-content {padding-left:15px; padding-right:15px; font-size:0.85em;}
            td {flex-direction:column; align-items:flex-start;} 
            td::before {width:100%; margin-bottom:5px; margin-right: 0;}
            td button {align-self:flex-end;}

            .chat-container { 
                width: calc(100% - 16px); 
                 right: 8px; left: 8px;
                max-height: 55vh; 
                bottom: 70px;
                padding: 8px;
            }
            #chatMessages { height: 180px; padding: 6px; gap: 6px; }
            .chat-message { padding: 6px 10px; }

            #toggleChatButton { 
                width: 45px; 
                height: 45px; 
                font-size: 22px; 
                bottom: 12px; right: 12px;
                 box-shadow: 0 1px 5px rgba(0,0,0,0.3);
            }

        }
    </style>
</head>
<body>

    <div class="form-container">
        <h2 class="main-form-title">Fișă Monitorizare</h2> 
        <p>Completează fiecare întrebare pentru a înțelege mai bine situațiile tale. Fiecare secțiune reprezintă o parte importantă a reflecției tale. În acest exercițiu, îți voi ghida fiecare pas, astfel încât să poți explora în profunzime gândurile, emoțiile și comportamentele tale.</p>
    
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    
        <form id="exercitiuForm" novalidate>
            <!-- PASUL 1 - PASUL 28 - PĂSTRAT COMPLET -->
             <!-- AICI ESTE TOATĂ STRUCTURA HTML A FORMULARULUI CUM AI AVUT-O DEJA -->

            <div class="question-card form-step form-step-active" id="step-1">
                <h3>Care este situația?</h3>
                <p>Te rog să descrii contextul care a declanșat emoțiile sau comportamentul tău. Încearcă să fii cât mai specific și detaliat. Aceasta poate fi o situație concretă din viața de zi cu zi în care te-ai simțit copleșit, stresat sau într-o altă stare emoțională intensă.</p>
                <textarea name="situatie" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-2">
                <h3>Ce îmi trece prin minte?</h3>
                <p>Îți cer să identifici gândurile automate care au apărut în această situație. Acestea sunt gânduri rapide, involuntare, care îți trec prin minte în momentele de stres. Ce îți spui în acel moment? Este un gând critic sau îngrijorător?</p>
                <textarea name="ganduri" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-3">
                <h3>Cum mă face acel gând să mă simt?</h3>
                <p>Te rog să notezi emoțiile pe care le simți în urma acelui gând. Ce simți? Frică, tristețe, furie? Dă o intensitate emoției (de la 0 la 100) pentru a vedea cât de puternică este.</p>
                <textarea name="emotii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-4">
                <h3>Ce mod este activ?</h3>
                <p>Identifică modul în care te afli în această situație. Este un mod de copil vulnerabil, critic interior, sau poate adultul sănătos? Conștientizarea modului îți poate oferi o mai bună înțelegere a reacțiilor tale.</p>
                <textarea name="mod_activ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-5">
                <h3>Ce comportament simți că adopți?</h3>
                <p>Descrie comportamentul pe care îl manifești în această situație. Este un comportament de evitare, de confruntare, de sacrificiu de sine? Recunoașterea comportamentului te ajută să înțelegi mai bine cum reacționezi.</p>
                <textarea name="comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-6">
                <h3>Care sunt nevoile tale mai profunde?</h3>
                <p>Ce nevoi stau la baza acestor emoții și comportamente? Poate fi nevoia de siguranță, de validare, de acceptare? Identificarea acestor nevoi te poate ajuta să găsești strategii mai sănătoase pentru a le îndeplini.</p>
                <textarea name="nevoi_profunde" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-7">
                <h3>Mă ajută comportamentul meu să îndeplinesc aceste nevoi?</h3>
                <p>Reflectează dacă felul în care reacționezi te ajută cu adevărat să îți îndeplinești nevoile. Poate fi util să te gândești dacă există alternative mai eficiente.</p>
                <textarea name="ajutor_comportament" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-8">
                <h3>Cum ar gândi și cum s-ar comporta Adultul Sănătos?</h3>
                <p>Gândește-te la cum ar reacționa partea ta Adultă Sănătoasă în această situație. Cum ai putea să abordezi diferit pentru a avea grijă de tine și de nevoile tale?</p>
                <textarea name="adult_sanatos" rows="3" required></textarea>
            </div>

            <!-- PASUL 2 -->
            <div class="question-card form-step" id="step-9">
                <h3>Ce mă face să cred că gândul automat este adevărat?</h3>
                <p>Explorează motivele pentru care crezi că acest gând este adevărat. Ce dovezi ai care îți confirmă acest lucru? De multe ori, ne bazăm pe experiențe trecute sau frici pentru a justifica un gând.</p>
                <textarea name="dovezi_adevar" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-10">
                <h3>Ce mă face să cred că nu este adevărat?</h3>
                <p>Acum, să ne uităm la dovezile împotriva gândului tău. Există argumente sau experiențe care contrazic acest gând? Poate există o altă perspectivă pe care nu ai luat-o în considerare?</p>
                <textarea name="dovezi_fals" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-11">
                <h3>Există o explicație alternativă?</h3>
                <p>Uneori, există mai multe explicații pentru ceea ce se întâmplă. Ce alte interpretări ai putea avea pentru această situație? Gândește-te la alte posibilități care ar putea explica contextul.</p>
                <textarea name="explicatie_alternativa" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-12">
                <h3>Care este cel mai rău lucru care s-ar putea întâmpla?</h3>
                <p>Ce este cel mai rău care ar putea avea loc în această situație? Să identificăm acele frici catastrofale care adesea ne alimentează gândurile negative.</p>
                <textarea name="scenariu_negativ" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-13">
                <h3>Care este cel mai bun lucru care s-ar putea întâmpla?</h3>
                <p>Pe de altă parte, care ar fi cel mai pozitiv scenariu? Uneori uităm să ne gândim și la posibilitățile bune. Cum ar arăta cel mai bun rezultat al acestei situații?</p>
                <textarea name="scenariu_optimist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-14">
                <h3>Care este cel mai realist rezultat?</h3>
                <p>După ce am explorat extremele, ce crezi că este cel mai probabil să se întâmple? Cum ar arăta un rezultat realist, ținând cont de toate perspectivele?</p>
                <textarea name="rezultat_realist" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-15">
                <h3>Ce s-ar întâmpla dacă mi-aș schimba modul de gândire?</h3>
                <p>Întreabă-te cum ar fi dacă ai aborda situația cu un alt tip de gândire. Cum ar influența asta emoțiile și comportamentele tale?</p>
                <textarea name="schimbare_gandire" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-16">
                <h3>Ce i-aș spune unui prieten dacă ar fi în aceeași situație?</h3>
                <p>Gândește-te la cum ai reacționa dacă un prieten drag ar avea aceleași gânduri. Ce i-ai spune pentru a-l sprijini? Cum ai încerca să-l încurajezi?</p>
                <textarea name="sfat_prieten" rows="3" required></textarea>
            </div>

            <!-- PASUL 3 -->
            <div class="question-card form-step" id="step-17">
                <h3>Văd doar partea rea a lucrurilor?</h3>
                <p>Este posibil să fii prins într-un tipar negativ de gândire, concentrându-te doar pe aspectele negative. Încearcă să observi dacă există și aspecte pozitive pe care le-ai ignorat.</p>
                <textarea name="partea_rea" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-18">
                <h3>Îmi asum responsabilitatea pentru lucruri care nu au stat în puterea mea?</h3>
                <p>Reflectează dacă îți asumi responsabilitatea pentru situații asupra cărora nu aveai control. Este important să îți dai seama de limitele influenței tale.</p>
                <textarea name="responsabilitate" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-19">
                <h3>Mă condamn în baza unui singur eveniment?</h3>
                <p>Îți evaluezi valoarea personală bazându-te pe un singur eveniment negativ? Amintește-ți că un eveniment nu definește cine ești în totalitate.</p>
                <textarea name="condamnare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-20">
                <h3>Privesc situația în termeni extremi?</h3>
                <p>Verifică dacă vezi situația doar în alb sau negru, fără nuanțe de gri. Gândirea extremă poate distorsiona realitatea.</p>
                <textarea name="termeni_extremi" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-21">
                <h3>Exagerez situația?</h3>
                <p>Îți amplifici reacțiile față de o situație? Încearcă să te gândești dacă ceea ce percepi este realist sau dacă exagerezi impactul situației.</p>
                <textarea name="exagerare" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-22">
                <h3>Există și alți factori responsabili?</h3>
                <p>Există alți factori care contribuie la această situație, pe lângă tine? Este important să ai o perspectivă completă asupra cauzelor unei situații.</p>
                <textarea name="factori_responsabili" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-23">
                <h3>Am sărit direct la concluzii?</h3>
                <p>Te-ai grăbit să ajungi la o concluzie fără suficiente dovezi? Încearcă să observi dacă există alte posibilități care ar putea explica situația.</p>
                <textarea name="concluzii" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-24">
                <h3>Îmi pun întrebări fără răspuns?</h3>
                <p>Te frământă întrebări care nu au un răspuns clar sau realist? Aceste întrebări pot fi o sursă majoră de anxietate.</p>
                <textarea name="intrebari_fara_raspuns" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-25">
                <h3>Mă concentrez doar asupra slăbiciunilor mele?</h3>
                <p>Ai tendința să te focalizezi doar pe slăbiciuni și să ignori punctele tale forte? Încearcă să îți recunoști și punctele pozitive.</p>
                <textarea name="slabiciuni" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-26">
                <h3>Mă zbat prea mult gândind la cum ar trebui să fie lucrurile?</h3>
                <p>Ai tendința să te gândești mereu la cum ar trebui să fie lucrurile, în loc să accepți situația așa cum este? Acceptarea poate reduce stresul și anxietatea.</p>
                <textarea name="cum_ar_trebui" rows="3" required></textarea>
            </div>
            <div class="question-card form-step" id="step-27">
                <h3>Mă aștept să fiu perfect?</h3>
                <p>Îți setezi standarde foarte înalte, imposibil de atins? Perfecționismul poate fi o sursă majoră de frustrare și descurajare.</p>
                <textarea name="perfectiune" rows="3" required></textarea>
            </div>
             <div class="question-card form-step" id="step-28">
                <h3>Completare finalizată!</h3>
                <p>Felicitări pentru parcurgerea acestui exercițiu de auto-reflecție! Apasă butonul de mai jos pentru a salva datele și a genera un feedback automatizat, dacă este disponibil.</p>
                <p>Feedback-ul AI te poate ajuta să obții noi perspective. Dacă întâmpini probleme cu generarea (ex: erori de limită de utilizare sau cheie API invalidă), poți încerca din nou mai târziu sau contacta administratorul.</p>
            </div>


            <div class="step-navigation">
                <button type="button" id="prevButton">Înapoi</button>
                <button type="button" id="nextButton">Înainte</button>
            </div>
            <button type="button" id="addButton">Salvează și Generează Feedback AI</button>
        </form>

        <div id="confirmationMessage" class="confirmation-message">
            <!-- Mesajul va fi setat de JavaScript -->
        </div>

        <div class="collaboration-section">
            <button type="button" id="generateLinkButton">Generează Link de Colaborare</button>
        </div>
    </div>
    
    <h3 style="text-align: center; margin-top: 40px; margin-bottom: 10px; color: #333; font-weight: 500;">Răspunsurile Tale și Istoricul Feedback-ului AI:</h3>
    
    <div class="card-view" id="cardViewContainer">
        <!-- Cardurile cu răspunsuri și feedback AI vor fi adăugate aici de JavaScript -->
    </div>
    
    <!-- Chat Container -->
    <div class="chat-container" id="chatContainer"> 
        <h3>Discută cu PsihoGPT</h3>
        <div id="chatMessages">
            <!-- Mesajele vor apărea aici -->
        </div>
        <textarea id="chatInput" rows="2" placeholder="Scrie mesajul tău aici... Apasă Enter pentru a trimite."></textarea>
        <button id="sendChatMessageButton" disabled>Trimite Mesaj</button> 
        <p id="chatStatus"></p>
    </div>

    <button id="toggleChatButton" style="display: none;">💬</button>


     <!-- Tabelul original (acum ascuns implicit prin CSS .table-container {display: none;}) -->
    <div class="table-container"> 
        <table>
            <thead>
                <tr>
                    <th>Data</th><th>Situația</th><th>Gânduri</th><th>Emoții</th><th>Mod activ</th>
                    <th>Comportament</th><th>Nevoile</th><th>Ajutor comport.</th><th>Adult Sănătos</th><th>Detalii</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <br/>
</body>
</html>