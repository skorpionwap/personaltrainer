<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // ÃŽnlocuieÈ™te cu cheia ta realÄƒ
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÃŽNLOCUIEÈ˜TE AICI !!!
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17"; // Sau "gemini-1.5-flash-latest"
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configuratÄƒ:", "'" + GEMINI_API_KEY + "'");

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") { // Am eliminat verificarea .startsWith()
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini iniÈ›ializat. Model Feedback Jurnal:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare criticÄƒ la iniÈ›ializarea SDK Gemini:", e);
            let alertMessage = "Eroare la iniÈ›ializarea serviciului AI pentru jurnal. VerificaÈ›i cheia API Gemini È™i configuraÈ›ia.";
            if (e.message && e.message.toLowerCase().includes("api key not valid")) {
                alertMessage = "Cheia API Gemini nu este validÄƒ sau nu are permisiuni pentru modelul de jurnal. VerificaÈ›i Google Cloud Console.";
            } else if (e.message && e.message.toLowerCase().includes("quota")) {
                alertMessage = "Limita de utilizare pentru API-ul Gemini a fost atinsÄƒ (posibil pentru modelul de jurnal).";
            }
            alert(alertMessage + " FuncÈ›ionalitatea AI va fi limitatÄƒ.");
            geminiModelJournalFeedback = null;
        }
    } else  {
        console.warn(`Jurnal Terapeutic: Cheia API Gemini este goalÄƒ sau lipseÈ™te. FuncÈ›ionalitatea AI va fi dezactivatÄƒ.`);
        alert("Jurnal Terapeutic: Cheia API Gemini nu este configuratÄƒ. FuncÈ›ionalitatea AI pentru jurnal va fi dezactivatÄƒ.");
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
    };

    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [
            { label: "ExploreazÄƒ o emoÈ›ie", text: "AstÄƒzi vreau sÄƒ explorez emoÈ›ia de [NUMEÈ˜TE EMOÈšIA].\n\nCum se simte Ã®n corpul meu? [DESCRIE SENZAÈšIILE]\nCe gÃ¢nduri sunt asociate? [NOTEAZÄ‚ GÃ‚NDURILE]\nÃŽn ce context a apÄƒrut? [DESCRIE SITUAÈšIA]\nCe nevoie ar putea semnala? [REFLECTEAZÄ‚]\nCum aÈ™ putea oferi compasiune? [ACÈšIUNE COMPASIONALÄ‚]\n" },
            { label: "AnalizeazÄƒ o situaÈ›ie", text: "SituaÈ›ia care mÄƒ preocupÄƒ este: [DESCRIE SITUAÈšIA]\n\nCe s-a Ã®ntÃ¢mplat exact? (Fapte)\nInterpretarea mea iniÈ›ialÄƒ: [GÃ‚NDURI AUTOMATE]\nEmoÈ›iile principale: [LISTEAZÄ‚ EMOÈšIILE]\nO altÄƒ perspectivÄƒ: [REFRAMING]\nCe am Ã®nvÄƒÈ›at/pot Ã®nvÄƒÈ›a? [LECÈšII]\n" },
            { label: "Dialog Voce CriticÄƒ", text: "Vocea mea criticÄƒ Ã®mi spune: \"[MESAJUL CRITIC]\"\n\nMÄƒ face sÄƒ mÄƒ simt: [EMOÈšII GENERATE]\nDin perspectiva Adultului SÄƒnÄƒtos, aÈ™ rÄƒspunde: \"[RÄ‚SPUNS COMPASIONAL]\"\nO nevoie ascunsÄƒ: [NEVOIA SUBIACENTÄ‚]\n" },
            { label: "RecunoÈ™tinÈ›Äƒ & Resurse", text: "AstÄƒzi sunt recunoscÄƒtor/oare pentru:\n1. \n2. \n3. \n\nO resursÄƒ interioarÄƒ pe care mÄƒ pot baza: \nUn gest de auto-Ã®ngrijire: \n" },
            { label: "ðŸŒ€ Ritual ReconstrucÈ›ie InterioarÄƒ", // Am adÄƒugat un emoji
        text: `ðŸ§­ MASTER TEMPLATE â€“ Scriere TerapeuticÄƒ de Integrare È™i Vindecare\n` +
              `Denumire: â€žRitual de reconstrucÈ›ie interioarÄƒâ€\n` +
              `Scop: Eliberare, Clarificare, ConÈ›inere, ÃŽnÈ›elepciune, DirecÈ›ie\n\n` +
              `I. ðŸ” INVITAÈšIE LA AUTENTICITATE\n` +
              `â€žCe parte din mine cere atenÈ›ie acum?â€\n\n` +
              `   * Ce trÄƒiesc cu adevÄƒrat, fÄƒrÄƒ filtru, fÄƒrÄƒ poveste cosmetizatÄƒ?\n` +
              `   * Ce mi-e ruÈ™ine sÄƒ simt sau sÄƒ recunosc chiar È™i Ã®n scris?\n` +
              `   * Ce parte din mine se simte exclusÄƒ, neauzitÄƒ, ignoratÄƒ?\n` +
              `   [RÄ‚SPUNSUL TÄ‚U AICI]\n\n` + // Am adÄƒugat un placeholder
              `II. ðŸŒŠ CONTAINERE EMOÈšIONALE\n` +
              `â€žCe simte corpul meu? Unde locuieÈ™te durerea?â€\n\n` +
              `   * Unde simt emoÈ›ia Ã®n corp? Cum se manifestÄƒ? (Tensiune, Ã®nÈ›epÄƒturi, etc.)\n` +
              `   * DacÄƒ ar avea o culoare, formÄƒ, texturÄƒ â€“ cum ar arÄƒta?\n` +
              `   * Pot respira Ã®n acea zonÄƒ 3 minute, fÄƒrÄƒ sÄƒ fug?\n` +
              `   [RÄ‚SPUNSUL TÄ‚U AICI]\n\n` +
              `III. ðŸ§  DECODIFICARE NARATIVÄ‚\n` +
              `â€žCe poveste Ã®mi spun? Este Ã®ntreagÄƒ?â€\n\n` +
              `   * Ce naraÈ›iune inconÈ™tientÄƒ guverneazÄƒ trÄƒirea mea? (ex: â€žNu sunt dorit.â€)\n` +
              `   * De unde vine aceastÄƒ naraÈ›iune? CÃ¢nd am mai trÄƒit ceva similar?\n` +
              `   * Ce parte din mine (copil rÄƒnit, etc.) scrie aceastÄƒ poveste?\n` +
              `   [RÄ‚SPUNSUL TÄ‚U AICI]\n\n` +
              `IV. ðŸ§© INTEGRARE EXPLICATIVÄ‚\n` +
              `â€žCe Ã®nÈ›eleg nou despre mine din aceastÄƒ durere?â€\n\n` +
              `   * Ce nevoi profunde au fost ignorate sau negate?\n` +
              `   * Ce am protejat, de fapt, prin reacÈ›ia mea?\n` +
              `   * Ce emoÈ›ii contradictorii coexistÄƒ Ã®n mine È™i ce spun ele?\n` +
              `   [RÄ‚SPUNSUL TÄ‚U AICI]\n\n` +
              `V. ðŸªž COMPASIUNE È˜I BLÃ‚NDEÈšE\n` +
              `â€žCum pot fi pÄƒrinte pentru mine acum?â€\n\n` +
              `   * DacÄƒ mi-aÈ™ È›ine partea rÄƒnitÄƒ Ã®n braÈ›e, ce i-aÈ™ spune?\n` +
              `   * Ce aÈ™ vrea sÄƒ aud din partea unei figuri ideale de susÈ›inere?\n` +
              `   * Pot lÄƒsa iubirea, nu logica, sÄƒ conducÄƒ acest moment?\n` +
              `   [RÄ‚SPUNSUL TÄ‚U AICI]\n\n` +
              `VI. ðŸ”® RECONFIGURARE IDENTITARÄ‚\n` +
              `â€žCine sunt eu dincolo de aceastÄƒ ranÄƒ?â€\n\n` +
              `   * Ce adevÄƒr despre mine rÄƒmÃ¢ne valabil, chiar È™i Ã®n durere?\n` +
              `   * Cine devin dacÄƒ Ã®nvÄƒÈ› sÄƒ stau cu mine Ã®n acest spaÈ›iu?\n` +
              `   * DacÄƒ aÈ™ fi un personaj simbolic acum, cine aÈ™ fi?\n` +
              `   [RÄ‚SPUNSUL TÄ‚U AICI]\n\n` +
              `VII. âœï¸ ACTUL SACRU DE ALEGERE\n` +
              `â€žCe aleg de azi, pentru mine?â€\n\n` +
              `   * Ce meritÄƒ sÄƒ las sÄƒ plece?\n` +
              `   * Ce Ã®mi iau ca Ã®nvÄƒÈ›ÄƒturÄƒ de Ã®ncredere Ã®n viaÈ›Äƒ?\n` +
              `   * Ce ritual zilnic/mic obicei pot Ã®ncepe pentru a onora aceastÄƒ transformare?\n` +
              `   [RÄ‚SPUNSUL TÄ‚U AICI]\n\n` +
              `VIII. (OpÈ›ional) ðŸ“œ SCRISOARE-RITUAL\n` +
              `Scrie o scrisoare cÄƒtre...\n` +
              `   [ALEGE È˜I SCRIE AICI]\n`
    }
        ];
        promptsContainerEl.innerHTML = ''; // Clear previous
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "InsereazÄƒ acest ghid Ã®n jurnal";
            button.onclick = () => {
                if (journalTextarea.value.trim() !== "" && !confirm("Vrei sÄƒ Ã®nlocuieÈ™ti textul curent cu acest ghid? OK pentru a Ã®nlocui, Anulare pentru a adÄƒuga la sfÃ¢rÈ™it.")) {
                    journalTextarea.value += "\n\n---\n" + prompt.text;
                } else {
                    journalTextarea.value = prompt.text;
                }
                journalTextarea.focus();
                journalTextarea.scrollTop = journalTextarea.scrollHeight;
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) return "EROARE: Model AI neiniÈ›ializat (jurnal).";
        try {
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.72, ...generationConfigOptions }
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare opritÄƒ (Motiv: ${response.candidates[0].finishReason}).`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}).`;
            }
            return "EROARE Gemini: RÄƒspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            return `EROARE Gemini: ${error.message || "Eroare API."}`;
        }
    }

    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: FuncÈ›ionalitatea AI pentru jurnal nu este disponibilÄƒ.";
        
        const promptJurnalPentruRitual = `
"EÈ™ti PsihoGPT, un partener de dialog avansat, un psihoterapeut experimentat format Ã®n toate abordarile moderne de psihoterapie. Vei integra teorie relevanta, vei cita si vei parafraza.
Specializat Ã®n analiza profundÄƒ a scrierilor terapeutice structurate. 
Tocmai am completat un exerciÈ›iu numit 'Ritual de ReconstrucÈ›ie InterioarÄƒ', care are urmÄƒtoarele secÈ›iuni: I. InvitaÈ›ie la Autenticitate, II. Continere Emotionala, III. Decodificare NarativÄƒ, IV. Integrare ExplicativÄƒ, V. Compasiune È™i BlÃ¢ndeÈ›e, VI. Reconfigurare IdentitarÄƒ, VII. Actul Sacru de Alegere, È™i opÈ›ional VIII. Scrisoare-Ritual.

Scopul tÄƒu este sÄƒ-mi oferi un feedback care:
1.  **RecunoaÈ™te È™i valideazÄƒ** efortul È™i vulnerabilitatea implicate Ã®n completarea acestui ritual.
2.  **ReflectÄƒ temele È™i insight-urile cheie** care reies DIN FIECARE SECÈšIUNE a ritualului meu (unde am oferit rÄƒspunsuri semnificative). Fii specific È™i referÄƒ-te la conÈ›inutul meu.
3.  **IdentificÄƒ conexiuni** Ã®ntre diferitele secÈ›iuni ale ritualului (ex: cum autenticitatea din secÈ›iunea I se leagÄƒ de nevoia identificatÄƒ Ã®n IV sau de alegerea din VII).
4.  **Pune Ã®ntrebÄƒri de aprofundare** care sÄƒ mÄƒ ajute sÄƒ integrez È™i mai mult cele descoperite (cÃ¢te 1-2 Ã®ntrebÄƒri per secÈ›iune relevantÄƒ sau cÃ¢teva Ã®ntrebÄƒri globale de sintezÄƒ).
5.  **OglindeÈ™te limbajul È™i conceptele psihoterapeutice** pe care le-am folosit sau care par relevante pentru rÄƒspunsurile mele (ex: dacÄƒ vorbesc despre 'copilul interior', poÈ›i reflecta pe marginea acestuia).
6.  **ÃŽncurajeazÄƒ È™i susÈ›ine** procesul de transformare schiÈ›at Ã®n secÈ›iunea VII (Actul Sacru de Alegere).

Abordarea ta sÄƒ fie profund empaticÄƒ, analiticÄƒ, dar È™i provocatoare constructiv. Sunt familiarizat cu concepte terapeutice. FoloseÈ™te un format clar, poate reluÃ¢nd titlurile secÈ›iunilor mele È™i oferind comentarii/Ã®ntrebÄƒri specifice pentru fiecare."

Intrarea mea completatÄƒ Ã®n cadrul 'Ritualului de ReconstrucÈ›ie InterioarÄƒ' este:
Titlu: ${entryData.titlu}
ConÈ›inut (cu secÈ›iunile marcate):
---
${entryData.continut} 
---
// Nota pentru AI: RÄƒspunsurile mele sunt sub fiecare set de Ã®ntrebÄƒri/secÈ›iune a Ritualului.

OferÄƒ-mi un feedback detaliat È™i structurat. MulÈ›umesc!`;

        console.log("Trimitere prompt cÄƒtre Gemini (jurnal):", promptJurnal.substring(0, 100) + "...");
        const feedbackText = await callGeminiAPI(promptJurnal, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId);
    }
    
    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId) {
        const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva Ã®n jurnal."); return; }

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salveazÄƒ..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se genereazÄƒ AI...";
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id);
            
            const docSnapshot = await getDoc(docRef);
            if (docSnapshot.exists()) afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            
            journalTextarea.value = ""; if (journalTitleInput) journalTitleInput.value = "";
            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvatÄƒ. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvatÄƒ È™i feedback AI generat!';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 9000);
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau generare feedback.';
            confirmationMsg.className = 'confirmation-message error';
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
        } finally {
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se genereazÄƒ..."; btn.disabled = true; }

        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { alert("Intrarea nu existÄƒ."); return; }
            await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId);
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); // Re-fetch
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
            }
            alert("Feedback AI regenerat!");
        } catch (e) { console.error("Eroare regenerare:", e); alert("Eroare la regenerare feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        if (!confirm("È˜tergi ultimul feedback AI pentru aceastÄƒ intrare?")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se È™terge..."; btn.disabled = true; }

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                alert("Nu existÄƒ feedback de È™ters."); return;
            }
            const history = entrySnap.data().feedbackAI_history;
            const lastFeedback = history.pop(); // Scoate ultimul È™i Ã®l avem Ã®n `lastFeedback`

            await updateDoc(entryDocRef, {
                feedbackAI_history: history, // SalveazÄƒ istoricul fÄƒrÄƒ ultimul element
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            alert("Ultimul feedback AI È™ters.");
        } catch (e) { console.error("Eroare È™tergere ultim feedback:", e); alert("Eroare la È™tergere feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, feedbackHistory) {
    containerEl.innerHTML = ''; // GoleÈ™te containerul existent

    if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
        const noHistoryMsg = document.createElement("p");
        noHistoryMsg.textContent = "Niciun feedback AI generat pentru aceastÄƒ intrare.";
        noHistoryMsg.style.fontStyle = "italic";
        noHistoryMsg.style.textAlign = "center";
        noHistoryMsg.style.padding = "10px 0";
        containerEl.appendChild(noHistoryMsg);
        return;
    }

    feedbackHistory.slice().reverse().forEach((entry, index) => {
        const itemContainer = document.createElement("div");
        itemContainer.className = "feedback-entry-card"; // Clasa generalÄƒ pentru un card de feedback

        const timestampAndModel = document.createElement("p");
        timestampAndModel.className = "feedback-timestamp";
        timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - ${entry.model || 'N/A'})`;
        itemContainer.appendChild(timestampAndModel);

        const contentWrapper = document.createElement("div"); // Un wrapper pentru conÈ›inutul AI
        contentWrapper.className = "content-ai"; // Pentru stilizarea generalÄƒ a textului AI

        if (entry.error) {
            const errorP = document.createElement("p");
            errorP.style.color = "red";
            errorP.style.fontWeight = "bold";
            errorP.style.whiteSpace = "pre-wrap";
            errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
            contentWrapper.appendChild(errorP);
        } else {
            let processedHTML = entry.rawText || 'ConÈ›inut indisponibil.';

            // SecurizeazÄƒ HTML-ul brut Ã®nainte de a injecta regex-uri (minimal)
            // Acest pas este important dacÄƒ textul ar putea conÈ›ine caractere care interfereazÄƒ cu HTML-ul.
            // Dar, pentru moment, ne bazÄƒm cÄƒ textul e predominant text simplu cu markdown-ul Gemini.
            // processedHTML = processedHTML.replace(/</g, "<").replace(/>/g, ">"); // Prea agresiv, stricÄƒ dacÄƒ AI-ul AR da HTML

            // 1. ProceseazÄƒ Titlurile de SecÈ›iune Principale (Ex: "1. **Sumar...**" sau "**ObservaÈ›ii...**")
            // CautÄƒ linii care Ã®ncep (opÈ›ional cu spaÈ›ii) cu un numÄƒr, punct, opÈ›ional spaÈ›ii, "**", text, "**"
            processedHTML = processedHTML.replace(/^(\s*\d+\.\s*\*\*)(.*?)(\*\*)/gm, '<div class="ai-main-section-title">$1$2$3</div>');
            // CautÄƒ linii care Ã®ncep (opÈ›ional cu spaÈ›ii) cu "**", text, "**", DAR NU cele numerotate deja (evitÄƒ dubla potrivire)
            processedHTML = processedHTML.replace(/^(\s*\*\*)(?!\s*\d+\.\s)(.*?)(\*\*)/gm, '<div class="ai-main-section-title">$1$2$3</div>');
            
            // 2. ProceseazÄƒ Elementele de ListÄƒ (Ex: "* Textul listei")
            // CautÄƒ linii care Ã®ncep (opÈ›ional cu spaÈ›ii) cu un asterisc, un spaÈ›iu, apoi textul.
            // Regex-ul este conceput sÄƒ Ã®ncerce sÄƒ prindÄƒ È™i continuarea item-ului pe linii noi,
            // pÃ¢nÄƒ la o linie goalÄƒ sau un nou item/titlu.
            processedHTML = processedHTML.replace(/^\s*(\*\s+((?:.|\n(?!\n\n|^\s*(\d+\.|\*\*|\*\s))))+))/gm, (match, listItemContent) => {
                // EliminÄƒm asteriscul È™i spaÈ›iul iniÈ›ial din conÈ›inutul efectiv, pentru a nu-l afiÈ™a de douÄƒ ori cu pseudo-elementul
                const cleanedItemContent = listItemContent.replace(/^\*\s+/, '');
                return `<div class="ai-list-item">${cleanedItemContent}</div>`;
            });


            // 3. DupÄƒ procesarea structurilor (titluri, liste), Ã®nlocuieÈ™te newline-urile rÄƒmase cu <br>
            // È™i Ã®nfÄƒÈ™oarÄƒ blocurile de text non-procesate Ã®n paragrafe pentru spaÈ›iere.
            // Acest pas este mai complex de fÄƒcut corect doar cu regex-uri pentru a nu strica HTML-ul deja format.
            // O abordare mai robustÄƒ ar fi sÄƒ faci split pe \n È™i sÄƒ construieÈ™ti HTML-ul linie cu linie,
            // verificÃ¢nd dacÄƒ linia a fost deja procesatÄƒ.
            // Pentru acum, o variantÄƒ simplificatÄƒ:
            
            const lines = processedHTML.split('\n');
            let finalHtmlContent = "";
            let inParagraph = false;

            lines.forEach(line => {
                if (line.trim().startsWith('<div class="ai-main-section-title">') || line.trim().startsWith('<div class="ai-list-item">')) {
                    if (inParagraph) {
                        finalHtmlContent += '</p>'; // ÃŽnchide paragraful anterior dacÄƒ existÄƒ
                        inParagraph = false;
                    }
                    finalHtmlContent += line; // AdaugÄƒ direct div-ul procesat
                } else if (line.trim() === "") { // Linie goalÄƒ
                    if (inParagraph) {
                        finalHtmlContent += '</p>';
                        inParagraph = false;
                    }
                     finalHtmlContent += '<br>'; // Poate fi un separator <p> </p> sau un div.spacer
                } else { // Linie de text normal
                    if (!inParagraph) {
                        finalHtmlContent += '<p class="ai-text-paragraph">';
                        inParagraph = true;
                    } else {
                         finalHtmlContent += '<br>'; // Pentru linii noi Ã®n interiorul aceluiaÈ™i paragraf logic
                    }
                    finalHtmlContent += line;
                }
            });
            if (inParagraph) { // ÃŽnchide ultimul paragraf dacÄƒ a rÄƒmas deschis
                finalHtmlContent += '</p>';
            }
            
            contentWrapper.innerHTML = finalHtmlContent;
        }
        itemContainer.appendChild(contentWrapper);
        containerEl.appendChild(itemContainer);
    });
}
    function afiseazaCardJurnal(entryData) {
        const container = document.getElementById("journalEntriesContainer");
        let card = container.querySelector(`.journal-card[data-id="${entryData.id}"]`);
        const cardExists = !!card;

        const entryDate = entryData.dataIntrare || (entryData.timestampCreare?.toDate ? new Date(entryData.timestampCreare.toDate()).toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }) : 'DatÄƒ necunoscutÄƒ');
        const entryTitle = entryData.titlu || `Intrare din ${entryDate}`;

        if (!card) {
            card = document.createElement("div");
            card.className = "response-card journal-card"; 
            card.setAttribute("data-id", entryData.id);
            card.innerHTML = `
                <div class="card-header">${entryTitle}</div>
                <div class="card-content">
                    <p><strong>Data intrÄƒrii:</strong> ${entryDate}</p>
                    <p><strong>ConÈ›inut Jurnal:</strong></p>
                    <p class="journal-entry-content">${entryData.continut.replace(/\n/g, '<br>')}</p>
                    <h4>Feedback AI PsihoGPT</h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                         <button class="regenerate-feedback-button" title="RegenereazÄƒ Feedback AI">RegenereazÄƒ</button>
                         <button class="delete-last-feedback-button" title="È˜terge Ultimul Feedback AI">È˜terge Ultimul</button>
                         <button class="delete-journal-entry-button" title="È˜terge Intrarea È™i Tot Feedback-ul">È˜terge Intrarea</button>
                    </div>
                </div>`;
            card.querySelector('.card-header').addEventListener('click', () => card.classList.toggle('open'));
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); regenereazaFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); stergeUltimulFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeIntrareJurnal(entryData.id, card); });

            if (container.firstChild && container.firstChild.nodeName !== 'P') { // AdaugÄƒ Ã®naintea primului card, dacÄƒ existÄƒ È™i nu e mesajul "nici o intrare"
                container.insertBefore(card, container.firstChild);
            } else { // Altfel, dacÄƒ e gol sau are mesajul "nici o intrare", curÄƒÈ›Äƒ È™i adaugÄƒ
                if (container.firstChild && container.firstChild.nodeName === 'P') container.innerHTML = '';
                container.appendChild(card);
            }
        } else { // Update existing card's content (important for UI consistency after regeneration)
             card.querySelector('.journal-entry-content').innerHTML = entryData.continut.replace(/\n/g, '<br>');
             card.querySelector('.card-header').textContent = entryTitle; // Update title too if it changed
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, entryData.feedbackAI_history || []);
    }

    async function stergeIntrareJurnal(id, cardElement) {
        if (!confirm("È˜tergi aceastÄƒ intrare din jurnal È™i tot feedback-ul asociat?")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card')) { // VerificÄƒ dacÄƒ mai sunt carduri
                container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare Ã®n jurnal gÄƒsitÄƒ.</p>`;
            }
        } catch (error) { console.error("Eroare È™tergere intrare:", error); alert("Eroare la È™tergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        const loadingP = container.querySelector("p");
        if (!loadingP || !loadingP.textContent.includes("Se Ã®ncarcÄƒ")) { // AdaugÄƒ loadingP doar dacÄƒ nu existÄƒ deja È™i nu sunt carduri
             if(!container.querySelector('.journal-card')) {
                container.innerHTML = '<p style="text-align:center; margin-top:20px;">Se Ã®ncarcÄƒ intrÄƒrile...</p>';
             }
        }


        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            const currentCards = {}; // Map for existing cards to avoid full re-render
            container.querySelectorAll('.journal-card').forEach(card => {
                currentCards[card.dataset.id] = card;
            });

            let hasNewData = false;
            const newDocs = [];

            querySnapshot.forEach((docSnap) => {
                newDocs.push({ id: docSnap.id, ...docSnap.data() });
                if (!currentCards[docSnap.id]) {
                    hasNewData = true;
                }
                delete currentCards[docSnap.id]; // Remove from map, remaining ones will be deleted
            });

            // Remove old cards that are no longer in Firestore
            Object.values(currentCards).forEach(oldCard => oldCard.remove());
            
            if (querySnapshot.empty) {
                if(!container.querySelector('.journal-card')) container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare. ÃŽncepe prin a scrie una!</p>`;
            } else {
                 if (container.querySelector("p") && container.firstChild.nodeName === 'P') container.innerHTML = ''; // Clear "Se Ã®ncarcÄƒ..." sau "Nicio intrare..."
                 newDocs.forEach(docData => afiseazaCardJurnal(docData)); // Will update or add
            }

        } catch (error) {
            console.error("Eroare Ã®ncÄƒrcare jurnal:", error);
            if(!container.querySelector('.journal-card')) container.innerHTML = '<p style="text-align:center; color:red;">Eroare Ã®ncÄƒrcare jurnal.</p>';
        }
    }
    </script>
    <style>
    /* Reset È™i Stiluri Generale */
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f4f7f9; /* Un gri mai deschis È™i modern */
        color: #333a40; /* Text mai Ã®nchis pentru contrast */
        line-height: 1.6; font-size: 16px; /* O bazÄƒ bunÄƒ */
    }
    .journal-form-container {
        max-width: 760px; margin: 30px auto; background: #fff; padding: 30px 35px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.07); border-radius: 10px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.8em; margin-bottom: 10px; }
    h3 { font-size: 1.5em; margin-top: 40px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    /* Formular */
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d5dde5;
        transition: border-color 0.2s, box-shadow 0.2s;
    }
    textarea#journalContent { min-height: 200px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3px rgba(92, 133, 214, 0.15); outline: none;
    }
    
    /* Butoane Prompt ReflecÈ›ie */
    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 12px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 10px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 8px; }
    button.prompt-button {
        background-color: #e7f0ff; color: #4a69bd; border: 1px solid #cddcff;
        padding: 6px 12px; font-size: 0.8em; font-weight: 500; border-radius: 16px;
        cursor: pointer; transition: all 0.2s; margin-top: 0; box-shadow: none;
    }
    button.prompt-button:hover { background-color: #d6e4ff; color: #3a539b; transform: translateY(-1px); }

    /* Buton Principal Salvare */
    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 15px; padding: 12px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 2px 5px rgba(92, 133, 214, 0.2);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); box-shadow: 0 3px 7px rgba(92, 133, 214, 0.25); }
    button#saveJournalEntryButton:disabled { background: #aebfD4 !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    /* Mesaj Confirmare */
    .confirmation-message { display: none; text-align: center; padding: 12px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e6f4ea; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdebea; color: #b32d21; border-color: #f8c6c1; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    /* Vizualizare Carduri */
    .card-view {display: flex; flex-direction: column; gap: 20px; max-width: 760px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.06); overflow: hidden; }
    .response-card .card-header {
        font-weight: 500; font-size: 1.05em; cursor: pointer; background: #fdfdfe;
        padding: 12px 20px; color: #3a4550; border-bottom: 1px solid #eaeff3;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header::after {content: 'â–¼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: auto; transition: all 0.4s ease-in-out; } 
    .response-card.open .card-content { max-height: 5000px; padding: 18px 20px; }
    .response-card .card-content p {margin-bottom: 10px; color: #455058;}
    .response-card .card-content p.journal-entry-content { white-space: pre-wrap; font-size: 1em; line-height: 1.65;}
    .response-card .card-content p strong {font-weight: 600; color: #2c3840;}
    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 12px; font-size: 1em;
        border-bottom: 1px solid #e6eaee; padding-bottom: 6px;
    }
    .response-card h4:first-child {margin-top: 0;}
     .ai-feedback-history-container { margin-top: 8px; }
    .feedback-entry-card { background:#f8f9fc; padding:12px; border-left:3px solid #5c85d6; border-radius:6px; margin-bottom:12px; font-size:0.9em; line-height:1.55; }
    .feedback-timestamp { color:#606f7b; font-size:0.8em; margin-bottom:8px; font-style: italic; }
    .card-actions { text-align: right; margin-top: 18px; padding-top: 12px; border-top: 1px solid #eaeff3; display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }
    .card-actions button {
        padding: 7px 14px; font-size: 0.8em; font-weight:500; border-radius: 5px;
        transition: all 0.2s; margin-top: 0; /* Suprascrie margin-top general */
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border: 1px solid #f1c0ba;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; border-color: #c0392b;}
    button.regenerate-feedback-button { background-color:transparent; color: #228b22; border: 1px solid #b3d9b3;}
    button.regenerate-feedback-button:hover { background-color: #228b22; color: white; border-color: #228b22;}
    button.delete-last-feedback-button { background-color:transparent; color: #d39e00; border: 1px solid #ffe180;}
    button.delete-last-feedback-button:hover { background-color: #d39e00; color: white; border-color: #d39e00;}
    
    /* Responsive */
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto;}
        h2 {font-size: 1.6em;} h3 {font-size: 1.3em;}
        .card-actions {justify-content: center;}
        .card-actions button { flex-basis: calc(50% - 4px); /* DouÄƒ pe rÃ¢nd, cu gap */}
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.4em;} h3 {font-size: 1.2em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 6px;}
        button.prompt-button {padding: 5px 10px; font-size: 0.75em;}
        button#saveJournalEntryButton {padding: 10px 18px; font-size: 1em;}
        .card-actions button { flex-basis: 100%; margin-left: 0;}
    }
/* === STILURI NOI PENTRU COSMETIZAREA FEEDBACK-ULUI AI === */

.feedback-entry-card .content-ai { /* AdaugÄƒ o clasÄƒ nouÄƒ la paragraful care conÈ›ine textul AI Ã®n JS */
    font-size: 0.98em; /* AjusteazÄƒ dupÄƒ preferinÈ›Äƒ */
    line-height: 1.65;
    color: #3a4a58; /* O culoare de text puÈ›in mai soft */
}

/* 
   Pentru a stiliza titlurile È™i listele, vom folosi o abordare combinatÄƒ:
   1. ÃŽn JavaScript, cÃ¢nd primeÈ™ti `rawText` de la AI, ai putea sÄƒ-l procesezi puÈ›in
      pentru a Ã®nfÄƒÈ™ura titlurile de secÈ›iune È™i listele Ã®n tag-uri HTML simple DUPÄ‚ ce le-ai primit,
      Ã®nainte de a le afiÈ™a. Acest lucru ar oferi cel mai bun control.

   Exemplu de procesare Ã®n JavaScript (Ã®n funcÈ›ia afiseazaIstoricFeedbackJurnal):
   let aiHtml = entry.rawText.replace(/\n/g, '<br>'); // PÄƒstreazÄƒ newlines ca <br>
   // EvidenÈ›iazÄƒ titlurile (ex: "1. **Sumar Empatic Concis:**" sau "**Conexiuni Conceptuale:**")
   aiHtml = aiHtml.replace(/(\d+\.\s*\*\*|^\*\*)(.*?)(\*\*)/g, '<strong class="ai-section-title">$1$2$3</strong>');
   // EvidenÈ›iazÄƒ elementele de listÄƒ (ex: "* Ai identificat...") - puÈ›in mai tricky fÄƒrÄƒ a strica formatarea
   // S-ar putea sÄƒ fie mai simplu sÄƒ stilizezi paragrafele care Ã®ncep cu "* " direct Ã®n CSS
   
   DacÄƒ NU vrei sÄƒ modifici JavaScript-ul pentru a adÄƒuga HTML, CSS-ul de mai jos 
   este o Ã®ncercare de a stiliza pe baza textului brut, dar este mai limitat.
*/

/* Varianta 1: FÄƒrÄƒ procesare JS a textului AI (mai limitatÄƒ) */
.feedback-entry-card p[style*="white-space: pre-wrap"] strong { /* Orice text bold Ã®n feedback */
    font-weight: 600; /* Ubuntu are un bold bun la 500-700 */
    color: #2c3e50; 
}

/* ÃŽncercare de a stiliza titlurile de secÈ›iune - acest selector e general */
/* Ar fi mai bine dacÄƒ ai putea Ã®nfÄƒÈ™ura titlurile Ã®ntr-un <span> sau <strong> cu o clasÄƒ */
.feedback-entry-card p[style*="white-space: pre-wrap"] br + strong, /* Un strong dupÄƒ un <br> poate fi un titlu */
.feedback-entry-card p[style*="white-space: pre-wrap"] > strong:first-child { /* Primul strong din paragraf */
    /* Acest lucru e foarte speculativ È™i depinde de cum Gemini structureazÄƒ */
}

/* Varianta 2: Cu procesare minimÄƒ Ã®n JS pentru a adÄƒuga clase (RECOMANDATÄ‚) */
/* 
Presupunem cÄƒ Ã®n funcÈ›ia `afiseazaIstoricFeedbackJurnal` ai fÄƒcut:
let processedText = entry.rawText;
// Titlurile principale de secÈ›iune (ex: "1. **Sumar Empatic Concis:**" sau "**ObservaÈ›ii Cheie:**")
processedText = processedText.replace(/^(\d+\.\s*\*\*.*?\*\*)/gm, '<div class="ai-main-section-title">$1</div>'); // Titluri numerotate
processedText = processedText.replace(/^(\*\*[^:\n]+?\*\*)/gm, (match, p1) => { // Titluri non-numerotate (ex: **Conexiuni:**)
    if (!match.match(/^\d+\./)) { // AsigurÄƒ-te cÄƒ nu e deja capturat de regex-ul anterior
        return '<div class="ai-main-section-title">' + p1 + '</div>';
    }
    return match; 
});

// Elementele de listÄƒ (ex: "* Textul listei")
processedText = processedText.replace(/^\s*(\*\s+.*)/gm, '<div class="ai-list-item">$1</div>');

// Apoi Ã®nlocuieÈ™ti \n cu <br> DUPÄ‚ ce ai aplicat transformÄƒrile de mai sus, DAR cu grijÄƒ la <br>-urile din div-uri
// Este mai sigur sÄƒ faci split pe \n È™i sÄƒ Ã®nfÄƒÈ™ori fiecare linie Ã®ntr-un <p> sau <div> dacÄƒ nu e goalÄƒ
// SAU sÄƒ laÈ™i `white-space: pre-wrap` È™i sÄƒ stilizezi pe baza selectorilor de mai jos.
// Cel mai robust: procesezi liniile È™i Ã®nfÄƒÈ™ori ce trebuie Ã®n div-uri cu clase, apoi faci .innerHTML = processedHTML;
// ---
// Pentru HTML final: contentP.innerHTML = processedText.replace(/\n/g, '<br>'); // dupÄƒ ce ai adÄƒugat clasele.
*/

.feedback-entry-card .ai-main-section-title { /* DacÄƒ ai adÄƒugat clasa .ai-main-section-title Ã®n JS */
    display: block; /* AsigurÄƒ cÄƒ este pe linia proprie */
    font-weight: 600; /* Ubuntu medium-bold */
    color: #5c85d6; /* Culoarea ta accent */
    margin-top: 18px;
    margin-bottom: 8px;
    font-size: 1.05em;
    /* border-bottom: 1px dashed #d5dde5; */ /* OpÈ›ional, o linie subtilÄƒ */
    padding-bottom: 3px;
}
.feedback-entry-card .ai-main-section-title:first-child {
    margin-top: 5px; /* Mai puÈ›in spaÈ›iu pentru primul titlu */
}

/* Stil pentru textul bold standard din AI care NU este un titlu principal */
.feedback-entry-card p strong:not(.ai-main-section-title *) { /* SÄƒ nu stilizÄƒm ce e deja Ã®n titlu */
    font-weight: 500; /* Ubuntu medium */
    color: #3a4a58;
}

/* Stil pentru elementele de listÄƒ dacÄƒ le-ai Ã®nfÄƒÈ™urat Ã®ntr-un div cu clasa .ai-list-item */
.feedback-entry-card .ai-list-item {
    display: block; /* Fiecare pe linia sa */
    margin-left: 20px; /* Indentare */
    margin-bottom: 6px;
    position: relative; /* Pentru pseudo-elementul `::before` */
    padding-left: 18px; /* SpaÈ›iu pentru bullet */
    line-height: 1.6;
}

.feedback-entry-card .ai-list-item::before {
    content: "â€¢"; /* Bullet point */
    color: #5c85d6; /* Culoarea accent */
    font-weight: bold;
    display: inline-block; 
    position: absolute;
    left: 0;
    top: 0; /* AjusteazÄƒ fin dacÄƒ e necesar */
}

/* DacÄƒ nu poÈ›i adÄƒuga clasa .ai-list-item, poÈ›i Ã®ncerca sÄƒ stilizezi direct
   paragrafele care È˜TII cÄƒ vor Ã®ncepe cu "* ", dar e mai puÈ›in fiabil.
   Exemplu:
.feedback-entry-card p[style*="white-space: pre-wrap"]::first-line { 
    // Acest lucru e foarte problematic dacÄƒ ai È™i text normal Ã®nainte de listÄƒ Ã®n acelaÈ™i <p>
}
*/
/* === STILURI NOI PENTRU COSMETIZAREA FEEDBACK-ULUI AI (continuare) === */

.feedback-entry-card .ai-text-paragraph {
    margin-top: 5px; /* SpaÈ›iu Ã®ntre paragrafele de text normal */
    margin-bottom: 10px;
    line-height: 1.65;
}
/* AsigurÄƒ-te cÄƒ primul paragraf dupÄƒ un titlu nu are prea mult spaÈ›iu sus */
.feedback-entry-card .ai-main-section-title + .ai-text-paragraph {
    margin-top: 3px;
}
.feedback-entry-card .ai-list-item + .ai-text-paragraph {
    margin-top: 8px; /* SpaÈ›iu dacÄƒ un paragraf urmeazÄƒ dupÄƒ un item de listÄƒ */
}
    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -10px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            SpaÈ›iul tÄƒu pentru reflecÈ›ie È™i integrare.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (OpÈ›ional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: ReflecÈ›ii despre ziua de azi...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflecÈ›ie (click pentru a insera):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <label for="journalContent" style="margin-top: 20px;">Intrarea ta Ã®n jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="12" placeholder="Scrie liber aici... sau alege un ghid de mai sus."></textarea>
            
            <button type="button" id="saveJournalEntryButton">SalveazÄƒ È™i Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul IntrÄƒrilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Carduri -->
    </div>
    
</body>
</html>