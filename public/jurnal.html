<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // √énlocuie»ôte cu cheia ta realƒÉ
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- √éNLOCUIE»òTE AICI !!!
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17"; // Sau "gemini-1.5-flash-latest"
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configuratƒÉ:", "'" + GEMINI_API_KEY + "'");

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") { // Am eliminat verificarea .startsWith()
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini ini»õializat. Model Feedback Jurnal:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare criticƒÉ la ini»õializarea SDK Gemini:", e);
            let alertMessage = "Eroare la ini»õializarea serviciului AI pentru jurnal. Verifica»õi cheia API Gemini »ôi configura»õia.";
            if (e.message && e.message.toLowerCase().includes("api key not valid")) {
                alertMessage = "Cheia API Gemini nu este validƒÉ sau nu are permisiuni pentru modelul de jurnal. Verifica»õi Google Cloud Console.";
            } else if (e.message && e.message.toLowerCase().includes("quota")) {
                alertMessage = "Limita de utilizare pentru API-ul Gemini a fost atinsƒÉ (posibil pentru modelul de jurnal).";
            }
            alert(alertMessage + " Func»õionalitatea AI va fi limitatƒÉ.");
            geminiModelJournalFeedback = null;
        }
    } else  {
        console.warn(`Jurnal Terapeutic: Cheia API Gemini este goalƒÉ sau lipse»ôte. Func»õionalitatea AI va fi dezactivatƒÉ.`);
        alert("Jurnal Terapeutic: Cheia API Gemini nu este configuratƒÉ. Func»õionalitatea AI pentru jurnal va fi dezactivatƒÉ.");
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
    };

    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [
            { label: "ExploreazƒÉ o emo»õie", text: "AstƒÉzi vreau sƒÉ explorez emo»õia de [NUME»òTE EMO»öIA].\n\nCum se simte √Æn corpul meu? [DESCRIE SENZA»öIILE]\nCe g√¢nduri sunt asociate? [NOTEAZƒÇ G√ÇNDURILE]\n√én ce context a apƒÉrut? [DESCRIE SITUA»öIA]\nCe nevoie ar putea semnala? [REFLECTEAZƒÇ]\nCum a»ô putea oferi compasiune? [AC»öIUNE COMPASIONALƒÇ]\n" },
            { label: "AnalizeazƒÉ o situa»õie", text: "Situa»õia care mƒÉ preocupƒÉ este: [DESCRIE SITUA»öIA]\n\nCe s-a √Ænt√¢mplat exact? (Fapte)\nInterpretarea mea ini»õialƒÉ: [G√ÇNDURI AUTOMATE]\nEmo»õiile principale: [LISTEAZƒÇ EMO»öIILE]\nO altƒÉ perspectivƒÉ: [REFRAMING]\nCe am √ÆnvƒÉ»õat/pot √ÆnvƒÉ»õa? [LEC»öII]\n" },
            { label: "Dialog Voce CriticƒÉ", text: "Vocea mea criticƒÉ √Æmi spune: \"[MESAJUL CRITIC]\"\n\nMƒÉ face sƒÉ mƒÉ simt: [EMO»öII GENERATE]\nDin perspectiva Adultului SƒÉnƒÉtos, a»ô rƒÉspunde: \"[RƒÇSPUNS COMPASIONAL]\"\nO nevoie ascunsƒÉ: [NEVOIA SUBIACENTƒÇ]\n" },
            { label: "Recuno»ôtin»õƒÉ & Resurse", text: "AstƒÉzi sunt recunoscƒÉtor/oare pentru:\n1. \n2. \n3. \n\nO resursƒÉ interioarƒÉ pe care mƒÉ pot baza: \nUn gest de auto-√Ængrijire: \n" },
            { label: "üåÄ Ritual Reconstruc»õie InterioarƒÉ", // Am adƒÉugat un emoji
        text: `üß≠ MASTER TEMPLATE ‚Äì Scriere TerapeuticƒÉ de Integrare »ôi Vindecare\n` +
              `Denumire: ‚ÄûRitual de reconstruc»õie interioarƒÉ‚Äù\n` +
              `Scop: Eliberare, Clarificare, Con»õinere, √én»õelepciune, Direc»õie\n\n` +
              `I. üîç INVITA»öIE LA AUTENTICITATE\n` +
              `‚ÄûCe parte din mine cere aten»õie acum?‚Äù\n\n` +
              `   * Ce trƒÉiesc cu adevƒÉrat, fƒÉrƒÉ filtru, fƒÉrƒÉ poveste cosmetizatƒÉ?\n` +
              `   * Ce mi-e ru»ôine sƒÉ simt sau sƒÉ recunosc chiar »ôi √Æn scris?\n` +
              `   * Ce parte din mine se simte exclusƒÉ, neauzitƒÉ, ignoratƒÉ?\n` +
              `   [RƒÇSPUNSUL TƒÇU AICI]\n\n` + // Am adƒÉugat un placeholder
              `II. üåä CONTAINERE EMO»öIONALE\n` +
              `‚ÄûCe simte corpul meu? Unde locuie»ôte durerea?‚Äù\n\n` +
              `   * Unde simt emo»õia √Æn corp? Cum se manifestƒÉ? (Tensiune, √Æn»õepƒÉturi, etc.)\n` +
              `   * DacƒÉ ar avea o culoare, formƒÉ, texturƒÉ ‚Äì cum ar arƒÉta?\n` +
              `   * Pot respira √Æn acea zonƒÉ 3 minute, fƒÉrƒÉ sƒÉ fug?\n` +
              `   [RƒÇSPUNSUL TƒÇU AICI]\n\n` +
              `III. üß† DECODIFICARE NARATIVƒÇ\n` +
              `‚ÄûCe poveste √Æmi spun? Este √ÆntreagƒÉ?‚Äù\n\n` +
              `   * Ce nara»õiune incon»ôtientƒÉ guverneazƒÉ trƒÉirea mea? (ex: ‚ÄûNu sunt dorit.‚Äù)\n` +
              `   * De unde vine aceastƒÉ nara»õiune? C√¢nd am mai trƒÉit ceva similar?\n` +
              `   * Ce parte din mine (copil rƒÉnit, etc.) scrie aceastƒÉ poveste?\n` +
              `   [RƒÇSPUNSUL TƒÇU AICI]\n\n` +
              `IV. üß© INTEGRARE EXPLICATIVƒÇ\n` +
              `‚ÄûCe √Æn»õeleg nou despre mine din aceastƒÉ durere?‚Äù\n\n` +
              `   * Ce nevoi profunde au fost ignorate sau negate?\n` +
              `   * Ce am protejat, de fapt, prin reac»õia mea?\n` +
              `   * Ce emo»õii contradictorii coexistƒÉ √Æn mine »ôi ce spun ele?\n` +
              `   [RƒÇSPUNSUL TƒÇU AICI]\n\n` +
              `V. ü™û COMPASIUNE »òI BL√ÇNDE»öE\n` +
              `‚ÄûCum pot fi pƒÉrinte pentru mine acum?‚Äù\n\n` +
              `   * DacƒÉ mi-a»ô »õine partea rƒÉnitƒÉ √Æn bra»õe, ce i-a»ô spune?\n` +
              `   * Ce a»ô vrea sƒÉ aud din partea unei figuri ideale de sus»õinere?\n` +
              `   * Pot lƒÉsa iubirea, nu logica, sƒÉ conducƒÉ acest moment?\n` +
              `   [RƒÇSPUNSUL TƒÇU AICI]\n\n` +
              `VI. üîÆ RECONFIGURARE IDENTITARƒÇ\n` +
              `‚ÄûCine sunt eu dincolo de aceastƒÉ ranƒÉ?‚Äù\n\n` +
              `   * Ce adevƒÉr despre mine rƒÉm√¢ne valabil, chiar »ôi √Æn durere?\n` +
              `   * Cine devin dacƒÉ √ÆnvƒÉ»õ sƒÉ stau cu mine √Æn acest spa»õiu?\n` +
              `   * DacƒÉ a»ô fi un personaj simbolic acum, cine a»ô fi?\n` +
              `   [RƒÇSPUNSUL TƒÇU AICI]\n\n` +
              `VII. ‚úçÔ∏è ACTUL SACRU DE ALEGERE\n` +
              `‚ÄûCe aleg de azi, pentru mine?‚Äù\n\n` +
              `   * Ce meritƒÉ sƒÉ las sƒÉ plece?\n` +
              `   * Ce √Æmi iau ca √ÆnvƒÉ»õƒÉturƒÉ de √Æncredere √Æn via»õƒÉ?\n` +
              `   * Ce ritual zilnic/mic obicei pot √Æncepe pentru a onora aceastƒÉ transformare?\n` +
              `   [RƒÇSPUNSUL TƒÇU AICI]\n\n` +
              `VIII. (Op»õional) üìú SCRISOARE-RITUAL\n` +
              `Scrie o scrisoare cƒÉtre...\n` +
              `   [ALEGE »òI SCRIE AICI]\n`
    }
        ];
        promptsContainerEl.innerHTML = ''; // Clear previous
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "InsereazƒÉ acest ghid √Æn jurnal";
            button.onclick = () => {
                if (journalTextarea.value.trim() !== "" && !confirm("Vrei sƒÉ √Ænlocuie»ôti textul curent cu acest ghid? OK pentru a √Ænlocui, Anulare pentru a adƒÉuga la sf√¢r»ôit.")) {
                    journalTextarea.value += "\n\n---\n" + prompt.text;
                } else {
                    journalTextarea.value = prompt.text;
                }
                journalTextarea.focus();
                journalTextarea.scrollTop = journalTextarea.scrollHeight;
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) return "EROARE: Model AI neini»õializat (jurnal).";
        try {
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.72, ...generationConfigOptions }
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare opritƒÉ (Motiv: ${response.candidates[0].finishReason}).`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}).`;
            }
            return "EROARE Gemini: RƒÉspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            return `EROARE Gemini: ${error.message || "Eroare API."}`;
        }
    }

    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: Func»õionalitatea AI pentru jurnal nu este disponibilƒÉ.";
        
        const promptJurnalPentruRitual = `
"E»ôti PsihoGPT, un partener de dialog avansat, un psihoterapeut experimentat format √Æn toate abordarile moderne de psihoterapie. Vei integra teorie relevanta, vei cita si vei parafraza.
Specializat √Æn analiza profundƒÉ a scrierilor terapeutice structurate. 
Tocmai am completat un exerci»õiu numit 'Ritual de Reconstruc»õie InterioarƒÉ', care are urmƒÉtoarele sec»õiuni: I. Invita»õie la Autenticitate, II. Continere Emotionala, III. Decodificare NarativƒÉ, IV. Integrare ExplicativƒÉ, V. Compasiune »ôi Bl√¢nde»õe, VI. Reconfigurare IdentitarƒÉ, VII. Actul Sacru de Alegere, »ôi op»õional VIII. Scrisoare-Ritual.

Scopul tƒÉu este sƒÉ-mi oferi un feedback care:
1.  **Recunoa»ôte »ôi valideazƒÉ** efortul »ôi vulnerabilitatea implicate √Æn completarea acestui ritual.
2.  **ReflectƒÉ temele »ôi insight-urile cheie** care reies DIN FIECARE SEC»öIUNE a ritualului meu (unde am oferit rƒÉspunsuri semnificative). Fii specific »ôi referƒÉ-te la con»õinutul meu.
3.  **IdentificƒÉ conexiuni** √Æntre diferitele sec»õiuni ale ritualului (ex: cum autenticitatea din sec»õiunea I se leagƒÉ de nevoia identificatƒÉ √Æn IV sau de alegerea din VII).
4.  **Pune √ÆntrebƒÉri de aprofundare** care sƒÉ mƒÉ ajute sƒÉ integrez »ôi mai mult cele descoperite (c√¢te 1-2 √ÆntrebƒÉri per sec»õiune relevantƒÉ sau c√¢teva √ÆntrebƒÉri globale de sintezƒÉ).
5.  **Oglinde»ôte limbajul »ôi conceptele psihoterapeutice** pe care le-am folosit sau care par relevante pentru rƒÉspunsurile mele (ex: dacƒÉ vorbesc despre 'copilul interior', po»õi reflecta pe marginea acestuia).
6.  **√éncurajeazƒÉ »ôi sus»õine** procesul de transformare schi»õat √Æn sec»õiunea VII (Actul Sacru de Alegere).

Abordarea ta sƒÉ fie profund empaticƒÉ, analiticƒÉ, dar »ôi provocatoare constructiv. Sunt familiarizat cu concepte terapeutice. Folose»ôte un format clar, poate relu√¢nd titlurile sec»õiunilor mele »ôi oferind comentarii/√ÆntrebƒÉri specifice pentru fiecare."

Intrarea mea completatƒÉ √Æn cadrul 'Ritualului de Reconstruc»õie InterioarƒÉ' este:
Titlu: ${entryData.titlu}
Con»õinut (cu sec»õiunile marcate):
---
${entryData.continut} 
---
// Nota pentru AI: RƒÉspunsurile mele sunt sub fiecare set de √ÆntrebƒÉri/sec»õiune a Ritualului.

OferƒÉ-mi un feedback detaliat »ôi structurat. Mul»õumesc!`;

        console.log("Trimitere prompt cƒÉtre Gemini (jurnal):", promptJurnal.substring(0, 100) + "...");
        const feedbackText = await callGeminiAPI(promptJurnal, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId);
    }
    
    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId) {
        const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva √Æn jurnal."); return; }

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salveazƒÉ..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se genereazƒÉ AI...";
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id);
            
            const docSnapshot = await getDoc(docRef);
            if (docSnapshot.exists()) afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            
            journalTextarea.value = ""; if (journalTitleInput) journalTitleInput.value = "";
            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvatƒÉ. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvatƒÉ »ôi feedback AI generat!';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 9000);
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau generare feedback.';
            confirmationMsg.className = 'confirmation-message error';
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
        } finally {
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se genereazƒÉ..."; btn.disabled = true; }

        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { alert("Intrarea nu existƒÉ."); return; }
            await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId);
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); // Re-fetch
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
            }
            alert("Feedback AI regenerat!");
        } catch (e) { console.error("Eroare regenerare:", e); alert("Eroare la regenerare feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        if (!confirm("»òtergi ultimul feedback AI pentru aceastƒÉ intrare?")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se »ôterge..."; btn.disabled = true; }

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                alert("Nu existƒÉ feedback de »ôters."); return;
            }
            const history = entrySnap.data().feedbackAI_history;
            const lastFeedback = history.pop(); // Scoate ultimul »ôi √Æl avem √Æn `lastFeedback`

            await updateDoc(entryDocRef, {
                feedbackAI_history: history, // SalveazƒÉ istoricul fƒÉrƒÉ ultimul element
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            alert("Ultimul feedback AI »ôters.");
        } catch (e) { console.error("Eroare »ôtergere ultim feedback:", e); alert("Eroare la »ôtergere feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, feedbackHistory) {
    containerEl.innerHTML = ''; // Gole»ôte containerul existent

    if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
        const noHistoryMsg = document.createElement("p");
        noHistoryMsg.textContent = "Niciun feedback AI generat pentru aceastƒÉ intrare.";
        noHistoryMsg.style.fontStyle = "italic";
        noHistoryMsg.style.textAlign = "center";
        noHistoryMsg.style.padding = "10px 0";
        containerEl.appendChild(noHistoryMsg);
        return;
    }

    feedbackHistory.slice().reverse().forEach((entry, index) => {
        const itemContainer = document.createElement("div");
        itemContainer.className = "feedback-entry-card"; // Clasa generalƒÉ pentru un card de feedback

        const timestampAndModel = document.createElement("p");
        timestampAndModel.className = "feedback-timestamp";
        timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - ${entry.model || 'N/A'})`;
        itemContainer.appendChild(timestampAndModel);

        const contentWrapper = document.createElement("div"); // Un wrapper pentru con»õinutul AI
        contentWrapper.className = "content-ai"; // Pentru stilizarea generalƒÉ a textului AI

        if (entry.error) {
            const errorP = document.createElement("p");
            errorP.style.color = "red";
            errorP.style.fontWeight = "bold";
            errorP.style.whiteSpace = "pre-wrap";
            errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
            contentWrapper.appendChild(errorP);
        } else {
            let processedHTML = entry.rawText || 'Con»õinut indisponibil.';

            // SecurizeazƒÉ HTML-ul brut √Ænainte de a injecta regex-uri (minimal)
            // Acest pas este important dacƒÉ textul ar putea con»õine caractere care interfereazƒÉ cu HTML-ul.
            // Dar, pentru moment, ne bazƒÉm cƒÉ textul e predominant text simplu cu markdown-ul Gemini.
            // processedHTML = processedHTML.replace(/</g, "<").replace(/>/g, ">"); // Prea agresiv, stricƒÉ dacƒÉ AI-ul AR da HTML

            // 1. ProceseazƒÉ Titlurile de Sec»õiune Principale (Ex: "1. **Sumar...**" sau "**Observa»õii...**")
            // CautƒÉ linii care √Æncep (op»õional cu spa»õii) cu un numƒÉr, punct, op»õional spa»õii, "**", text, "**"
            processedHTML = processedHTML.replace(/^(\s*\d+\.\s*\*\*)(.*?)(\*\*)/gm, '<div class="ai-main-section-title">$1$2$3</div>');
            // CautƒÉ linii care √Æncep (op»õional cu spa»õii) cu "**", text, "**", DAR NU cele numerotate deja (evitƒÉ dubla potrivire)
            processedHTML = processedHTML.replace(/^(\s*\*\*)(?!\s*\d+\.\s)(.*?)(\*\*)/gm, '<div class="ai-main-section-title">$1$2$3</div>');
            
            // 2. ProceseazƒÉ Elementele de ListƒÉ (Ex: "* Textul listei")
            // CautƒÉ linii care √Æncep (op»õional cu spa»õii) cu un asterisc, un spa»õiu, apoi textul.
            // Regex-ul este conceput sƒÉ √Æncerce sƒÉ prindƒÉ »ôi continuarea item-ului pe linii noi,
            // p√¢nƒÉ la o linie goalƒÉ sau un nou item/titlu.
            processedHTML = processedHTML.replace(/^\s*(\*\s+((?:.|\n(?!\n\n|^\s*(\d+\.|\*\*|\*\s))))+))/gm, (match, listItemContent) => {
                // EliminƒÉm asteriscul »ôi spa»õiul ini»õial din con»õinutul efectiv, pentru a nu-l afi»ôa de douƒÉ ori cu pseudo-elementul
                const cleanedItemContent = listItemContent.replace(/^\*\s+/, '');
                return `<div class="ai-list-item">${cleanedItemContent}</div>`;
            });


            // 3. DupƒÉ procesarea structurilor (titluri, liste), √Ænlocuie»ôte newline-urile rƒÉmase cu <br>
            // »ôi √ÆnfƒÉ»ôoarƒÉ blocurile de text non-procesate √Æn paragrafe pentru spa»õiere.
            // Acest pas este mai complex de fƒÉcut corect doar cu regex-uri pentru a nu strica HTML-ul deja format.
            // O abordare mai robustƒÉ ar fi sƒÉ faci split pe \n »ôi sƒÉ construie»ôti HTML-ul linie cu linie,
            // verific√¢nd dacƒÉ linia a fost deja procesatƒÉ.
            // Pentru acum, o variantƒÉ simplificatƒÉ:
            
            const lines = processedHTML.split('\n');
            let finalHtmlContent = "";
            let inParagraph = false;

            lines.forEach(line => {
                if (line.trim().startsWith('<div class="ai-main-section-title">') || line.trim().startsWith('<div class="ai-list-item">')) {
                    if (inParagraph) {
                        finalHtmlContent += '</p>'; // √énchide paragraful anterior dacƒÉ existƒÉ
                        inParagraph = false;
                    }
                    finalHtmlContent += line; // AdaugƒÉ direct div-ul procesat
                } else if (line.trim() === "") { // Linie goalƒÉ
                    if (inParagraph) {
                        finalHtmlContent += '</p>';
                        inParagraph = false;
                    }
                     finalHtmlContent += '<br>'; // Poate fi un separator <p> </p> sau un div.spacer
                } else { // Linie de text normal
                    if (!inParagraph) {
                        finalHtmlContent += '<p class="ai-text-paragraph">';
                        inParagraph = true;
                    } else {
                         finalHtmlContent += '<br>'; // Pentru linii noi √Æn interiorul aceluia»ôi paragraf logic
                    }
                    finalHtmlContent += line;
                }
            });
            if (inParagraph) { // √énchide ultimul paragraf dacƒÉ a rƒÉmas deschis
                finalHtmlContent += '</p>';
            }
            
            contentWrapper.innerHTML = finalHtmlContent;
        }
        itemContainer.appendChild(contentWrapper);
        containerEl.appendChild(itemContainer);
    });
}
    function afiseazaCardJurnal(entryData) {
        const container = document.getElementById("journalEntriesContainer");
        let card = container.querySelector(`.journal-card[data-id="${entryData.id}"]`);
        const cardExists = !!card;

        const entryDate = entryData.dataIntrare || (entryData.timestampCreare?.toDate ? new Date(entryData.timestampCreare.toDate()).toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }) : 'DatƒÉ necunoscutƒÉ');
        const entryTitle = entryData.titlu || `Intrare din ${entryDate}`;

        if (!card) {
            card = document.createElement("div");
            card.className = "response-card journal-card"; 
            card.setAttribute("data-id", entryData.id);
            card.innerHTML = `
                <div class="card-header">${entryTitle}</div>
                <div class="card-content">
                    <p><strong>Data intrƒÉrii:</strong> ${entryDate}</p>
                    <p><strong>Con»õinut Jurnal:</strong></p>
                    <p class="journal-entry-content">${entryData.continut.replace(/\n/g, '<br>')}</p>
                    <h4>Feedback AI PsihoGPT</h4>
                    <div class="ai-feedback-history-container"></div>
                    <div class="card-actions">
                         <button class="regenerate-feedback-button" title="RegenereazƒÉ Feedback AI">RegenereazƒÉ</button>
                         <button class="delete-last-feedback-button" title="»òterge Ultimul Feedback AI">»òterge Ultimul</button>
                         <button class="delete-journal-entry-button" title="»òterge Intrarea »ôi Tot Feedback-ul">»òterge Intrarea</button>
                    </div>
                </div>`;
            card.querySelector('.card-header').addEventListener('click', () => card.classList.toggle('open'));
            card.querySelector('.regenerate-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); regenereazaFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-last-feedback-button').addEventListener('click', (e) => { e.stopPropagation(); stergeUltimulFeedbackJurnal(entryData.id); });
            card.querySelector('.delete-journal-entry-button').addEventListener('click', (e) => { e.stopPropagation(); stergeIntrareJurnal(entryData.id, card); });

            if (container.firstChild && container.firstChild.nodeName !== 'P') { // AdaugƒÉ √Ænaintea primului card, dacƒÉ existƒÉ »ôi nu e mesajul "nici o intrare"
                container.insertBefore(card, container.firstChild);
            } else { // Altfel, dacƒÉ e gol sau are mesajul "nici o intrare", curƒÉ»õƒÉ »ôi adaugƒÉ
                if (container.firstChild && container.firstChild.nodeName === 'P') container.innerHTML = '';
                container.appendChild(card);
            }
        } else { // Update existing card's content (important for UI consistency after regeneration)
             card.querySelector('.journal-entry-content').innerHTML = entryData.continut.replace(/\n/g, '<br>');
             card.querySelector('.card-header').textContent = entryTitle; // Update title too if it changed
        }
        
        const feedbackContainer = card.querySelector('.ai-feedback-history-container');
        if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, entryData.feedbackAI_history || []);
    }

    async function stergeIntrareJurnal(id, cardElement) {
        if (!confirm("»òtergi aceastƒÉ intrare din jurnal »ôi tot feedback-ul asociat?")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card')) { // VerificƒÉ dacƒÉ mai sunt carduri
                container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare √Æn jurnal gƒÉsitƒÉ.</p>`;
            }
        } catch (error) { console.error("Eroare »ôtergere intrare:", error); alert("Eroare la »ôtergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        const loadingP = container.querySelector("p");
        if (!loadingP || !loadingP.textContent.includes("Se √ÆncarcƒÉ")) { // AdaugƒÉ loadingP doar dacƒÉ nu existƒÉ deja »ôi nu sunt carduri
             if(!container.querySelector('.journal-card')) {
                container.innerHTML = '<p style="text-align:center; margin-top:20px;">Se √ÆncarcƒÉ intrƒÉrile...</p>';
             }
        }


        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            const currentCards = {}; // Map for existing cards to avoid full re-render
            container.querySelectorAll('.journal-card').forEach(card => {
                currentCards[card.dataset.id] = card;
            });

            let hasNewData = false;
            const newDocs = [];

            querySnapshot.forEach((docSnap) => {
                newDocs.push({ id: docSnap.id, ...docSnap.data() });
                if (!currentCards[docSnap.id]) {
                    hasNewData = true;
                }
                delete currentCards[docSnap.id]; // Remove from map, remaining ones will be deleted
            });

            // Remove old cards that are no longer in Firestore
            Object.values(currentCards).forEach(oldCard => oldCard.remove());
            
            if (querySnapshot.empty) {
                if(!container.querySelector('.journal-card')) container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare. √éncepe prin a scrie una!</p>`;
            } else {
                 if (container.querySelector("p") && container.firstChild.nodeName === 'P') container.innerHTML = ''; // Clear "Se √ÆncarcƒÉ..." sau "Nicio intrare..."
                 newDocs.forEach(docData => afiseazaCardJurnal(docData)); // Will update or add
            }

        } catch (error) {
            console.error("Eroare √ÆncƒÉrcare jurnal:", error);
            if(!container.querySelector('.journal-card')) container.innerHTML = '<p style="text-align:center; color:red;">Eroare √ÆncƒÉrcare jurnal.</p>';
        }
    }
    </script>
    <style>
    /* Reset »ôi Stiluri Generale */
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f4f7f9; /* Un gri mai deschis »ôi modern */
        color: #333a40; /* Text mai √Ænchis pentru contrast */
        line-height: 1.6; font-size: 16px; /* O bazƒÉ bunƒÉ */
    }
    .journal-form-container {
        max-width: 760px; margin: 30px auto; background: #fff; padding: 30px 35px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.07); border-radius: 10px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.8em; margin-bottom: 10px; }
    h3 { font-size: 1.5em; margin-top: 40px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    /* Formular */
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d5dde5;
        transition: border-color 0.2s, box-shadow 0.2s;
    }
    textarea#journalContent { min-height: 200px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3px rgba(92, 133, 214, 0.15); outline: none;
    }
    
    /* Butoane Prompt Reflec»õie */
    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 12px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 10px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 8px; }
    button.prompt-button {
        background-color: #e7f0ff; color: #4a69bd; border: 1px solid #cddcff;
        padding: 6px 12px; font-size: 0.8em; font-weight: 500; border-radius: 16px;
        cursor: pointer; transition: all 0.2s; margin-top: 0; box-shadow: none;
    }
    button.prompt-button:hover { background-color: #d6e4ff; color: #3a539b; transform: translateY(-1px); }

    /* Buton Principal Salvare */
    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 15px; padding: 12px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 2px 5px rgba(92, 133, 214, 0.2);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); box-shadow: 0 3px 7px rgba(92, 133, 214, 0.25); }
    button#saveJournalEntryButton:disabled { background: #aebfD4 !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    /* Mesaj Confirmare */
    .confirmation-message { display: none; text-align: center; padding: 12px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e6f4ea; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdebea; color: #b32d21; border-color: #f8c6c1; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    /* Vizualizare Carduri */
    .card-view {display: flex; flex-direction: column; gap: 20px; max-width: 760px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.06); overflow: hidden; }
    .response-card .card-header {
        font-weight: 500; font-size: 1.05em; cursor: pointer; background: #fdfdfe;
        padding: 12px 20px; color: #3a4550; border-bottom: 1px solid #eaeff3;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header::after {content: '‚ñº'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: auto; transition: all 0.4s ease-in-out; } 
    .response-card.open .card-content { max-height: 5000px; padding: 18px 20px; }
    .response-card .card-content p {margin-bottom: 10px; color: #455058;}
    .response-card .card-content p.journal-entry-content { white-space: pre-wrap; font-size: 1em; line-height: 1.65;}
    .response-card .card-content p strong {font-weight: 600; color: #2c3840;}
    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 12px; font-size: 1em;
        border-bottom: 1px solid #e6eaee; padding-bottom: 6px;
    }
    .response-card h4:first-child {margin-top: 0;}
     .ai-feedback-history-container { margin-top: 8px; }
    .feedback-entry-card { background:#f8f9fc; padding:12px; border-left:3px solid #5c85d6; border-radius:6px; margin-bottom:12px; font-size:0.9em; line-height:1.55; }
    .feedback-timestamp { color:#606f7b; font-size:0.8em; margin-bottom:8px; font-style: italic; }
    .card-actions { text-align: right; margin-top: 18px; padding-top: 12px; border-top: 1px solid #eaeff3; display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }
    .card-actions button {
        padding: 7px 14px; font-size: 0.8em; font-weight:500; border-radius: 5px;
        transition: all 0.2s; margin-top: 0; /* Suprascrie margin-top general */
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border: 1px solid #f1c0ba;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; border-color: #c0392b;}
    button.regenerate-feedback-button { background-color:transparent; color: #228b22; border: 1px solid #b3d9b3;}
    button.regenerate-feedback-button:hover { background-color: #228b22; color: white; border-color: #228b22;}
    button.delete-last-feedback-button { background-color:transparent; color: #d39e00; border: 1px solid #ffe180;}
    button.delete-last-feedback-button:hover { background-color: #d39e00; color: white; border-color: #d39e00;}
    
    /* Responsive */
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto;}
        h2 {font-size: 1.6em;} h3 {font-size: 1.3em;}
        .card-actions {justify-content: center;}
        .card-actions button { flex-basis: calc(50% - 4px); /* DouƒÉ pe r√¢nd, cu gap */}
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.4em;} h3 {font-size: 1.2em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 6px;}
        button.prompt-button {padding: 5px 10px; font-size: 0.75em;}
        button#saveJournalEntryButton {padding: 10px 18px; font-size: 1em;}
        .card-actions button { flex-basis: 100%; margin-left: 0;}
    }
/* === STILURI NOI PENTRU COSMETIZAREA FEEDBACK-ULUI AI === */

.feedback-entry-card .content-ai { /* AdaugƒÉ o clasƒÉ nouƒÉ la paragraful care con»õine textul AI √Æn JS */
    font-size: 0.98em; /* AjusteazƒÉ dupƒÉ preferin»õƒÉ */
    line-height: 1.65;
    color: #3a4a58; /* O culoare de text pu»õin mai soft */
}

/* 
   Pentru a stiliza titlurile »ôi listele, vom folosi o abordare combinatƒÉ:
   1. √én JavaScript, c√¢nd prime»ôti `rawText` de la AI, ai putea sƒÉ-l procesezi pu»õin
      pentru a √ÆnfƒÉ»ôura titlurile de sec»õiune »ôi listele √Æn tag-uri HTML simple DUPƒÇ ce le-ai primit,
      √Ænainte de a le afi»ôa. Acest lucru ar oferi cel mai bun control.

   Exemplu de procesare √Æn JavaScript (√Æn func»õia afiseazaIstoricFeedbackJurnal):
   let aiHtml = entry.rawText.replace(/\n/g, '<br>'); // PƒÉstreazƒÉ newlines ca <br>
   // Eviden»õiazƒÉ titlurile (ex: "1. **Sumar Empatic Concis:**" sau "**Conexiuni Conceptuale:**")
   aiHtml = aiHtml.replace(/(\d+\.\s*\*\*|^\*\*)(.*?)(\*\*)/g, '<strong class="ai-section-title">$1$2$3</strong>');
   // Eviden»õiazƒÉ elementele de listƒÉ (ex: "* Ai identificat...") - pu»õin mai tricky fƒÉrƒÉ a strica formatarea
   // S-ar putea sƒÉ fie mai simplu sƒÉ stilizezi paragrafele care √Æncep cu "* " direct √Æn CSS
   
   DacƒÉ NU vrei sƒÉ modifici JavaScript-ul pentru a adƒÉuga HTML, CSS-ul de mai jos 
   este o √Æncercare de a stiliza pe baza textului brut, dar este mai limitat.
*/

/* Varianta 1: FƒÉrƒÉ procesare JS a textului AI (mai limitatƒÉ) */
.feedback-entry-card p[style*="white-space: pre-wrap"] strong { /* Orice text bold √Æn feedback */
    font-weight: 600; /* Ubuntu are un bold bun la 500-700 */
    color: #2c3e50; 
}

/* √éncercare de a stiliza titlurile de sec»õiune - acest selector e general */
/* Ar fi mai bine dacƒÉ ai putea √ÆnfƒÉ»ôura titlurile √Æntr-un <span> sau <strong> cu o clasƒÉ */
.feedback-entry-card p[style*="white-space: pre-wrap"] br + strong, /* Un strong dupƒÉ un <br> poate fi un titlu */
.feedback-entry-card p[style*="white-space: pre-wrap"] > strong:first-child { /* Primul strong din paragraf */
    /* Acest lucru e foarte speculativ »ôi depinde de cum Gemini structureazƒÉ */
}

/* Varianta 2: Cu procesare minimƒÉ √Æn JS pentru a adƒÉuga clase (RECOMANDATƒÇ) */
/* 
Presupunem cƒÉ √Æn func»õia `afiseazaIstoricFeedbackJurnal` ai fƒÉcut:
let processedText = entry.rawText;
// Titlurile principale de sec»õiune (ex: "1. **Sumar Empatic Concis:**" sau "**Observa»õii Cheie:**")
processedText = processedText.replace(/^(\d+\.\s*\*\*.*?\*\*)/gm, '<div class="ai-main-section-title">$1</div>'); // Titluri numerotate
processedText = processedText.replace(/^(\*\*[^:\n]+?\*\*)/gm, (match, p1) => { // Titluri non-numerotate (ex: **Conexiuni:**)
    if (!match.match(/^\d+\./)) { // AsigurƒÉ-te cƒÉ nu e deja capturat de regex-ul anterior
        return '<div class="ai-main-section-title">' + p1 + '</div>';
    }
    return match; 
});

// Elementele de listƒÉ (ex: "* Textul listei")
processedText = processedText.replace(/^\s*(\*\s+.*)/gm, '<div class="ai-list-item">$1</div>');

// Apoi √Ænlocuie»ôti \n cu <br> DUPƒÇ ce ai aplicat transformƒÉrile de mai sus, DAR cu grijƒÉ la <br>-urile din div-uri
// Este mai sigur sƒÉ faci split pe \n »ôi sƒÉ √ÆnfƒÉ»ôori fiecare linie √Æntr-un <p> sau <div> dacƒÉ nu e goalƒÉ
// SAU sƒÉ la»ôi `white-space: pre-wrap` »ôi sƒÉ stilizezi pe baza selectorilor de mai jos.
// Cel mai robust: procesezi liniile »ôi √ÆnfƒÉ»ôori ce trebuie √Æn div-uri cu clase, apoi faci .innerHTML = processedHTML;
// ---
// Pentru HTML final: contentP.innerHTML = processedText.replace(/\n/g, '<br>'); // dupƒÉ ce ai adƒÉugat clasele.
*/

.feedback-entry-card .ai-main-section-title { /* DacƒÉ ai adƒÉugat clasa .ai-main-section-title √Æn JS */
    display: block; /* AsigurƒÉ cƒÉ este pe linia proprie */
    font-weight: 600; /* Ubuntu medium-bold */
    color: #5c85d6; /* Culoarea ta accent */
    margin-top: 18px;
    margin-bottom: 8px;
    font-size: 1.05em;
    /* border-bottom: 1px dashed #d5dde5; */ /* Op»õional, o linie subtilƒÉ */
    padding-bottom: 3px;
}
.feedback-entry-card .ai-main-section-title:first-child {
    margin-top: 5px; /* Mai pu»õin spa»õiu pentru primul titlu */
}

/* Stil pentru textul bold standard din AI care NU este un titlu principal */
.feedback-entry-card p strong:not(.ai-main-section-title *) { /* SƒÉ nu stilizƒÉm ce e deja √Æn titlu */
    font-weight: 500; /* Ubuntu medium */
    color: #3a4a58;
}

/* Stil pentru elementele de listƒÉ dacƒÉ le-ai √ÆnfƒÉ»ôurat √Æntr-un div cu clasa .ai-list-item */
.feedback-entry-card .ai-list-item {
    display: block; /* Fiecare pe linia sa */
    margin-left: 20px; /* Indentare */
    margin-bottom: 6px;
    position: relative; /* Pentru pseudo-elementul `::before` */
    padding-left: 18px; /* Spa»õiu pentru bullet */
    line-height: 1.6;
}

.feedback-entry-card .ai-list-item::before {
    content: "‚Ä¢"; /* Bullet point */
    color: #5c85d6; /* Culoarea accent */
    font-weight: bold;
    display: inline-block; 
    position: absolute;
    left: 0;
    top: 0; /* AjusteazƒÉ fin dacƒÉ e necesar */
}

/* DacƒÉ nu po»õi adƒÉuga clasa .ai-list-item, po»õi √Æncerca sƒÉ stilizezi direct
   paragrafele care »òTII cƒÉ vor √Æncepe cu "* ", dar e mai pu»õin fiabil.
   Exemplu:
.feedback-entry-card p[style*="white-space: pre-wrap"]::first-line { 
    // Acest lucru e foarte problematic dacƒÉ ai »ôi text normal √Ænainte de listƒÉ √Æn acela»ôi <p>
}
*/
/* === STILURI NOI PENTRU COSMETIZAREA FEEDBACK-ULUI AI (continuare) === */

.feedback-entry-card .ai-text-paragraph {
    margin-top: 5px; /* Spa»õiu √Æntre paragrafele de text normal */
    margin-bottom: 10px;
    line-height: 1.65;
}
/* AsigurƒÉ-te cƒÉ primul paragraf dupƒÉ un titlu nu are prea mult spa»õiu sus */
.feedback-entry-card .ai-main-section-title + .ai-text-paragraph {
    margin-top: 3px;
}
.feedback-entry-card .ai-list-item + .ai-text-paragraph {
    margin-top: 8px; /* Spa»õiu dacƒÉ un paragraf urmeazƒÉ dupƒÉ un item de listƒÉ */
}
    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -10px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            Spa»õiul tƒÉu pentru reflec»õie »ôi integrare.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (Op»õional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: Reflec»õii despre ziua de azi...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflec»õie (click pentru a insera):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <label for="journalContent" style="margin-top: 20px;">Intrarea ta √Æn jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="12" placeholder="Scrie liber aici... sau alege un ghid de mai sus."></textarea>
            
            <button type="button" id="saveJournalEntryButton">SalveazƒÉ »ôi Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul IntrƒÉrilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Carduri -->
    </div>
    
</body>
</html>