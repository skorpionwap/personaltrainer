<!DOCTYPE html>
<html>
<head>
    <title>Jurnal Terapeutic Personal - Psiho</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, getDoc, updateDoc, arrayUnion, arrayRemove, query, where, orderBy, limit, Timestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

    const firebaseConfig = {
        apiKey: "AIzaSyBn2bojEoV4_icF4fVVKFdJN1YjDhtlG98", // Înlocuiește cu cheia ta reală
        authDomain: "personaltrainer-74ea4.firebaseapp.com",
        projectId: "personaltrainer-74ea4",
        storageBucket: "personaltrainer-74ea4.appspot.com",
        messagingSenderId: "591778567441",
        appId: "1:591778567441:web:bbaeac19a3fb0f190668b0",
        measurementId: "G-WLWNGNDK5V",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const GEMINI_API_KEY = "AIzaSyAlm63krfJxBu1QR5ZmvA0rcGUnjm17sng"; // <--- ÎNLOCUIEȘTE AICI !!!
    const GEMINI_MODEL_NAME_JOURNAL_FEEDBACK = "gemini-2.5-flash-preview-04-17"; // Sau "gemini-1.5-flash-latest"
    let genAI, geminiModelJournalFeedback;

    console.log("Jurnal - Cheia API configurată:", "'" + GEMINI_API_KEY + "'");

    if (GEMINI_API_KEY && GEMINI_API_KEY.trim() !== "") { // Am eliminat verificarea .startsWith()
        try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
            geminiModelJournalFeedback = genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME_JOURNAL_FEEDBACK });
            console.log("Jurnal Terapeutic: SDK Gemini inițializat. Model Feedback Jurnal:", GEMINI_MODEL_NAME_JOURNAL_FEEDBACK);
        } catch (e) {
            console.error("Jurnal Terapeutic: Eroare critică la inițializarea SDK Gemini:", e);
            let alertMessage = "Eroare la inițializarea serviciului AI pentru jurnal. Verificați cheia API Gemini și configurația.";
            if (e.message && e.message.toLowerCase().includes("api key not valid")) {
                alertMessage = "Cheia API Gemini nu este validă sau nu are permisiuni pentru modelul de jurnal. Verificați Google Cloud Console.";
            } else if (e.message && e.message.toLowerCase().includes("quota")) {
                alertMessage = "Limita de utilizare pentru API-ul Gemini a fost atinsă (posibil pentru modelul de jurnal).";
            }
            alert(alertMessage + " Funcționalitatea AI va fi limitată.");
            geminiModelJournalFeedback = null;
        }
    } else  {
        console.warn(`Jurnal Terapeutic: Cheia API Gemini este goală sau lipsește. Funcționalitatea AI va fi dezactivată.`);
        alert("Jurnal Terapeutic: Cheia API Gemini nu este configurată. Funcționalitatea AI pentru jurnal va fi dezactivată.");
        geminiModelJournalFeedback = null;
    }

    let dataAlreadyLoaded = false;

    window.onload = function () {
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!dataAlreadyLoaded) {
                    incarcaIntrariJurnal(user.uid);
                    dataAlreadyLoaded = true;
                }
                initializeReflectionPrompts();
            } else {
                window.location.href = "login.html";
            }
        });
        document.getElementById("saveJournalEntryButton")?.addEventListener("click", salveazaIntrareJurnalSiGenereazaFeedback);
    };

    function initializeReflectionPrompts() {
        const promptsContainerEl = document.getElementById("reflectionPrompts");
        const journalTextarea = document.getElementById("journalContent");
        if (!promptsContainerEl || !journalTextarea) return;

        const prompts = [
            { label: "Explorează o emoție", text: "Astăzi vreau să explorez emoția de [NUMEȘTE EMOȚIA].\n\nCum se simte în corpul meu? [DESCRIE SENZAȚIILE]\nCe gânduri sunt asociate? [NOTEAZĂ GÂNDURILE]\nÎn ce context a apărut? [DESCRIE SITUAȚIA]\nCe nevoie ar putea semnala? [REFLECTEAZĂ]\nCum aș putea oferi compasiune? [ACȚIUNE COMPASIONALĂ]\n" },
            { label: "Analizează o situație", text: "Situația care mă preocupă este: [DESCRIE SITUAȚIA]\n\nCe s-a întâmplat exact? (Fapte)\nInterpretarea mea inițială: [GÂNDURI AUTOMATE]\nEmoțiile principale: [LISTEAZĂ EMOȚIILE]\nO altă perspectivă: [REFRAMING]\nCe am învățat/pot învăța? [LECȚII]\n" },
            { label: "Dialog Voce Critică", text: "Vocea mea critică îmi spune: \"[MESAJUL CRITIC]\"\n\nMă face să mă simt: [EMOȚII GENERATE]\nDin perspectiva Adultului Sănătos, aș răspunde: \"[RĂSPUNS COMPASIONAL]\"\nO nevoie ascunsă: [NEVOIA SUBIACENTĂ]\n" },
            { label: "Recunoștință & Resurse", text: "Astăzi sunt recunoscător/oare pentru:\n1. \n2. \n3. \n\nO resursă interioară pe care mă pot baza: \nUn gest de auto-îngrijire: \n" }
        ];
        promptsContainerEl.innerHTML = ''; // Clear previous
        prompts.forEach(prompt => {
            const button = document.createElement("button");
            button.textContent = prompt.label;
            button.className = "prompt-button";
            button.type = "button";
            button.title = "Inserează acest ghid în jurnal";
            button.onclick = () => {
                if (journalTextarea.value.trim() !== "" && !confirm("Vrei să înlocuiești textul curent cu acest ghid? OK pentru a înlocui, Anulare pentru a adăuga la sfârșit.")) {
                    journalTextarea.value += "\n\n---\n" + prompt.text;
                } else {
                    journalTextarea.value = prompt.text;
                }
                journalTextarea.focus();
                journalTextarea.scrollTop = journalTextarea.scrollHeight;
            };
            promptsContainerEl.appendChild(button);
        });
    }

    async function callGeminiAPI(promptText, modelToUse, generationConfigOptions = {}) {
        if (!modelToUse) return "EROARE: Model AI neinițializat (jurnal).";
        try {
            const result = await modelToUse.generateContent({
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.72, ...generationConfigOptions }
            });
            const response = result.response;
            if (response?.candidates?.[0]?.content?.parts?.[0]?.text) {
                if (response.candidates[0].finishReason && !["STOP", "MAX_TOKENS"].includes(response.candidates[0].finishReason)) {
                    return `EROARE Gemini: Generare oprită (Motiv: ${response.candidates[0].finishReason}).`;
                }
                return response.candidates[0].content.parts[0].text;
            } else if (response?.promptFeedback?.blockReason) {
                return `EROARE Gemini: Prompt blocat (Motiv: ${response.promptFeedback.blockReason}).`;
            }
            return "EROARE Gemini: Răspuns invalid/gol.";
        } catch (error) {
            console.error("Eroare callGeminiAPI (jurnal):", error);
            return `EROARE Gemini: ${error.message || "Eroare API."}`;
        }
    }

    async function genereazaSauRegenereazaFeedbackJurnal(entryData, entryId) {
        if (!geminiModelJournalFeedback) return "EROARE: Funcționalitatea AI pentru jurnal nu este disponibilă.";
        
        const promptJurnal = `
Rolul meu personalizat pentru PsihoGPT Jurnal (pentru uz personal, sunt în terapie):
"Ești PsihoGPT, asistentul meu personal AI pentru scriere terapeutică și auto-reflecție. Te consider un 'partener de dialog' informat de diverse școli psihoterapeutice (TCC, Scheme, ACT, IFS, Psihodinamică, Centrată pe Emoții). Scopul tău este să mă ajuți să adâncesc înțelegerea propriei mele experiențe, să identific tipare, să explorez perspective și să facilitez procesul de integrare emoțională. Abordarea ta este una de curiositate empatică, provocare blândă și rezonanță cu conceptele terapeutice. Am suport terapeutic uman, deci poți fi mai direct în reflecții și poți folosi termeni tehnici relevanți, atâta timp cât menții un ton suportiv și cald."

Intrarea mea de jurnal este:
Titlu: ${entryData.titlu}
Conținut:
---
${entryData.continut}
---

Te rog să-mi oferi un feedback structurat după cum urmează, adaptat pentru mine:
1.  **Sumar Empatic Concis:** (1-2 propoziții, validând esența emoțională sau tema principală.)
2.  **Observații Cheie și Tipare Identificate:** (2-4 puncte relevante, potențiale tipare de gândire, emoționale, sau comportamentale observate. Poți fi direct.)
3.  **Conexiuni Conceptuale (Opțional, unde e cazul):** (Menționează 1-2 concepte/modele psihoterapeutice care par a ilumina ce am scris. Ex: cum se manifestă o schemă, un mecanism de coping, o distorsiune cognitivă, o nevoie neîndeplinită, principii ACT etc.)
4.  **Întrebări Specifice pentru Aprofundare:** (2-3 întrebări deschise, tăioase dar constructive, care să mă invite la o reflecție mai profundă asupra celor scrise, bazate pe conținutul meu și pe conceptele identificate.)
5.  **Sugestie de Focalizare (pentru auto-lucru):** (O scurtă sugestie despre un aspect pe care l-aș putea explora mai departe în următoarea intrare, sau un micro-exercițiu de reflecție bazat pe discuția noastră. Ex: "Pentru următoarea intrare, ai putea explora [tema] din perspectiva [model terapeutic]".)

Folosește un limbaj clar, profesionist, dar empatic. Nu ezita să folosești termeni tehnici pe care i-am putea discuta în terapie. Mulțumesc!`;
        console.log("Trimitere prompt către Gemini (jurnal):", promptJurnal.substring(0, 100) + "...");
        const feedbackText = await callGeminiAPI(promptJurnal, geminiModelJournalFeedback);
        return proceseazaSiStructureazaFeedbackJurnal(feedbackText, entryId);
    }
    
    async function proceseazaSiStructureazaFeedbackJurnal(feedbackText, docId) {
        const parsedFeedback = {
            rawText: feedbackText,
            model: `Gemini (${GEMINI_MODEL_NAME_JOURNAL_FEEDBACK})`,
            timestamp: new Date().toISOString(),
            error: typeof feedbackText === 'string' && feedbackText.toUpperCase().startsWith("EROARE:")
        };
        if (docId) {
            try {
                await updateDoc(doc(db, "intrariJurnal", docId), {
                    feedbackAI_history: arrayUnion(parsedFeedback),
                    feedbackAI_latest: parsedFeedback
                });
                console.log(`Feedback AI (jurnal) salvat pentru ${docId}`);
            } catch (e) { console.error(`Eroare update feedback pt ${docId}:`, e); }
        }
        return parsedFeedback;
    }

    async function salveazaIntrareJurnalSiGenereazaFeedback() {
        const journalTextarea = document.getElementById("journalContent");
        const journalTitleInput = document.getElementById("journalTitle");
        if (!journalTextarea || journalTextarea.value.trim() === "") { alert("Scrie ceva în jurnal."); return; }

        const entryData = {
            continut: journalTextarea.value,
            titlu: (journalTitleInput?.value.trim() !== "") ? journalTitleInput.value.trim() : `Intrare din ${new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' })}`,
            timestampCreare: Timestamp.fromDate(new Date()),
            dataIntrare: new Date().toLocaleDateString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric' }),
            ownerUid: auth.currentUser?.uid
        };
        if (!entryData.ownerUid) { alert("Eroare autentificare."); return; }

        const saveButton = document.getElementById("saveJournalEntryButton");
        const originalButtonText = saveButton.textContent;
        saveButton.textContent = "Se salvează..."; saveButton.disabled = true;
        const confirmationMsg = document.getElementById('journalConfirmationMessage');

        try {
            const docRef = await addDoc(collection(db, "intrariJurnal"), entryData);
            saveButton.textContent = "Se generează AI...";
            const parsedFeedback = await genereazaSauRegenereazaFeedbackJurnal(entryData, docRef.id);
            
            const docSnapshot = await getDoc(docRef);
            if (docSnapshot.exists()) afiseazaCardJurnal({ id: docSnapshot.id, ...docSnapshot.data() });
            
            journalTextarea.value = ""; if (journalTitleInput) journalTitleInput.value = "";
            confirmationMsg.textContent = parsedFeedback.error ? `Intrare salvată. Feedback AI: ${parsedFeedback.rawText}` : 'Intrare salvată și feedback AI generat!';
            confirmationMsg.className = `confirmation-message ${parsedFeedback.error ? 'error' : 'success'}`;
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 9000);
        } catch (error) {
            console.error("Eroare la salvare/generare feedback jurnal:", error);
            confirmationMsg.textContent = 'Eroare la salvare sau generare feedback.';
            confirmationMsg.className = 'confirmation-message error';
            confirmationMsg.style.display = 'block';
            setTimeout(() => { confirmationMsg.style.display = 'none'; }, 7000);
        } finally {
            saveButton.textContent = originalButtonText;
            saveButton.disabled = false;
        }
    }
    
    async function regenereazaFeedbackJurnal(entryId) {
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .regenerate-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se generează..."; btn.disabled = true; }

        try {
            const entryDoc = await getDoc(doc(db, "intrariJurnal", entryId));
            if (!entryDoc.exists()) { alert("Intrarea nu există."); return; }
            await genereazaSauRegenereazaFeedbackJurnal(entryDoc.data(), entryId);
            
            const updatedDoc = await getDoc(doc(db, "intrariJurnal", entryId)); // Re-fetch
            if (updatedDoc.exists()) {
                const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
                const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
                if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, updatedDoc.data().feedbackAI_history || []);
            }
            alert("Feedback AI regenerat!");
        } catch (e) { console.error("Eroare regenerare:", e); alert("Eroare la regenerare feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }

    async function stergeUltimulFeedbackJurnal(entryId) {
        if (!confirm("Ștergi ultimul feedback AI pentru această intrare?")) return;
        const btn = document.querySelector(`.journal-card[data-id="${entryId}"] .delete-last-feedback-button`);
        const originalText = btn ? btn.textContent : "";
        if (btn) { btn.textContent = "Se șterge..."; btn.disabled = true; }

        try {
            const entryDocRef = doc(db, "intrariJurnal", entryId);
            const entrySnap = await getDoc(entryDocRef);
            if (!entrySnap.exists() || !entrySnap.data().feedbackAI_history?.length) {
                alert("Nu există feedback de șters."); return;
            }
            const history = entrySnap.data().feedbackAI_history;
            const lastFeedback = history.pop(); // Scoate ultimul și îl avem în `lastFeedback`

            await updateDoc(entryDocRef, {
                feedbackAI_history: history, // Salvează istoricul fără ultimul element
                feedbackAI_latest: history.length > 0 ? history[history.length - 1] : null 
            });
            
            const card = document.querySelector(`.journal-card[data-id="${entryId}"]`);
            const feedbackContainer = card?.querySelector('.ai-feedback-history-container');
            if (feedbackContainer) afiseazaIstoricFeedbackJurnal(feedbackContainer, history);
            alert("Ultimul feedback AI șters.");
        } catch (e) { console.error("Eroare ștergere ultim feedback:", e); alert("Eroare la ștergere feedback.");
        } finally { if (btn) { btn.textContent = originalText; btn.disabled = false; } }
    }
    
    function afiseazaIstoricFeedbackJurnal(containerEl, history) {
        containerEl.innerHTML = ''; 
        if (!history?.length) {
            containerEl.innerHTML = "<p style='font-style:italic;text-align:center;'>Niciun feedback AI generat.</p>"; return;
        }
        history.slice().reverse().forEach((entry, index) => { 
            const itemDiv = document.createElement("div");
            itemDiv.className = "feedback-entry-card";
            itemDiv.innerHTML = `
                <p class="feedback-timestamp"><strong>Feedback #${history.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO")} - ${entry.model || 'N/A'})</p>
                <p style="white-space: pre-wrap; ${entry.error ? 'color:red;font-weight:bold;' : ''}">${(entry.rawText || 'Conținut indisponibil.').replace(/\n/g, '<br>')}</p>
            `;
            containerEl.appendChild(itemDiv);
        });
    }

    function afiseazaIstoricFeedbackJurnal(containerEl, feedbackHistory) {
    containerEl.innerHTML = ''; // Golește containerul existent

    if (!feedbackHistory || !Array.isArray(feedbackHistory) || feedbackHistory.length === 0) {
        const noHistoryMsg = document.createElement("p");
        noHistoryMsg.textContent = "Niciun feedback AI generat pentru această intrare.";
        noHistoryMsg.style.fontStyle = "italic";
        noHistoryMsg.style.textAlign = "center";
        noHistoryMsg.style.padding = "10px 0";
        containerEl.appendChild(noHistoryMsg);
        return;
    }

    feedbackHistory.slice().reverse().forEach((entry, index) => {
        const itemContainer = document.createElement("div");
        itemContainer.className = "feedback-entry-card"; // Clasa generală pentru un card de feedback

        const timestampAndModel = document.createElement("p");
        timestampAndModel.className = "feedback-timestamp";
        timestampAndModel.innerHTML = `<strong>Feedback #${feedbackHistory.length - index}</strong> (${new Date(entry.timestamp).toLocaleString("ro-RO", { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' })} - ${entry.model || 'N/A'})`;
        itemContainer.appendChild(timestampAndModel);

        const contentWrapper = document.createElement("div"); // Un wrapper pentru conținutul AI
        contentWrapper.className = "content-ai"; // Pentru stilizarea generală a textului AI

        if (entry.error) {
            const errorP = document.createElement("p");
            errorP.style.color = "red";
            errorP.style.fontWeight = "bold";
            errorP.style.whiteSpace = "pre-wrap";
            errorP.innerHTML = (entry.rawText || "Eroare la generarea acestui feedback.").replace(/\n/g, '<br>');
            contentWrapper.appendChild(errorP);
        } else {
            let processedHTML = entry.rawText || 'Conținut indisponibil.';

            // Securizează HTML-ul brut înainte de a injecta regex-uri (minimal)
            // Acest pas este important dacă textul ar putea conține caractere care interferează cu HTML-ul.
            // Dar, pentru moment, ne bazăm că textul e predominant text simplu cu markdown-ul Gemini.
            // processedHTML = processedHTML.replace(/</g, "<").replace(/>/g, ">"); // Prea agresiv, strică dacă AI-ul AR da HTML

            // 1. Procesează Titlurile de Secțiune Principale (Ex: "1. **Sumar...**" sau "**Observații...**")
            // Caută linii care încep (opțional cu spații) cu un număr, punct, opțional spații, "**", text, "**"
            processedHTML = processedHTML.replace(/^(\s*\d+\.\s*\*\*)(.*?)(\*\*)/gm, '<div class="ai-main-section-title">$1$2$3</div>');
            // Caută linii care încep (opțional cu spații) cu "**", text, "**", DAR NU cele numerotate deja (evită dubla potrivire)
            processedHTML = processedHTML.replace(/^(\s*\*\*)(?!\s*\d+\.\s)(.*?)(\*\*)/gm, '<div class="ai-main-section-title">$1$2$3</div>');
            
            // 2. Procesează Elementele de Listă (Ex: "* Textul listei")
            // Caută linii care încep (opțional cu spații) cu un asterisc, un spațiu, apoi textul.
            // Regex-ul este conceput să încerce să prindă și continuarea item-ului pe linii noi,
            // până la o linie goală sau un nou item/titlu.
            processedHTML = processedHTML.replace(/^\s*(\*\s+((?:.|\n(?!\n\n|^\s*(\d+\.|\*\*|\*\s))))+))/gm, (match, listItemContent) => {
                // Eliminăm asteriscul și spațiul inițial din conținutul efectiv, pentru a nu-l afișa de două ori cu pseudo-elementul
                const cleanedItemContent = listItemContent.replace(/^\*\s+/, '');
                return `<div class="ai-list-item">${cleanedItemContent}</div>`;
            });


            // 3. După procesarea structurilor (titluri, liste), înlocuiește newline-urile rămase cu <br>
            // și înfășoară blocurile de text non-procesate în paragrafe pentru spațiere.
            // Acest pas este mai complex de făcut corect doar cu regex-uri pentru a nu strica HTML-ul deja format.
            // O abordare mai robustă ar fi să faci split pe \n și să construiești HTML-ul linie cu linie,
            // verificând dacă linia a fost deja procesată.
            // Pentru acum, o variantă simplificată:
            
            const lines = processedHTML.split('\n');
            let finalHtmlContent = "";
            let inParagraph = false;

            lines.forEach(line => {
                if (line.trim().startsWith('<div class="ai-main-section-title">') || line.trim().startsWith('<div class="ai-list-item">')) {
                    if (inParagraph) {
                        finalHtmlContent += '</p>'; // Închide paragraful anterior dacă există
                        inParagraph = false;
                    }
                    finalHtmlContent += line; // Adaugă direct div-ul procesat
                } else if (line.trim() === "") { // Linie goală
                    if (inParagraph) {
                        finalHtmlContent += '</p>';
                        inParagraph = false;
                    }
                     finalHtmlContent += '<br>'; // Poate fi un separator <p> </p> sau un div.spacer
                } else { // Linie de text normal
                    if (!inParagraph) {
                        finalHtmlContent += '<p class="ai-text-paragraph">';
                        inParagraph = true;
                    } else {
                         finalHtmlContent += '<br>'; // Pentru linii noi în interiorul aceluiași paragraf logic
                    }
                    finalHtmlContent += line;
                }
            });
            if (inParagraph) { // Închide ultimul paragraf dacă a rămas deschis
                finalHtmlContent += '</p>';
            }
            
            contentWrapper.innerHTML = finalHtmlContent;
        }
        itemContainer.appendChild(contentWrapper);
        containerEl.appendChild(itemContainer);
    });
}

    async function stergeIntrareJurnal(id, cardElement) {
        if (!confirm("Ștergi această intrare din jurnal și tot feedback-ul asociat?")) return;
        try {
            await deleteDoc(doc(db, "intrariJurnal", id));
            cardElement.remove();
            const container = document.getElementById("journalEntriesContainer");
            if(container && !container.querySelector('.journal-card')) { // Verifică dacă mai sunt carduri
                container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare în jurnal găsită.</p>`;
            }
        } catch (error) { console.error("Eroare ștergere intrare:", error); alert("Eroare la ștergere."); }
    }

    async function incarcaIntrariJurnal(userId) {
        const container = document.getElementById("journalEntriesContainer");
        if (!container || !userId) return;
        const loadingP = container.querySelector("p");
        if (!loadingP || !loadingP.textContent.includes("Se încarcă")) { // Adaugă loadingP doar dacă nu există deja și nu sunt carduri
             if(!container.querySelector('.journal-card')) {
                container.innerHTML = '<p style="text-align:center; margin-top:20px;">Se încarcă intrările...</p>';
             }
        }


        try {
            const q = query(collection(db, "intrariJurnal"), where("ownerUid", "==", userId), orderBy("timestampCreare", "desc"));
            const querySnapshot = await getDocs(q);
            
            const currentCards = {}; // Map for existing cards to avoid full re-render
            container.querySelectorAll('.journal-card').forEach(card => {
                currentCards[card.dataset.id] = card;
            });

            let hasNewData = false;
            const newDocs = [];

            querySnapshot.forEach((docSnap) => {
                newDocs.push({ id: docSnap.id, ...docSnap.data() });
                if (!currentCards[docSnap.id]) {
                    hasNewData = true;
                }
                delete currentCards[docSnap.id]; // Remove from map, remaining ones will be deleted
            });

            // Remove old cards that are no longer in Firestore
            Object.values(currentCards).forEach(oldCard => oldCard.remove());
            
            if (querySnapshot.empty) {
                if(!container.querySelector('.journal-card')) container.innerHTML = `<p style="text-align:center; margin-top:20px; font-style:italic;">Nicio intrare. Începe prin a scrie una!</p>`;
            } else {
                 if (container.querySelector("p") && container.firstChild.nodeName === 'P') container.innerHTML = ''; // Clear "Se încarcă..." sau "Nicio intrare..."
                 newDocs.forEach(docData => afiseazaCardJurnal(docData)); // Will update or add
            }

        } catch (error) {
            console.error("Eroare încărcare jurnal:", error);
            if(!container.querySelector('.journal-card')) container.innerHTML = '<p style="text-align:center; color:red;">Eroare încărcare jurnal.</p>';
        }
    }
    </script>
    <style>
    /* Reset și Stiluri Generale */
    *, *::before, *::after { box-sizing: border-box; }
    body {
        font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        margin: 0; padding: 20px; background: #f4f7f9; /* Un gri mai deschis și modern */
        color: #333a40; /* Text mai închis pentru contrast */
        line-height: 1.6; font-size: 16px; /* O bază bună */
    }
    .journal-form-container {
        max-width: 760px; margin: 30px auto; background: #fff; padding: 30px 35px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.07); border-radius: 10px;
    }
    h2, h3 {
        color: #2c3840; text-align: center; margin-bottom: 20px; font-weight: 500;
    }
    h2 { font-size: 1.8em; margin-bottom: 10px; }
    h3 { font-size: 1.5em; margin-top: 40px; }
    label { display:block; margin-bottom: 6px; font-weight: 500; color: #455058; font-size: 0.95em;}
    
    /* Formular */
    textarea#journalContent, input#journalTitle {
        width: 100%; padding: 12px 15px; margin-bottom: 15px; font-size: 1em;
        font-family: inherit; border-radius: 6px; border: 1px solid #d5dde5;
        transition: border-color 0.2s, box-shadow 0.2s;
    }
    textarea#journalContent { min-height: 200px; line-height: 1.65; }
    textarea#journalContent:focus, input#journalTitle:focus {
        border-color: #5c85d6; box-shadow: 0 0 0 3px rgba(92, 133, 214, 0.15); outline: none;
    }
    
    /* Butoane Prompt Reflecție */
    #reflectionPromptsContainer { margin: 15px 0 20px 0; padding: 12px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid #e8ecf0; }
    #reflectionPromptsContainer p { margin-top: 0; margin-bottom: 10px; font-weight: 500; color: #4a5560; font-size: 0.9em; }
    .prompt-button-group { display: flex; flex-wrap: wrap; gap: 8px; }
    button.prompt-button {
        background-color: #e7f0ff; color: #4a69bd; border: 1px solid #cddcff;
        padding: 6px 12px; font-size: 0.8em; font-weight: 500; border-radius: 16px;
        cursor: pointer; transition: all 0.2s; margin-top: 0; box-shadow: none;
    }
    button.prompt-button:hover { background-color: #d6e4ff; color: #3a539b; transform: translateY(-1px); }

    /* Buton Principal Salvare */
    button#saveJournalEntryButton {
        display: block; width: 100%; margin-top: 15px; padding: 12px 20px;
        font-size: 1.05em; font-weight: 500; background: #5c85d6; color: white;
        border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s;
        box-shadow: 0 2px 5px rgba(92, 133, 214, 0.2);
    }
    button#saveJournalEntryButton:hover:not(:disabled) { background-color: #4a6fb5; transform: translateY(-1px); box-shadow: 0 3px 7px rgba(92, 133, 214, 0.25); }
    button#saveJournalEntryButton:disabled { background: #aebfD4 !important; color: #707c8b !important; cursor: not-allowed !important; box-shadow: none !important; }

    /* Mesaj Confirmare */
    .confirmation-message { display: none; text-align: center; padding: 12px; border: 1px solid transparent; border-radius: 6px; margin-top: 18px; animation: fadeIn 0.4s; font-weight: 500; font-size: 0.95em;}
    .confirmation-message.success { background-color: #e6f4ea; color: #1e6a39; border-color: #b3d9c0; }
    .confirmation-message.error { background-color: #fdebea; color: #b32d21; border-color: #f8c6c1; }
    @keyframes fadeIn { 0% {opacity: 0; transform: translateY(8px);} 100% {opacity: 1; transform: translateY(0);} }
    
    /* Vizualizare Carduri */
    .card-view {display: flex; flex-direction: column; gap: 20px; max-width: 760px; margin: 25px auto;}
    .response-card { background: #ffffff; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.06); overflow: hidden; }
    .response-card .card-header {
        font-weight: 500; font-size: 1.05em; cursor: pointer; background: #fdfdfe;
        padding: 12px 20px; color: #3a4550; border-bottom: 1px solid #eaeff3;
        display: flex; justify-content: space-between; align-items: center;
    }
    .response-card .card-header::after {content: '▼'; font-size: 0.75em; transition: transform 0.2s ease; color: #707c8b;}
    .response-card.open .card-header::after {transform: rotate(180deg);}
    .response-card .card-content { max-height: 0; padding: 0 20px; overflow-y: auto; transition: all 0.4s ease-in-out; } 
    .response-card.open .card-content { max-height: 5000px; padding: 18px 20px; }
    .response-card .card-content p {margin-bottom: 10px; color: #455058;}
    .response-card .card-content p.journal-entry-content { white-space: pre-wrap; font-size: 1em; line-height: 1.65;}
    .response-card .card-content p strong {font-weight: 600; color: #2c3840;}
    .response-card h4 {
        color: #5c85d6; font-weight: 500; margin-top: 20px; margin-bottom: 12px; font-size: 1em;
        border-bottom: 1px solid #e6eaee; padding-bottom: 6px;
    }
    .response-card h4:first-child {margin-top: 0;}
     .ai-feedback-history-container { margin-top: 8px; }
    .feedback-entry-card { background:#f8f9fc; padding:12px; border-left:3px solid #5c85d6; border-radius:6px; margin-bottom:12px; font-size:0.9em; line-height:1.55; }
    .feedback-timestamp { color:#606f7b; font-size:0.8em; margin-bottom:8px; font-style: italic; }
    .card-actions { text-align: right; margin-top: 18px; padding-top: 12px; border-top: 1px solid #eaeff3; display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }
    .card-actions button {
        padding: 7px 14px; font-size: 0.8em; font-weight:500; border-radius: 5px;
        transition: all 0.2s; margin-top: 0; /* Suprascrie margin-top general */
    }
    button.delete-journal-entry-button { background-color:transparent; color: #c0392b; border: 1px solid #f1c0ba;}
    button.delete-journal-entry-button:hover { background-color: #c0392b; color: white; border-color: #c0392b;}
    button.regenerate-feedback-button { background-color:transparent; color: #228b22; border: 1px solid #b3d9b3;}
    button.regenerate-feedback-button:hover { background-color: #228b22; color: white; border-color: #228b22;}
    button.delete-last-feedback-button { background-color:transparent; color: #d39e00; border: 1px solid #ffe180;}
    button.delete-last-feedback-button:hover { background-color: #d39e00; color: white; border-color: #d39e00;}
    
    /* Responsive */
    @media (max-width: 768px) {
        body {padding:15px; font-size: 15px;}
        .journal-form-container, .card-view {padding:20px; margin: 20px auto;}
        h2 {font-size: 1.6em;} h3 {font-size: 1.3em;}
        .card-actions {justify-content: center;}
        .card-actions button { flex-basis: calc(50% - 4px); /* Două pe rând, cu gap */}
    }
    @media (max-width: 480px) {
        body {padding:10px; font-size: 14px;}
        .journal-form-container, .card-view {padding:15px;}
        h2 {font-size: 1.4em;} h3 {font-size: 1.2em;}
        textarea#journalContent { min-height: 180px; }
        .prompt-button-group {gap: 6px;}
        button.prompt-button {padding: 5px 10px; font-size: 0.75em;}
        button#saveJournalEntryButton {padding: 10px 18px; font-size: 1em;}
        .card-actions button { flex-basis: 100%; margin-left: 0;}
    }
/* === STILURI NOI PENTRU COSMETIZAREA FEEDBACK-ULUI AI === */

.feedback-entry-card .content-ai { /* Adaugă o clasă nouă la paragraful care conține textul AI în JS */
    font-size: 0.98em; /* Ajustează după preferință */
    line-height: 1.65;
    color: #3a4a58; /* O culoare de text puțin mai soft */
}

/* 
   Pentru a stiliza titlurile și listele, vom folosi o abordare combinată:
   1. În JavaScript, când primești `rawText` de la AI, ai putea să-l procesezi puțin
      pentru a înfășura titlurile de secțiune și listele în tag-uri HTML simple DUPĂ ce le-ai primit,
      înainte de a le afișa. Acest lucru ar oferi cel mai bun control.

   Exemplu de procesare în JavaScript (în funcția afiseazaIstoricFeedbackJurnal):
   let aiHtml = entry.rawText.replace(/\n/g, '<br>'); // Păstrează newlines ca <br>
   // Evidențiază titlurile (ex: "1. **Sumar Empatic Concis:**" sau "**Conexiuni Conceptuale:**")
   aiHtml = aiHtml.replace(/(\d+\.\s*\*\*|^\*\*)(.*?)(\*\*)/g, '<strong class="ai-section-title">$1$2$3</strong>');
   // Evidențiază elementele de listă (ex: "* Ai identificat...") - puțin mai tricky fără a strica formatarea
   // S-ar putea să fie mai simplu să stilizezi paragrafele care încep cu "* " direct în CSS
   
   Dacă NU vrei să modifici JavaScript-ul pentru a adăuga HTML, CSS-ul de mai jos 
   este o încercare de a stiliza pe baza textului brut, dar este mai limitat.
*/

/* Varianta 1: Fără procesare JS a textului AI (mai limitată) */
.feedback-entry-card p[style*="white-space: pre-wrap"] strong { /* Orice text bold în feedback */
    font-weight: 600; /* Ubuntu are un bold bun la 500-700 */
    color: #2c3e50; 
}

/* Încercare de a stiliza titlurile de secțiune - acest selector e general */
/* Ar fi mai bine dacă ai putea înfășura titlurile într-un <span> sau <strong> cu o clasă */
.feedback-entry-card p[style*="white-space: pre-wrap"] br + strong, /* Un strong după un <br> poate fi un titlu */
.feedback-entry-card p[style*="white-space: pre-wrap"] > strong:first-child { /* Primul strong din paragraf */
    /* Acest lucru e foarte speculativ și depinde de cum Gemini structurează */
}

/* Varianta 2: Cu procesare minimă în JS pentru a adăuga clase (RECOMANDATĂ) */
/* 
Presupunem că în funcția `afiseazaIstoricFeedbackJurnal` ai făcut:
let processedText = entry.rawText;
// Titlurile principale de secțiune (ex: "1. **Sumar Empatic Concis:**" sau "**Observații Cheie:**")
processedText = processedText.replace(/^(\d+\.\s*\*\*.*?\*\*)/gm, '<div class="ai-main-section-title">$1</div>'); // Titluri numerotate
processedText = processedText.replace(/^(\*\*[^:\n]+?\*\*)/gm, (match, p1) => { // Titluri non-numerotate (ex: **Conexiuni:**)
    if (!match.match(/^\d+\./)) { // Asigură-te că nu e deja capturat de regex-ul anterior
        return '<div class="ai-main-section-title">' + p1 + '</div>';
    }
    return match; 
});

// Elementele de listă (ex: "* Textul listei")
processedText = processedText.replace(/^\s*(\*\s+.*)/gm, '<div class="ai-list-item">$1</div>');

// Apoi înlocuiești \n cu <br> DUPĂ ce ai aplicat transformările de mai sus, DAR cu grijă la <br>-urile din div-uri
// Este mai sigur să faci split pe \n și să înfășori fiecare linie într-un <p> sau <div> dacă nu e goală
// SAU să lași `white-space: pre-wrap` și să stilizezi pe baza selectorilor de mai jos.
// Cel mai robust: procesezi liniile și înfășori ce trebuie în div-uri cu clase, apoi faci .innerHTML = processedHTML;
// ---
// Pentru HTML final: contentP.innerHTML = processedText.replace(/\n/g, '<br>'); // după ce ai adăugat clasele.
*/

.feedback-entry-card .ai-main-section-title { /* Dacă ai adăugat clasa .ai-main-section-title în JS */
    display: block; /* Asigură că este pe linia proprie */
    font-weight: 600; /* Ubuntu medium-bold */
    color: #5c85d6; /* Culoarea ta accent */
    margin-top: 18px;
    margin-bottom: 8px;
    font-size: 1.05em;
    /* border-bottom: 1px dashed #d5dde5; */ /* Opțional, o linie subtilă */
    padding-bottom: 3px;
}
.feedback-entry-card .ai-main-section-title:first-child {
    margin-top: 5px; /* Mai puțin spațiu pentru primul titlu */
}

/* Stil pentru textul bold standard din AI care NU este un titlu principal */
.feedback-entry-card p strong:not(.ai-main-section-title *) { /* Să nu stilizăm ce e deja în titlu */
    font-weight: 500; /* Ubuntu medium */
    color: #3a4a58;
}

/* Stil pentru elementele de listă dacă le-ai înfășurat într-un div cu clasa .ai-list-item */
.feedback-entry-card .ai-list-item {
    display: block; /* Fiecare pe linia sa */
    margin-left: 20px; /* Indentare */
    margin-bottom: 6px;
    position: relative; /* Pentru pseudo-elementul `::before` */
    padding-left: 18px; /* Spațiu pentru bullet */
    line-height: 1.6;
}

.feedback-entry-card .ai-list-item::before {
    content: "•"; /* Bullet point */
    color: #5c85d6; /* Culoarea accent */
    font-weight: bold;
    display: inline-block; 
    position: absolute;
    left: 0;
    top: 0; /* Ajustează fin dacă e necesar */
}

/* Dacă nu poți adăuga clasa .ai-list-item, poți încerca să stilizezi direct
   paragrafele care ȘTII că vor începe cu "* ", dar e mai puțin fiabil.
   Exemplu:
.feedback-entry-card p[style*="white-space: pre-wrap"]::first-line { 
    // Acest lucru e foarte problematic dacă ai și text normal înainte de listă în același <p>
}
*/
/* === STILURI NOI PENTRU COSMETIZAREA FEEDBACK-ULUI AI (continuare) === */

.feedback-entry-card .ai-text-paragraph {
    margin-top: 5px; /* Spațiu între paragrafele de text normal */
    margin-bottom: 10px;
    line-height: 1.65;
}
/* Asigură-te că primul paragraf după un titlu nu are prea mult spațiu sus */
.feedback-entry-card .ai-main-section-title + .ai-text-paragraph {
    margin-top: 3px;
}
.feedback-entry-card .ai-list-item + .ai-text-paragraph {
    margin-top: 8px; /* Spațiu dacă un paragraf urmează după un item de listă */
}
    </style>
</head>
<body>

    <div class="journal-form-container">
        <h2>Jurnal Terapeutic Personal</h2>
        <p style="text-align: center; margin-top: -10px; margin-bottom: 25px; font-size: 0.9em; color: #556575;">
            Spațiul tău pentru reflecție și integrare.
        </p>
    
        <form id="therapeuticJournalForm" onsubmit="return false;">
            <label for="journalTitle">Titlu (Opțional):</label>
            <input type="text" id="journalTitle" name="journalTitle" placeholder="Ex: Reflecții despre ziua de azi...">
            
            <div id="reflectionPromptsContainer" style="margin-top: 20px;">
                <p>Puncte de start pentru reflecție (click pentru a insera):</p>
                <div class="prompt-button-group" id="reflectionPrompts">
                    <!-- Butoanele vor fi generate de JavaScript -->
                </div>
            </div>

            <label for="journalContent" style="margin-top: 20px;">Intrarea ta în jurnal:</label>
            <textarea id="journalContent" name="journalContent" rows="12" placeholder="Scrie liber aici... sau alege un ghid de mai sus."></textarea>
            
            <button type="button" id="saveJournalEntryButton">Salvează și Cere Feedback AI</button>
        </form>

        <div id="journalConfirmationMessage" class="confirmation-message"></div>
    </div>
    
    <h3>Istoricul Intrărilor din Jurnal</h3>
    
    <div class="card-view" id="journalEntriesContainer">
        <!-- Carduri -->
    </div>
    
</body>
</html>